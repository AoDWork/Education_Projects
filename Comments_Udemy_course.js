{//  ====    МЕТОДЫ ОТ SNIEDA    ==== 

    //++++++++++++++++++++++++ СТРОКИ ++++++++++++++++++++
    
    let str = 'Hello , World !';
    
    str.length // 15 Длина строки ( 15 элементов) последний элемент под индексом 14
    
    str.charAt(0); // 'H' - Возвращает букву под индексом 0
    str[0]; // 'H'
    
    str.charCodeAt(0); // 72 - код буквы
    

    str.concat (33); // 'Hello , World !33' - присоединяет к строке
    str.concat ([1,2,4]); // 'Hello , World !1,2,4'
    str.concat ({a:1, b:2}); //'Hello , World ![object Object]'
    

    str.startsWith('Hello') //true  Проверяет содержит ли строка это выражение в начале
    str.startsWith('ello'); //false
    str.startsWith('hello') //false регистр влияет
    str.startsWith('Hello', 1) //false Можхно задать начальный индекс поиска
    
    str.endsWith("!"); // true, Проверяет с конца строки, можно задать индекс
    str.endsWith("!", 10); //false
    

    str.includes('Hello') //true Проверяет содержится ли где то в строке такая подстрока
    str.includes('o') // true  Ищет по всей строке, а не только сначала
    str.includes('o', 13) //false можно указать индек с какого начинать искать
    
    str.indexOf('o') //4 Возвращает индекс первого совпадения
    str.indexOf('o', 5) //9 Можно задать начальный индекс, тогда вернет индекс следующего совпадения
    str.indexOf('y') // -1  При отсутствии совпадений возвращает минус 1
    

    str.slice() //'Hello , World !' - Обрезает строку и возвращает обрезанную. Если не указать индексы вернет всю строку
    str.slice(0, 5) //'Hello' Обрезает с 0 до 5го индекса НЕ включая 5й индекс
    str.slice(-7, -3) //'Worl' Принимает отрицательные числа
    str.slice(7) //' World !' указывая один первый индекс, возвратит строку обрезанную с 7го символа *включительно до конца

    str.substr(1, 8); //'ello , W' Обрезает строку и возвращает обрезанную. 
    //Первый аргумент - начальный индекс, второй - количество символов которые нужно вернуть
    

    str.split() // ['Hello , World !'] - возвращает массив, разделенный заданным разделителем. Тут нету разделителя. 1 элем
    str.split('') //['H', 'e', 'l', 'l', 'o', ' ', ',', ' ', 'W', 'o', 'r', 'l', 'd', ' ', '!'] Разделитель - пустая строка. 15 элем
    str.split(' ') // ['Hello', ',', 'World', '!'] Разделитель - пробел. 4 элемента
    str.split(',') // ['Hello ', ' World !'] Разделитель - запятая.  2 элемента
    str.split('o') // ['Hell', ' , W', 'rld !'] 3 элемента, разделитель удаляется и отсутствует в возвращенном массиве
    
    
    str.toLowerCase()  // 'hello , world !'  Возвращает новую строку в нижнем регистре      ***НЕ ИЗМЕНЯЕТ исходную строку.
    str.toUpperCase()  // 'HELLO , WORLD !'  В верхнем  регистре.                           ***НЕ ИЗМЕНЯЕТ исходную строку.
    
    
    let str2 = '     Hello , World !     ';
    
    str2.trim() //'Hello , World !'  Убирает пробелы в начале и в конце текста
    str2.trimStart() //'Hello , World !     ' - Только в начале
    str2.trimEnd() // '     Hello , World ! ' - Только в конце
    
    
    
    //++++++++++++++++++++++ МАССИВЫ ++++++++++++++++++++
    
    let arr = ["one", 'two', 'three', 'four', 'five'];
    
    arr.push(100) // 6 (показывает сколько элементов теперь содержит массив) - Добавляет переданные элементы в КОНЕЦ массива,
                                                                                //прадварительно превращая его в строку
    // ['one', 'Two', 'Three', 'Four', 'Five', 100] -                                    ***ИЗМЕНЯЕТ исходный массив

    console.log(arr.push(['six'])); // 7 Возвращает новое количество элементов, добавляет массив ['six'] как вложенный
    //['one', 'two', 'three', 'four', 'five', 100, Array(1)]                            ***ИЗМЕНЯЕТ исходный массив
    
    arr.push({a:1}) //8 ['one', 'two', 'three', 'four', 'five', 100, Array(1), {…}]     ***ИЗМЕНЯЕТ исходный массив
    
    arr.pop() //{a: 1} - Удаляет один последний элемент и возвращает его значение       ***ИЗМЕНЯЕТ исходный массив
    
    arr.unshift(1, 2) //9 - Добавляет элементы в начало массива, возвращает колличество элем.  
    //[1, 2, 'one', 'two', 'three', 'four', 'five', 100, Array(1)]                       ***ИЗМЕНЯЕТ исходный массив
    
    arr.shift(); //1   Удаляет первый элемент и возвращает его
    //[ 2, 'one', 'two', 'three', 'four', 'five', 100, Array(1)]                          ***ИЗМЕНЯЕТ исходный массив
    
    arr.concat([1, 2]); // Добавляет эл. в конец массива как push, но если добавим массив то он добавляет его элементы, а не сам 
                                                                                                                        //массив. 
    //(10) [2, 'one', 'two', 'three', 'four', 'five', 100, Array(1), 1, 2] ***НЕ ИЗМЕНЯЕТ исходный массив, а возвращает ***НОВЫЙ
    
    
    
    // ++++++++ Методы ПЕРЕБОРА массива forEach, map, some, every, find, findIndex, filter, reduce +++++++++++++++

    //Каждый из этих методов проходится по массиву от начала и до конца и принимает коллбэк функцию в качестве параметра(аргумента)
    arr = [1, 2, 3, 4, 5];
    

    // 1) forEach - перебирает эл. массива.  Аргументы el - элемент, ind - индекс, arr - массив.    ***МОЖЕТ ИЗМЕНЯТЬ исходный массив
        // ind и arr - указываем если хотим их использовать, имена произвольны.
        arr.forEach((el, ind, arr) => {
            console.log(`Element ${el}, Index: ${ind}, Massive: ${arr}`);
        })
        
        arr.forEach((elem, index) => {
            console.log(`Element ${elem}, Index: ${index} in this massive`);
        })
        //  Element 1, Index: 0 in this massive
        //  Element 2, Index: 1 in this massive
        //  Element 3, Index: 2 in this massive
        //  Element 4, Index: 3 in this massive
        //  Element 5, Index: 4 in this massive 

        // Так изменит свой же массив
        arr.forEach((el, ind) => {
            arr[ind] = el + 50;
        }) 
            console.log(arr); // [51, 52, 53, 54, 55]

    
    
    // 2) map - обязан вернуть значение поэтому прописываем return. ***возвращает НОВЫЙ массив, для хранения присваиваем переменной
        
        const mapArr = arr.map((el, ind, arr) => {
            return el * 2 + ind
        });
        //mapArr (5) [2, 5, 8, 11, 14]      при этом       arr  (5) [1, 2, 3, 4, 5];
        
    
    // 3) some Проверяет есть ли в массиве заданное условие, если хоть одно истинно возвращает true, если нет false
        
        const checkSome = arr.some ((el, ind, arr) => {
            return el > 1
        }) // true
    
    
    // 4) every Проверяет истину условия для каждого елем. если хоть один элем. не подходит, прекращает выполнение и возвращает false
        
        const checkEvery = arr.every ((el, ind, arr) => {
            return el > 1
        }) // false
    

    // includes Проверяет содержится ли где то в массиве такая подстрока. Возвращает - true / false
        
        arr.includes('new') //true
        arr.includes('new', 5) //false - второй параметр - начальный индекс поиска

    

    // 5) find - позволяет найти эл. в массиве и возвращает его (проверка останавливается на нем), если элемента нет - undefined
        
        const foundElem = arr.find((el, ind, arr) => {
            return el === 1
        }) // 1
    
    
    
    // 6) findIndex - возвращает индекс первого найденого элемента, если элемента нет - undefined
        
        const foundIndex = arr.findIndex ((el, ind, arr) => {
            return el === 1
        }) // 0
    

    
    // 7) filter - проверяет эл. на соответствие условию и ***возвращает НОВЫЙ массив с подходящими по условию элементами 
        
        const filterArr = arr.filter((el, ind, arr) => {
            return el > 3
        }) //(2) [4, 5]
    

    
    // 8) reduce - возвращает сумму всех элементов массива в ***НОВЫЙ. sum - переменная в которую ложится сумма(название 
        //произвольное)  init - можно задать значение по умолчанию для sum (0, 10, функцию, объект)
    
        const arrReduce = arr.reduce((sum, el, ind, arr) => {
            return sum + el
        }, init);   
        
        const arrReduce = arr.reduce((total, el) => {
            return total + el
        }, 0);  // 15
    


    //++++++++ ++++++++ ++++++++ ++++++++
    

    // flat - возвращает ***НОВЫЙ массив в котором раскрывает 1 степень вложенности массива   ***НЕ ИЗМЕНЯЕТ исходный массив
        const arr2 = [0, [1, 2], [3, [4, 5], [6, 7] ] ];  //  [0, Array(2), Array(3)]
        const arrFlat = arr2.flat(); // (6) [0, 1, 2, 3, Array(2), Array(2)]
        arrFlat.flat(); // (8) [0, 1, 2, 3, 4, 5, 6, 7]    Можно записать как arr.flat().flat()
    

    // indexOf Возвращает индекс элемента. первый аргумент - искомый элемент, второй - с какого индекса начинать искать
        arr.indexOf(1); // 0
        arr.indexOf("six"); // -1  - если не найдено совпадений
        arr.indexOf(1, 1); // -1
    


    // lastIndexOf - Начинает искать с конца массива. первый аргумент 
        arr.lastIndexOf(1); // 0
        arr.push(1);
        arr.lastIndexOf(1); //5
        arr.lastIndexOf(1, 1); //0
        arr.lastIndexOf("six"); // -1
    


    /* slice - обрезает часть массива и возвращает обрезанный кусок в виде массива. 1 аргум - с какого обрезать, 2й - до какого
                                                                                     ***НЕ ИЗМЕНЯЕТ исходный массив  */
        arr.slice(1, 5); // (4) [2, 3, 4, 5]
        arr.slice();     //(6) [1, 2, 3, 4, 5, 1]
        
    //fill - заполняет массив заданным аргументом - 1й, 2й - с какого по какой 3й аргумент заполнить  ***ИЗМЕНЯЕТ исходный массив
        
        arr.fill(0) // (6) [0, 0, 0, 0, 0, 0]
        arr.fill(1, 0, 3) // (6) [1, 1, 1, 0, 0, 0]
    
    // join - преобразует массив в строку с разделителем который принимает. Возвращает строку. ***НЕ ИЗМЕНЯЕТ исх. массив
        
        arr.join() // '1,1,1,0,0,0'
        arr.join('') //'111000' - пустая строка
        arr.join(' ') //'1 1 1 0 0 0'   пробел
    
    // reverse - изменяет порядок эл. массива на обратный. ***ИЗМЕНЯЕТ исходный массив
        reverse()  //(6) [0, 0, 0, 1, 1, 1]
    

    // sort - сортирует эл. массива. 2 аргумента а и b. Сортировка от меньшего к большему a - b, b - a - от большего к меньшему
    
        let arr3 = [10, 5, 2, 15, 11];                  //   Имена произвольные         ***ИЗМЕНЯЕТ исходный массив
        arr3.sort((a, b) => {
            return a - b
        })

        let arr = [2, 1, 3, 15, 6, 5, 4];
        let arr2 = ['Banana', 'Orange', 'Apple', 'Mango'];
        arr2.sort(); //['Apple', 'Banana', 'Mango', 'Orange'] - сортирует элементы в массиве в алфавитном порядке по первой букве
        arr.sort(); // [1, 15, 2, 3, 4, 5, 6]; - (если цифры то они тоже воспринимаются как строка и сравнение происходит по
                                                    //первой цифре)           
            /*Чтобы числа сортировало по возрастанию(как числа), нужно добавить вспомогательную функцию, она принимает параметры - 
                а и b - это соседние элементы массива, при первой итеррации это будут 2 и 1, при второй 1 и 3, и т.д. Функция
                каждый раз возвращает разницу этих элементов а - b, если разница плюсовое число, элементы массива меняются местами,
                если равна 0 или отрицательная то элементы остаются на своих местах.*/
            arr.sort((a, b) => {
                return a - b
            });                 //// [1, 2, 3, 4, 5, 6, 15];

    

    // splice - заменяет определенные эл. массива задаными, возвращает удаленные элем.   ***ИЗМЕНЯЕТ исходный массив
        // 1й аргумент - начальный индекс, 2й - сколько эл. удалить, следующие аргум - добавляемые элем.(может быть больше чем удаляемых)
                arr.splice(3, 2, 'two', 'three', 'four') // (2) [1, 1]  
        arr //(7) [0, 0, 0, 'two', 'three', 'four', 1]
        arr.splice(3, 3, 'new') //(3) ['two', 'three', 'four']
        arr //(5) [0, 0, 0, 'new', 1]
        arr.splice(1, 0, 2) //[]            - не удаляли эл. , а только вставили в индекс 1
        arr //(6) [0, 2, 0, 0, 'new', 1]
        arr.splice(0, 1) // Удалит 1 елемент в 0м индексе
    
   
    
    //++++++++++++++++++++++ ОБЪЕКТЫ ++++++++++++++++++++
        
        const obj1 = {
            name: 'Maks',
            age: 33,
            hi: function() {console.log(this.name);}
        };

        const obj2 = {
            country: 'Ua',
            skills: ['html', 'css', 'js'],
            obj: {name2: 'Vladimir'}
        };
        const targetObj = {};
    
    
    // Object.assign()  - Копирует свойства, методы и ОБЪЕКТЫ объектов в другой объект. Обращаемся к глобальному классу Object
    // Object.assign(target, source); - 1й объект куда копируем, 2й из которого копируем
    
        Object.assign(targetObj, obj1, obj2);  // копируемых объектов может быть несколько
        targetObj //{name: 'Maks', age: 33, country: 'Ua', skills: Array(3), hi: ƒ}
        const person = Object.assign({}, obj1, obj2); // присваиваем константе, аргумент - пустой объект
        person    //{name: 'Maks', age: 33, country: 'Ua', skills: Array(3), hi: ƒ}
        Object.assign(obj1, obj2);//                                                
        obj1      //{name: 'Maks', age: 33, country: 'Ua', skills: Array(3), hi: ƒ}   ***ИЗМЕНЯЕТ исходный массив obj1
    
    

    //Object.entries(obj) - принимает объект и возвращает массив с вложенными массивами
    
        Object.entries(obj2); //(3) [Array(2), Array(2), Array(2)]
        // 0: (2) ['country', 'Ua'] 1: (2) ['skills', Array(3)] 2: (2) ['obj', {…}]
        //Вложенные массивы и объекты обекта - сохраняют свою структуру
    

    
    //Object.fromEntries([]) - принимает массив с лож. массивами и вернет объект
    
        const obj3 = Object.fromEntries([['name', 'John'],['age', 44]]); // {name: 'John', age: 44}
        obj3 // {name: 'John', age: 44}
    
    

    //Object.is(el1, el2) - определяет являются ли оданиковыми эти два значения, возвращает true / false
    
        Object.is(1, 2) //false
        Object.is(1, 1) //true
        Object.is(1, '1') //false
        Object.is(NaN, NaN) //true  - только при этой проверке NaN равняется NaN
    
    

    //Object.keys(obj) - возвращает массив из ключей (название свойств, методов, объектов объекта)
    
        Object.keys(obj3) //(2) ['name', 'age']
        Object.keys(obj2) //(3) ['country', 'skills', 'obj']
        
        

    //Object.values(obj) - возвращает массив из значений (сохраняет структуру вложенных ассивов и объектов)
    
        Object.values(obj3) //(2) ['John', 44]
        Object.values(obj2)  // (3) ['Ua', Array(3), {…}]
    
    

    // ++++++++  ПРИСВОЕНИЕ в ОБЪЕКТАХ    bind, call, apply - позволяют изменить контекст вызова (изменить this)
    
    const person1 = {
        name: 'Maks',
        age: 33,
        getInfo: function(country, standart) {
            if(standart){
            return `Hi, my name is ${this.name}, i'm from ${standart}`
            }else{
            return `Hi, my name is ${this.name}, i'm from ${country}`};}
    };
    const person2 = {
        name: 'Oleg',
        age: 18,
    };
    
    
    /* 1) bind - возвращает метод присвоенного объекта(присоединяет метод одного объекта к контексту другого)
        obj1.method.bind(obj2)() -  obj2 - объект контекст которого используем для метода obj1
        
        console.log(person1.getInfo('Ua')); // Hi, my name is Maks, i'm from Ua
        console.log(person2.getInfo('Ua')); // Получаем ошибку
        
        console.log(person1.getInfo.bind(person2)); // ƒ (country) {return `Hi, my name is ${this.name}, i'm from ${country}`}
                                        не срабатывает как нужно потому что в country передается объект, а в стандарт ничего.
        console.log(person1.getInfo.bind(person2)('Ukr')); // Hi, my name is Oleg, i'm from Ukr - вызываем функцию
                                        Срабатывает потому что передается два аргумента.

            Может принимать несколько параметров
        console.log(person1.getInfo.bind(person2)('Ukr', 'Ukraine')); //// Hi, my name is Oleg, i'm from Ukraine
            или
        console.log(person1.getInfo.bind(person2, 'Ukr', 'Ukraine')()); //// Hi, my name is Oleg, i'm from Ukraine
        
        const getInfoPerson2 = person1.getInfo.bind(person2); // присваиваем метод переменной для сокращения вызова
        console.log(getInfoPerson2("Ru")) // "Hi, my name is Oleg, i'm from Ru"   */
    
    
    /* 2) call - ***НЕ ВОЗВРАЩАЕТ функцию, изменяет контекст передавая параметры, поэтому скобки вызова отсутствуют
        console.log(person1.getInfo.call(person2, 'Ukr', 'Ukraine'));
        
        Так как метод не привязывается к функции то невозможно позже через вызов переменной задавать новые параметры, их нужно
        присвоить переменной сразу
        const getInfoCall = person1.getInfo.call(person2, 'Ukr');
        console.log(getInfoCall);   */
        
        
        // 3) apply - не привязывает метод. Работает как и call но синтаксис другой(запись)
        // console.log(person1.getInfo.call(person2, ['Ukr'], ['Ukraine'] ));
    
    
    
    //++++++++++++++++++++++ ЧИСЛА ++++++++++++++++++++
    
    //Обращаемся через глобальный объект Number
    
    //isInteger - проверяет целое число или нет. Возвращает true / false
        Number.isInteger(10) // true
        Number.isInteger(10.5) // false
    
    //isFinite() - определяет передаваемый параметр число или нет true / false
        Number.isFinite(1) //true
        Number.isFinite('1') //false
        // но если обращатся без Number то происходит преобразование к числу и сравнение
        isFinite(1) //true
        isFinite('1') //true
        isFinite('') //true
        isFinite([1]) //true
        isFinite('o') //false
        isFinite({}) //false
    
    //parseInt - преобразует содержимое в целое число (обрезая остальное если числа в начале) и возвращает его
        parseInt('1.6 bb') //1
        parseInt('bb') //NaN
    
    //parseFloat - преобразует содержимое в дробное число
        parseFloat('1.6'); // 1.6
        
    //toFixed - вызывается у числа обернутого в скобки для округления к целому числу, возвращает число в СТРОКЕ
        (5.4).toFixed(); // 5
        (5.555555).toFixed(2) // '5.55'   (2) - Параметр определяет знаки после запятой
        +(5.556666).toFixed(2) // 5.56 - через + получаем число
    
    

    //++++++++++++++++++++++ MATH ++++++++++++++++++++
    
    // ceil - округляет к ближнему большему целому числу
        Math.ceil(25.1) // 26
    

    // floor - округляет к ближнему меньшему целому числу
        Math.floor(25.9999) // 25
    

    // round - округляет к  целому числу
        Math.round(25.1) // 25
        Math.round(25.9999) // 26
    

    // min - из принимаемых элементов возвращает наименьший
        Math.min( 20, 10, 5, 15) //5
    

    // max - из принимаемых элементов возвращает наибольшее
        Math.max( 20, 10, 5, 15) //20
    

    // trunc - удаляет дробную часть
        Math.trunc(25.55) // 25
    

    // random - возвращает случайное число от 0 до 1
        Math.random() // 0.43748290973274084

}

{/*  ====    Понимание ВЕСА CSS-селекторов    ====

    Введение

        Как и любая моя статья, эта начинается с введения. Дабы не говорить на разных языках, начнём с 
        самых основ в мире CSS, то есть с терминологии. Чувствую себя преподавателем в университете — как
        же это круто.

        Для того чтобы успешно разбираться в CSS и стать крутым специалистом в этой области, нужно первым
        делом разобраться с тем, что называют селектором. На изображении ниже представлена простейшая 
        структура CSS-правила.



    Простейшая структура CSS-правила

        Селектор — это строка, представляющая собой формальное описание структуры, на основе которого
        выбирается элемент или группа элементов в дереве документа и применяется объявленный блок свойств.

        Селекторы бывают самые разные. Существуют простые селекторы, например, состоящие из одной буквы
        или одного слова, и сложные, состоящие из большого количества слов и различных синтаксических 
        конструкций.

        Я не буду вдаваться в подробности того, что селекторы должны начинаться с буквы и некоторых других
        символов. Я также не буду говорить про неинтересные прописные истины, которые можно найти в любой
        статье на тему основ CSS. Речь в этой статье пойдёт про вес CSS-селекторов, а если говорить 
        простым языком — о его числовом представлении и понимании.



    Вес селекторов

        Вес селектора — это условные четыре позиции x, x, x, x, которые заполняются нулями и единицами в 
        соответствии с содержимым  селектора. Каждая из позиций имеет своё содержимое:

            Инлайн стили
            Идентификаторы
            Классы, атрибуты и псевдоклассы
            Теги и псевдоэлементы


        Как это читать?
        Очень просто. Справа налево. Слева идут числа старшего разряда, поэтому они имеют больший вес, 
        числа, идущие справа, наоборот, имеют наименьший вес. Всё это станет понятным дальше, поэтому 
        можно даже не вдумываться в смысл этого абзаца.


        Как заполнять?
        Немного сложнее, чем читать. Рассмотрим предложенную систему четырёх позиций на реальном примере
        для того, чтобы понять всю технологию.

            h1 {
            color: #777;
            }

        В этом примере селектором выступает заголовок h1, который состоит из одного тега. Получается,
        что напротив столбца «тег» мы ставим единичку. Получается следующая картина: 0, 0, 0, 1.


        Всё это замечательно, но в реальных проектах встречается разве что в ядре стилей или normalize, 
        а это значит, что нужно усложнить задачу.

            #main .container article.post > header h1.giga {
            color: #777;
            }

        Пример получился хардкорнее, чем предыдущий и в реальной жизни достоин премии «самого избыточного
        селектора». Такая избыточность должна преследоваться по закону, но подробнее на эту тему мы 
        поговорим в отдельной части статьи. Окей, вернёмся к примеру и немного поработаем весами.

        Давайте начнём слева, так как в начале стоит единственный идентификатор #main. Далее мы видим 
        три класса   .container, .post и .giga, а также три тега article, header и h1. Для ещё большей 
        наглядности я распишу это в виде этапов:

            // Селектор
            #main .container article.post > header h1.giga

            // Начальный вес
            0, 0, 0, 0

            // Идентификаторы
            #main         0, 1, 0, 0

            // Классы, атрибуты и псевдоклассы
            .container    0, 1, 1, 0
            .post         0, 1, 2, 0
            .giga         0, 1, 3, 0

            // Теги и псевдоэлементы
            article       0, 1, 3, 1
            header        0, 1, 3, 2
            h1            0, 1, 3, 3

        Итог

            #main .container article.post > header h1.giga
            =>
            0, 1, 3, 3


            
        Давайте напишем какой-нибудь безбашенный селектор, который я, надеюсь, никогда не увижу ни у кого
        в коде:

            // Селектор
            body.page-posts #main .container article.post ul.list-unstyled > li:first-child h2.article-title:hover {
            color: #333;
            }

            // Начальный вес
            0, 0, 0, 0

            // Идентификаторы
            #main             0, 1, 0, 0

            // Классы, атрибуты и псевдоклассы
            .page-posts       0, 1, 1, 0
            .container        0, 1, 2, 0
            .post             0, 1, 3, 0
            .list-unstyled    0, 1, 4, 0
            :first-child      0, 1, 5, 0
            .article-title    0, 1, 6, 0
            :hover            0, 1, 7, 0

            //  Теги и псевдоэлементы
            body              0, 1, 7, 1
            article           0, 1, 7, 2
            ul                0, 1, 7, 3
            li                0, 1, 7, 4
            h2                0, 1, 7, 5

        Итог

            body.page-posts #main .container article.post ul.list-unstyled > li:first-child h2.article-title:hover
            =>
            0, 1, 7, 5
        

        
        Ну и напоследок, для полного понимания темы, будет пример с атрибутами и псевдоэлементами.

            // Селектор
            .main[data-columns]:before {
            content: "3 .column.size-1of3";
            }

            // Начальный вес
            0, 0, 0, 0

            // Идентификаторы
            0, 0, 0, 0

            // Классы, атрибуты и псевдоклассы
            .main             0, 0, 1, 0
            [data-columns]    0, 0, 2, 0

            //  Теги и псевдоэлементы
            :before           0, 0, 2, 1

        Итог
            .main[data-columns]:before
            =>
            0, 0, 2, 1
            Вот такие вот дела.



        На самом деле, тема очень простая, но очень важная на практике для посредственного (минимального)
        понимания того, как браузер определяет какой блок объявлений необходимо применить к тому или иному
        элементу на странице.



    А что, если вес селекторов одинаковый?

        Допустим, что у вас есть два или несколько селекторов так или иначе указывающих на один и тот же
        элемент. И вот так сложилось, что вы посчитали или просто взглянули на них, и вес оказался 
        одинаковым. Не стоит отчаиваться, просто блок объявлений последнего селектора в вашем CSS-коде из
        этой группы и будет применяться к элементу. Как-то так. Мне кажется это логичным. Прямо как в 
        поговорке «кто не успел, тот опоздал», но наоборот: «кто опоздал, тот и успел».



    Зачем это нужно?

        Это очень интересный момент, ибо понять какой блок объявлений будет применяться к элементу, можно
        и без расчёта веса селектора, то есть просто посмотрев на него и слегка подумав. Однако, глазомер 
        может подвести, а вот машина не подведёт, посчитает вес и испортит вёрстку. Ошибка, конечно, не 
        машины, а прослойки между компьютером и стулом, но это уже совсем другая история.

        Ещё одним применением такого вот расчёта являются сервисы или скрипты, которые строят диаграммы
        специфичности CSS. Это может быть очень удобно для анализа и оценки избыточности вашего кода.

        Интересным фактом будет то, что единственный раз, когда мне приходилось считать вес селектора, 
        был тестом от Mail.ru на какой-то сертификат. Если интересно, то я поищу этот тест у себя в истории.



    Я ленивый и не хочу понимать, как считать вес селекторов, что тогда?

        Ох, специально для вас у меня есть сервис, на который я наткнулся при подготовке к изложению этого
        материала:  Specificity Calculator — это простой и эффективный калькулятор веса селекторов.



    Специфичность селекторов
        Раз уж зашла речь про вес CSS-селекторов, то неизбежно задумываешься о том, как бы его оценить: 
        когда нужно ему худеть, а когда наоборот — поправляться. Как и у человека, у селекторов всё таки 
        есть оптимальный вес.

        Так сложилось, что многие веб-разработчики считают оптимальной специфичностью селекторов три 
        вложения. Максимальной специфичностью селекторов называется пять вложений и рекомендуется 
        стараться это число не превышать. Разумеется, вложений может быть и больше, так как в жизни всякое
        бывает. Хотя, лучше всего, если вы всё таки будете соблюдать эту рекомендацию хотя бы косвенно. 
        Такой подход вам поможет сэкономить время в будущем.

        Хорошо, всё это замечательно, но причём тут вес? — да очень просто, он напрямую от этого зависит. 
        Чем больше вложений, тем больше вес. Логично, однако.

        Оценить ваш CSS-код можно с помощью ресурса CSS Specificity Graph Generator. По предложенному вами
        CSS-коду строится интерактивный график специфичности вашего кода, на котором можно визуально 
        определить проблемные участки ваших стилей.



    Выводы
        Постарайтесь поддерживать оптимальный вес селекторов и изредка проводите рефакторинг кода. Сначала
        это кажется избыточным и ненужным, но в итоге это может сыграть с вами плохую шутку.


*/}




//====================================  UDEMY COURSE ( 06.2022 ) =======================================
// 200 =================================== ОСНОВЫ Java Script ==========================================

                            //! ДЛЯ ЭТОГО КУРСА НУЖНЫ ЗНАНИЯ БАЗОВОЙ ВЕРСТКИ

{/*  201    ====    ЧТО ТАКОЕ JS и как его ПОДКЛЮЧИТЬ    ====

    При создании любого сайта используют несколько технологий HTML - это скелет нашего сайта(язык разметки)
        на него добавляются стили CSS (шрифты, цвета, расположение элементов), а для того что бы все это 
        работало используют JS (для взаимодействия страницы с пользователем), PHP (для взаимодействия 
        страницы с сервером или базой данных), базы данных, и т.д.


    Изначально JS был придуман для создания интерактивности на странице и взаимодействия с 
        пользователем(меню, подсказки, слайдеры, табы), те элменты на которые пользователь может нажать 
        или как то взаимодействовать. Отсюда вывод что нам нужно уметь работать со структурой 
        сайта ( HTML документа). 


    Сейчас с помощью JS можно создавать серверные программы (NODEjs), десктопные программы (ELECTRONjs), 
        мобильные приложения(react native), виртуальную реальность (React 360) и многое другое, но что бы 
        зайти так далеко для начала нужно выучить БАЗОВЫЙ (ванильный/нативный) JS который работает в 
        только браузере, тот с которого всё и началось.


    //! Базовый JS имеет свои ограничения - он не умеет работать с файлами на компьютере и не работает 
        между вкладками браузера, это сделано в целях безопасности. JS высокоуровневый язык - это значит 
        что браузер будет воспринимать наш код так как он написан без перевода(компиляции) в двоичную 
        систему. Был создан для непрограммистов поэтому он легче в изучении/использовании и большинство 
        комманд - английские слова и словосочетания.



    ПОДКЛЮЧЕНИЕ JS

        JS (script.js) как и файлы стилей (style.css) подключается к основному файлу страницы который 
        обычно назыают index.html,
            
        
        ХТМЛ страница имеет свою структуру
        
            <!DOCTYPE html>
            <html lang="ru">

                <head>
                    <meta charset="utf-8">
                    <meta http-equiv="X-UA-Compatible" content="IE=edge">
                    <title>JavaScript</title>
                    <link rel="stylesheet" href="css/elements_style.css">
                </head>

                <body>
                    <p> Hello World.</p>
                    <script> alert("Hello") </script>       // *1)
                    <script src="js/script.js"></script>   // **2)
                </body>

            </html>

        Можно подключить как в *1) сам документ, так и в **2) как отдельный файл. 
    

        *1) Пишем JS непосредственно в HTML файле в теге script пишут код - используется для очень 
            маленьких скриптов и в реальных проектах скорее всего мы его не увидим, потому что там много 
            кода который загромождает ХТМЛ файл. Чтобы такого не было и HTML структура нормально читалась 
            программистом скрипт JS подключают как отдельный файл. Откроем нашу страницу и увидим текст 
            Hello World. Потом пропишем в теге body тег скрипт (подключим JS непосредственно в HTML) 
            
                <script> alert("Hello") </script>

            Сохраним файл JS и обновив браузер увиди сообщение Hello в выпрыгнувшем окне.


        **2) Для этого метода создадим в папке проекта папку - js и в ней создадим файл с раширением js - 
            script.js  Для подключения также используем тег скрипт только теперь он будет пустой а в 
            аттрибуте src(source) указываем путь к файлу с кодом.

                <script src="./js/script.js"></script>

            В файле пропишем команду console.log("Hello in console");

            Открываем нашу страницу(index) и видим что ничего не изменилось, потому что эта команда 
            console.log выводит сообщение в консоль. Ее обычно можно открыть f12 или ctrl+shift+I или 
            клацнув правой кнопкой мыши на странице и выбрав пункт -> просмотреть код -> вкладка console. 
            Там и увидим наше сообщение - Hello in console.

            При таком подключении скрипта в файле если мы внутри тега скрипта начнем писать код, то он 
            будет игнорироваться, нужно или писать в новом теге скрипта или в файле js.

            //! В старом коде можно встретить в теге скрипт аттрибут type="text/javascript" - 
            его нужно удалять потому что  валидатор будет на него ругаться.


        
    МЕСТО ПОДКЛЮЧЕНИЯ

        Сейчас в начале курса мы подключаем скрипт в самый конец ХТМЛ страницы перед закрывающим тегом 
        </body>. Это делается  для того что бы мы избежали ошибок. 

        //! БАЗОВОЕ ПРАВИЛО ВЕРСТКИ (как строится страница). Браузер открывает наш документ - видит какой 
        тип документа <!DOCTYPE html> какой язык установлен (lang). Потом переходит к тегу <head></head>
        видит кодировку страницы смотрит на тайтл страницы (title), если тут будут какие-то стили - 
        подключает их. После этого переходит к тегу body и начинает загружать всю верстку элемент за 
        элементом, а в самом конце увидит скрипт и подключит его.

        //! Если мы подключим скрипт в head то сначала будет выполнятся код скрипта и при обращении из него
        к какому-то элементу на странице сделать это будет невозможно, потому что этот элемент еше не будет
        построен, так как верстка еще будет ждать окончания выполнения скрипта. И второй главный минус 
        такого подхода - если скрипт будет большой или лежит на каком то сервере то пока он обработается 
        пользователь будет смотреть на пустую страницу пока подгрузится/выполнится потому что верстка не 
        сформируется.


*/}

{/*  203    ====    ПЕРЕМЕННЫЕ И СТРОГИЙ РЕЖИМ    ====

    = (равно) - знак присваивания. Название переменной не должно начинаться с цифры и не должно совпадать 
        с зарезервированными названиями и может содержать буквы, цифры и знак доллара и нижнего подчеркиния.
        Записываем кемэл кейсом. Num и num - разные переменные


    //! Имя переменной может состоять из цифр, букв (английские/латиница), символов доллара ( $ ) и нижнего
    //! подчеркивания ( _ ), при этом первый символ ниогда не должен быть цифрой. Также названия не должны
    //! совпадать с заразервированными словами языка js - error, alert, ...  Если в названии несколько 
    //! слова то они склеиваются и пишуться кемел кейсом (горбатым стилем) 

            const leftBorderWidth = 1

        //! переменные с буквами в разных регистрах (большие и маленькие) это разные переменные

            let number = 5
            let Number = 5



    let - можно использовать только после того как объявлена. Изменяемая переменная с ограниченной областью 
        видимости (в пределах фигурных скобок {} если объект или функция, если в основной зоне видимости 
        тогда - глобальная)


    const - можно использовать только после того как объявлена (константа), ограниченная областью видимости,
        не изменяется на прямую, но если задать объект, то его можно изменять. Прямых констант в JS нет.

            const obj = {
                a: 50
            }
            obj.a = 10;
            console.log(obj);// {a:10}


    var ("старый" метод задания переменной), существует еще до того как была объявлена(всплытие переменной 
        при первом проходе браузера) поэтому будет undefined  вместо ошибки 

            console.log(name);
            var name = "Ivan";
    
        это затрудняет debugging. проблемы: глобальная область видимости из любого места, поднятие кода(всплытие переменной - 
            hoisting)
        


    Новый стандарт let и const не поддерживается в старых версиях браузеров, тогда нужно программой-
        конвертером переводить код в старый режим, для того чтобы использовать новый режим существует 
        директива "use strict"; -  для вывода ошибок. Прописывается на первой строке в файле кода или в 
        начале функции, при строгом режиме перестает работать такое выражение a = 15; будет выдавать ошибку,
        как и должно потому что переменная не была объявлена через ключевое словао.


*/}

{/*  204    ====    (Д) ПРАВИЛА И ТИПЫ НАЗВАНИЯ ПЕРЕМЕННЫХ    ====

    Д - значит дополнительный урок, добавленный в курс для более детальной проработки темы.


    Название переменной должно отражать что она делает, за что отвечает или что это за данные, чтобы 
        вернувшись через время за этот код или если другой разработчик будет его читать, было понятно что
        происходит в коде. */

            const vehicleBodyWidth = 5000
            const vehicleBodyLength = 5000

        // вместо 

            const a = 5000 


        /* Можно задавать и простые имена типа а, b, с, data, value - если эти переменные 
        технические(которые дальше нигде не будут использоваться, после использования удаляться). */

            ['Alex', 'Dmitry', 'Valeriy'].map( user => {} )

        /* напирмер для перебора каждого елемента массива в методе map нужно обозвать эту этот елемент, 
        и тут можно написать: user, element, el, dataItem, arrItem, a, b или с. Потому что после работы 
        map эта переменная нигде больше не будет использована и удалиться.


        или если ждем ответа от сервера, при этом мы не знаем какие дынные получим, тогда называем 
        переменную в которую поместим ответ асбтрактно - data, response



    Важно также соблюдать единый стиль кода - названия должны быть единообразны */

            const vehicleBodyWidth = 5000
            const carBodyLength = 5000

        /* тут уже видно что название выбивается из общего стиля, хотя относится к одному объекту.

        если работаете в команде нужно сразу определиться как называть переменные чтобы они были одинаковы,
        потому что например пользователя можно назвать - user, person, client - выбрать одно чтобы у всех
        было одинаковое и не пришлось потом переназывать.



    Существуют разные стили названия

        переменных:

            UPPER_SNAKE_CASE    - означает не переназначать
            _apiKey             - означает не переназначать


        папок и файлов:

            snake_case
            kebab-case
            PascalCase                                          */


    
    //! Когда создаем новую переменную она сохраняется в ячейке области памяти, это автоматический процесс,
    //! поэтому не нужно заботиться о том сколько создавать переменных и сколько они будут занимать памяти.
    //! Нужно только следить за утечками памяти, к переменным не относится. 


}

{/*  205    ====    КЛАСИФИКАЦИЯ ТИПОВ ДАННЫХ    ====

    Тип данных можно проверить typeof.  console.log(typeof(5));



    +++ ПРОСТЫЕ ТИПЫ (примитивы): 

        1) Числа ограничиваются - 2(двойкой) в 53 степени
            1, 2, 3.2 
            infinity(бесконечность) - получается при делании на 0(может быть отрицательной если делить 
            отрицательное число на 0) NaN (not a number)- получается при операции с не математической 
            логикой ("string" * 9)

        2) Строки(любая строка пишется в кавычках)  "string", 'name', `you are ${years}`, "5"

        3) Логический тип(boolean) true, false 

        4) null - что то чего не существует. null в консоль получаем редко, чаще будет ошибка 
            ReferenceError: something is not defined - ошибка ссылочного типа, которая говорит что мы 
            ссылаемся на не существующий объект.

        5) undefined - существует но значение не определено.

        6) Symbol 

        7) BigInt - тип данных для больших чисел больше чем 2 в 53 степени.



    +++ КОМПЛЕКСНЫЕ (объекты)

        Обычные объекты - коллекция данных, может содержать разные типы данных (свойства) и 
            действия/функции(методы). К свойствам(чтобы их достать)  можно обратиться или через точку(.)
            или через квадратные скобки [] */

                const obj = {
                    age: 10, 
                    name: "John",
                    say: function() {
                        console.log("Hello");
                    },
                    isMarried: false
                }
                console.log(obj.age);       //10       
                console.log(obj["age"]);    //10
                console.log( obj.say() );   // Hello


/*      Спец объекты: 

            1) Массивы ["text", 6, {}, [], true] - частный случай объектов, конструкция для хранения 
               данных строго по порядку различных типов данных. Первый элемент под номером(индексом) 0. */ 
                
                    let arr = [6, true, 'orange', {}, [] ]; 
                    console.log(arr[1]); //true
                
                /*Для записи эл. в конккретный индекс массива используем arr[0] = "9";

            2) Функции
            3) Объекты даты
            4) Регулярные выражения 
            5) Ошибки


*/}

{/*  206    ====    (Д) РАЗНИЦА ОБЪЕКТ - МАССИВ и НЕОЧЕВИДНЫЕ СИНТАКСИЧЕСКИЕ ВОЗМОЖНОСТИ    ====

    Разница Объект - Массив

        Массив - перечень информации по порядку, порядок важен потому что обращаемся к сущностям в массиве
        по их номерам(индексам) */

                const arr = [1, 2, 3]
                console.log(arr[1]) - обращаемся по индексу 1 - ко второму елементу, потому что нумерация 
                                        начинается с 0.


        // Объект - структура хранения данных в парном формате - ключ-значение, поряжок в них не важен.

                const obj = {a:1, b:2}
                
                const obj1 = {
                    Anna: 500,
                    'Alice': 800
                }

            /*свойства в объекте - строка, можно писать в кавычках или без них. Удобнее и быстрее без них.


       Функциональные различия. Хоть массивы - частный случай объектов, но у них есть свои методы и 
            свойства. Разберем далее в уроках, сейчас только примеры. Например метод по перебору каждого
            массива по порядку, методы добавления эл. в конец  или в начало, свойство для того чтобы узнать
            длинну массива. У объектов другие методы и свойства и это логично потому что если в объекте нету
            четкой нумерации, то и нету смысла в методе который добавляет элемент в конец.

            Если посмотреть в глубь массива то это теже объекты только у них ключ всегда - номер по порядку,
            тоесть массив  */

                const arr = ['a', 'b', 'c']

            //можем переписать как 

                const arrObj = {
                    0: 'a',
                    1: 'b',
                    2: 'c'
                }



    /*Синтаксические возможности.
        
        Если попробовать получить второй елемент из этого объекта через точку то получим ошибку, потому в
            обращении будет цифра.

                console.log(arrObj.1) //error

            обычно никто не называет свойства цифрами, но может такое случиться, тогда нужно использовать 
            второй метод обращения через квадратные скобки. Тоже смамое может случиться если будет другой
            язык отличный от английского(кирилица, арабский, иврит...).

                console.log(arrObj.[1]) // b


        В объекты можем добавлять данные используя или точку или квадратные скобки. Таким образом когда мы
            обратились к несуществующему свойству js видит это и добавляет его(или перезаписывает значение
            если оно есть)

                arrObj.b = 'some string'

            но если будем обращаться так к этому свойству, то будет ошибка потому что js видит что это 
            буква но не в кавычках и  думает что это переменная, но у нас нет такой переменной.

                console.log(arrObj.[b]) // error

            для правильного обращения нужно помещать буквы как строки или через точку

                console.log(arrObj['b'])   // some string
                console.log(arrObj.b)      // some string

            для создания через скобки тоже нужно указывать 'b' - строкой

                arrObj['b'] = 'some string'


        //! Динамическое имя свойства задается через скобки без кавычек ссылаясь на информацию в переменной,
            во время создания нового свойства, js обратится к переменной b и подставит ее содержимое в 
            данном случае строку 'b'
                
                const b = 'b'
                arrObj[b] = 'some string'


        //! Также динамически можно создавать элементы и в массиве, но это крайне не рекомендуется, потому
            что если допустим в массиве const arr = ['a', 'b', 'c']  создадим эл. на 10м индексе и запишем
            туда значение, то при обращении к нему все будет в порядке, но если вывести массив, то видим 
            что в нем 11 елементов и 7 ячеек между 'c' и 10м элементом - пустые, это нарушает логику 
            работы массива.


        Внутри объектв можно создавать еще один объект или массив, а в нем еще, но чтобы не запутаться не 
            рекомендуют более 3х уровней создавать.


*/}

{/*  207    ====    ПРОСТОЕ ОБЩЕНИЕ С ПОЛЬЗОВАТЕЛЕМ (alert, confirm, prompt, document.write)    ====

    alert, confirm, prompt - эти события не могут быть стилизированы и их вид зависит от браузера. 
    //! Они вызывают модальные окна которые блокируют построение страницы. Работают только в браузере!


    alert - окно предупреждения имеет 1 кнопку - ок */
            
            alert("hello"); 



    //confirm - 2 кнопки - ок и отмена.

            const result = confirm("are u here?");  
            console.log(result); 

        /*Результат нажатия этих клавиш будет записан в result. При нажатии ок - true, false - при нажатии
        кнопки отмена



    prompt - 2 кнопки - ок, отмена и поле ввода. */

            const answer = prompt("Вам есть 18", "");
            
        /*первый аргумент вопрос, второй аргумент пустые кавычки,  для получения ответа пользователя в них
        можно указать значение по умолчанию prompt("Вам есть 18", "18") ответ пользователя приходит в виде
        строки, что бы перевести в число ставим плюс впереди +prompt; */

            console.log(answer);
            console.log( typeof(answer) ); // проверка typeof на тип содержимого

        /* если promt без плюса - при закрытии окна Esc или Отмена - получим null (объект)
        если +prompt - 0 (number), если введут что то кроме числа - NaN (number)


        Помещаем ответы в массив */

            const answers = [];

            answers[0] = prompt("Как ваше имя?", "");
            answers[1] = prompt("Как ваша Фамилия?", "");
            answers[2] = prompt("Сколько вам лет?", "");

            document.write(answers); // пишет содержимое answers на странице

        /*Если записать в консоле document.write на сайте например гугла, то заменяет все содержимое 
        страницы, но если страница еще не сформирована, тоесть промпт идет в самом начале и
        блокирует ее формирование, то всё что должно быть на ней после выполнения скрипта появится, а
        запись из document.write будет внизу верстки

        //! если typeof применить к null, ответ - object - это официально признанная ошибка, потому что
        //! null отдельный тип данных.


*/}

{//         ====   СОРТИРОВКА МАССИВА (сортировка по порядку)    ====

    const arr = [1, 14, 4, 30, 54];
    let sorted = arr.sort(CompareNum);
    console.log(sorted); // [1, 4, 14, 30, 54]

    function CompareNum(a, b){
        return a-b;
    };


    let arr = [2, 1, 3, 15, 6, 5, 4];
    let arr2 = ['Banana', 'Orange', 'Apple', 'Mango'];
    arr2.sort(); //['Apple', 'Banana', 'Mango', 'Orange'] - сортирует элементы в массиве в алфавитном порядке по первой букве
    arr.sort(); // [1, 15, 2, 3, 4, 5, 6]; - (если цифры то они тоже воспринимаются как строка и сравнение происходит по
                                                  //первой цифре)           
        /*Чтобы числа сортировало по возрастанию(как числа), нужно добавить вспомогательную функцию, она принимает параметры - 
            а и b - это соседние элементы массива, при первой итеррации это будут 2 и 1, при второй 1 и 3, и т.д. Функция
            каждый раз возвращает разницу этих элементов а - b, если разница плюсовое число, элементы массива меняются местами,
            если равна 0 или отрицательная то элементы остаются на своих местах.*/
        arr.sort((a, b) => {
            return a - b
        });                 // [1, 2, 3, 4, 5, 6, 15];

}

{/*  208    ====    ИНТЕРПОЛЯЦИЯ (ES6)    ====

    Интерполяция - вставка значения переменной внутрь строки, используя кавычки на кнопке тильда 
        (косые бэктики - кнопка под Esc).


        Задача - подставить в путь перехода по ссылке переменную category. До ES6 реализовывалось через 
        конкатенацию строк. */

            const category = 'toys';
            console.log('https://someurl.com/' + category);


        /* Далее если нужно перейти на четвертую игрушку например, код начинает выглядеть не красиво 
        и не удобно с ним работать */
    
            console.log('https://someurl.com/' + category + '/' + '4');


        // Теперь это реализуется интерполяцией

            console.log(`https://someurl.com/${category}/4`);


        //! Таким образом можно динамически менять содержимое строки в зависимости от пришедших данных.


}

{/*  209    ====    ОПЕРАТОРЫ    ====

    Вычитание(-), умножение(*), деление(/) - работают также как в матиматике. 



    +++ СЛОЖЕНИЕ (+)

    При сложении двух строк или строки с чем-либо получим строку(конкатенация) */

            console.log('arr' + ' - object'); // arr - object  - строка
            console.log(4 + ' - object');     // 4 - object    - строка
            console.log(4 + +' - object');    // NaN - хотели прибавить к числу строку преобраз. в число
            console.log(4 + '5');             // 45            - строка

        // Плюс перед строкой (унарный - ставится перед чем то(использует только 1 аргумент)) позволяет
        // получить из нее число

            console.log(4 + +'5');            // 9             - число

            

    /* +++ ИНКРЕМЕНТ(++) и ДЕКРЕМЕНТ(--)

    Используются для сокращения кода, увеличивают или уменьшают значение переменной на 1. Существуют
    префиксные и постфиксные.*/

            let incr = 10,
                decr = 10;


        // Префиксные -  сначала выполняет операцию, а потом возвращает значение

            console.log(++incr); // 11
            console.log(--decr); // 9


        // Постфиксные - сначала возвращает старое значение, а потом выполняет операцию 
        
            console.log(incr++); // 10
            console.log(decr--); // 10



    // +++ ОСТАТОК ОТ ДЕЛЕНИЯ(%)

            console.log(5%2);   // 1

        // 5 делится на 2 столько раз сколько может а остаток возвращается.



    // +++ РАВЕНСТВО(==) и СТРОГОЕ РАВЕНСТВО(===)

            console.log(2*4 == 8);      // true    - сравнивает по значению, а не типу данных.
            console.log(2*4 == '8');    // true  - сравнение со строкой тоже дает истину. Пытается привести
                                        // к одинаковому типу для сравнения

            console.log(2*4 === '8');   // false - строгое равенство сравнивает сначала типы, если типы не
                                        // совпадают, дальше сравнение не идет.
            
            console.log(2*4 === 8);     // true 



    /* +++ ЛОГИЧЕСКИЕ ОПЕРАТОРЫ И(&&) и ИЛИ(||)

        И(&&) - возвращает true если ВСЕ аргументы true, иначе выводит false */

            const   isCheked = true,
                    isClose = true,
                    isFalse = false;

            console.log(isCheked && isClose); // true
            console.log(isCheked && isClose && isFalse); // false


        // ИЛИ(||) - возвращает true если ХОТЯБЫ ОДИН аргумент true, возвращает false если все 
        // аргументы false.

            console.log(isCheked || isClose || isFalse); // true



    // +++ ОТРИЦАНИЕ(!) - превращает значение в обратное

            console.log(isCheked && isClose && !isFalse); // true  *инвертируем зачение
            console.log(!isCheked || !isClose || isFalse); // false 
            console.log(2 + 2 * 2 != 8);    // true  - потому что 6 (НЕ) равно 8 *инвертируем оператор
            console.log(2 + 2 * 2 != '6');  // false - потому что 6 (НЕ) равно 6 *не строгое равенство
            console.log(2 + 2 * 2 !== '6'); // true - потому что 6 число (НЕ) НЕ равно 6 строке * строгое

        // инвертируем результат работы сравнения - != *не строгое равенство  !== * строгое равенство



    // +++ ПОРЯДОК ВЫПОЛНЕНИЯ ОПЕРАТОРОВ - приоритет можно посмотреть по таблице:
        // ( https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_precedence )
            
            console.log(2 + 2 * 2 == 8); 
            
        // false - потому что умножение выполнится раньше и получится 6 == 8



    // Существуют еще побитовые операторы, но в первые годы работы с кодом они не встречаются.


}

{/*  210    ====    GIT    ====

    GIT - система контроля версий, GitHub - сервис для хранения репозиториев.


    Скачать GIT с сайта git-scm.com, установить.


    Для создания репозитория в папке проекта нужно вызвать через shift+правая кнопка мыши - PowerShell или
        Graphic user inerface. Если такой функции нету тогда вызываем cmd прописываем cd(change directory)
        - и докопируем путь к папке проекта, что бы перейти в эту папку. Также можно работать с терминалом
        в VS Code, что бы в него перейти нужно нажать мышкой в левом нижнем углу на значки крестика в 
        кружочке и треугольника. 
        
        //! Если гит остался с предыдущей виндовс или портабл версия, все действия нужно выполнять
        //! в его окошке.


        Первым действием прописываем комманду git init , для того чтобы гит следил за файлами в папке(если
        все прошло успешно появится сообщение в терминале и в папке с проектом должна появится скрытая
        папка гита ). Чтобы увидеть нужно выбрать - показывать скрытые фалы во вкладке "вид" проводника.



    Сделаем настройки для доступа к гитхабу. Это можно сделать как локально для текущего проекта, так и
        глобально - настройки будут общими для всех проектов. Если в проекте установлены локальные 
        настройки они будут действовать перебивая глобальные настройки. 
        
        Пропишем 
        
            git config --local user.name "AoDWork"
            git config --local user.email aodtest07@gmail.com  
            
            имейл - второе обязательное поле для заполнения конфига.


        Можно посмотреть применились ли настройки конфигурации в файле конфиг в папке гита.
        Первый раз при настройке на компьютре реекомендуется прописать эти настройки глобально

            git config --global user.name "AoDWork"
            git config --global user.email aodtest07@gmail.com



    У гит репозитория есть три состояния файла: 
        1) когда файл только создан и просто лежит в папке
        2) когда гит следит за определенными файлами(они попадают в индекс)
        3) когда гит создал контрольную точку к которой можно позже вернуться - commit.



    Для того что бы посмотреть статус репозитория пропишем 

            git status

        Выдаст такbt сообщения - нету коммитов, нету файлов за которыми следит  
        No commits yet
        Untracked files:(use "git add <file>..." to include in what will be committed)
    

        Далее добавим(add) все файлы(-A) в папке в индекс что бы гит за ними следил
        
            git add -A 


        Прописав снова гит статус можно увидеть что файлики стали зелеными и гит предлагает сделать 
        контр.точку

            git status
   

        Что бы создать контр. точку прописываем гит коммит -а(все файлы) -m(месседж - описание коммита).

            git commit -a -m"First state"


        Теперь контрольная точка создана(папка с проектом скопирована). При дальнейшем изменении файлов 
        нужно будет снова добавлять(add) модифицированные файлы и делать коммит для сохранения.


        Что бы посмотреть какие коммиты были нужно прописать 

            git log



    Для заливки проекта на гитхаб нужно в профиле на гитхабе в директории Repositories нажать кнопку New
        для создания нового репозитория. Прописать имя репозитория -> Create repository(нажать на кнопку).
        Так как у нас репозиторий в папке проекта уже создан пожтому пропускаем первый абзац (create a new
        repository on the command line) и переходим к заливке репозитория или пуша (or push an existing
        repository)
    
        Копируем эту строчку remote(связываем созданный репозиторий и локальный) в окно и запускаем

            git remote add origin git@github.com:AoDWork/test.git
            
        Визуально ничего не изменилось, но теперь локальный репозиторий связан с удаленным.
    

        Далее копируем и запускаем эти строки -u(значит что все следующие пуши будут идти в этот 
        репозиторий)

            git branch -M main   переименовывает главную ветку master в main(в связи black lives matter)
            git push -u origin main  - пушит данные на гитхаб
    

        Все файлы проекта должны были запушится на гитхаб, о чем сообщило окно терминала и теперь обновив
        страницу гитхаба мы видим наши файлы и папки в репозитории.



    //! Подробная инструкция и курс по использовнию гита можно пройти на githowto.com


*/}

{/*  211    ====    РАБОТА с GitHub  С РАЗНЫХ КОМПЬЮТЕРОВ, Gitignore, Git Kraken    ====

    Для работы с разных компьютеров (домашний, рабочий). Для начала нужно скачать последнюю версию файлов 
        проекта и Гитхаба на  компьютер. В репозитории нажимаем на зеленую кнопку Code, и можно выбрать 
        или скачать зип архив распаковать его или строкой для окна терминала - клонировать. В окне 
        терминала должна быть выбрана папка в которую будем клонировать проект, далее прописываем

            git clone + адресс скопированный с гитхаба + название папки в которую будет клонироваться
            git clone git@github.com:AoDWork/Git_ignore.git test_work


        После работы с файлами, их нужно заново запушить в репозиторий, для этого

            git add -A
            git commit -a -m"modifyed on work"
            git push


        Для возобновления работы на домашнем компьютере нужно обновить этот проект до последней версии

            git pull

        //! Всегда перед началом работы с проектом нужно обновлять его состояние до последней версии.



    Ошибка которая может возникнуть если кто то изменил репозиторий, а мы не запулили или сами добавили 
        файл на гитхабе и не запулили, а потом модифицировав другие файлы, пытаемся запушить. Тогда нужно
        запулить файлы
    
            git pull

        при этом происходит слияние(merge) проекта локального и удаленного, а терминале где работаетм нужно
        ввести название коммита без "" - кавычек. Далее 2 раз нажать Ctrl+C, внизу освободится поле и курсор
        перепрыгнет на него, и там ввести 

            :wq!

        Должно произойти слияние. 

        
            git status              Проверим файлы 
            git push                и далее запушим мердженные файлы 



    +++ Git Ignore
    Игнорирование файлов которые не должны попасть в репозиторий при пуше (node_modules, тяжеловесные 
        файлы которые помогают запускать проект на нашем компьютере). Файл .gitignore должен быть в папке
        с проектом. Его структура такая 
    
            # See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

            # dependencies
            /node_modules
            /.pnp
            .pnp.js

            # testing
            /coverage

            # production
            /build

            # misc
            .DS_Store
            .env.local
            .env.development.local
            .env.test.local
            .env.production.local

            npm-debug.log*
            yarn-debug.log*
            yarn-error.log*



    +++ Git Kraken
        Для более удобного вида и работы с ветками проекта существует программа Git Kraken.
    

*/}

{/*  212    ====    (Д) Сетевые Протоколы. Подключение Компьютера К Аккаунту Github Через Ssh    ====

    Ssh (Secure Shell) - сетевой протокол, спользуется для подключения компьютера(устройства) к аккаунту 
        на github. Также через него можно подключаться к gitlab и bitbucket или к другим сервисам, этот 
        тип соединения используется много где.



    В Интернете постоянно принимаются или отправляются данные - сетевой трафик. Когда мы заходим например
        на сайт гугла, мы у сервера гугла запрашиваем html страницу которую скачиваем(тоже самое происходит
        со всеми картинками, стилями, скриптами которые есть на странице) и открываем у себя на компьютере.
        В основе всей этой передачи данных находится протокол HTTP - HyperText Transfer Protocol — 
        «протокол передачи гипертекста»

        //todo почитать про HTTP



    Есть также HTTPS (secure) - это защищенная версия HTTP. Обычнный HTTP никак не шифрует данные, он
        просто пересылает их в виде текста. HTTPS появился для защиты данных которые вводит юзер, таких как 
        логин, пароль, номер банковской карты, и тд... HTTPS шифрует данные например при помощи ssl 
        сертификатов - это электронный документ размещаемый на сервере сайта для безопасного обмена данными 
        между ним и нашим браузером, в таком случае браузер сначала преобразовывает например введенный
        номер карты в набор символов созданых по алгоритму, потом идет отправка информации на сервер и там
        происходит расшифровка данных по ключу(алгоритму) который хранится на сервере. Понять что сайт
        работает по HTTPS можно посмотрев в браузере на путь адрес сайта, слева должен быть замочек. 



    Есть и другие протоколы передачи данных:
    
        ftp (file transfer protocol) для передачи файлов 
        ftps - его защищенная криптографией версия
        ssh и другие...

        У них у всех есть свое предназначение и особенности.



    Ssh - используется для удаленного управления операционными системами и передачи файлов. Он тоже
        шифрует траффик. Для создания безопасного соединения используются ключи, закрытый и открытый 
        сегенированные при помощи спец программы. Открытый на гитхабе, а закрытый у юзера на компе, при
        подключении если они совпадают то можно выполнять действие с репозиторием. При таком подключении
        не используется логин и пароль вообще.

    

    Сравнение ssh и https.

        https плюсы 
            он проще для начала работы
            доступ к сервису с разных устройств проще
            порт в ОС для https всегда открыт (потому что базовый протокол инета)

        https минусы
            ввод логина и пароля при авторизации
            если украдут логин пароль то можно сделать с аккаунтом всё что хочешь


        ssh плюсы
            при наличии ключей любое действие авторизовано
            более безопасные ключи чем пароли
            при настройке 1 раз просто подключать новые устройства
            если ключ украдут то смогуд проводить манипуляции только с репозиториями, а не с акком

        ssh минусы
            первоначальная настройка
            иногда порт для ssh в ОС может быть заблокирован
            
       
            
    Подключиться по ssh к гиту можно по инструкции для своей ОС по ссылке

        https://docs.github.com/en/authentication/connecting-to-github-with-ssh



    GitRemote привязка акка. Когда создали новый репозиторий на гитхабе для его привязки к локальному
        репо если выбирать ssh и https то путь в команде git remote к репо будет разный, следует 
        использовать для нужного протокола.


*/}

{/*  213    ====    ПРАКТИКА 1. Создаем консольное приложение    ====

    Изучение новых языков программирования почти всегда начинаются с написания консольных приложений, 
        это общепринятая практика. Этот проект будет дополнятся и расширять функциональность, так 
        происходит в любом реальном приложении. Также научимся рефакторить код проекта.
    


    ЗАДАНИЕ

    1) Создать переменную numberOfFilms и поместить в нее ответ пользователя на вопрос:
        "Сколько фильмов вы уже посмотрели?"


    2) Создать объект personalMovieDB и в него поместить такие свойства:
        - count     - сюда передается ответ на первый вопрос
        - movies    - поместить пустой объект
        - actors    - поместить пустой объект
        - genres    - поместить пустой массив
        - privat    - поместить boolean значение false
    

    3) Задать пользователю по два вопроса:
        - "Один из последних просмотренных фильмов?"
        - "На сколько его оцените?"

        Ответы поместить в отдельные переменные и
        записать в объект movies в формате:

            movies: {
                'logan': '8.1'
            }


    Подсказка: обратиться к свойству в объекте можно двумя способами:
        movies.keyMovie;     keyMovie - свойство объекта
        movies[keyMovie];    - такой метод позволит избежать багов при работе с кирилицей
                                (*если значение ключа динамическое)


    //! Проверить что бы все работало без ошибок в консоли.  */



    // РЕШЕНИЕ

            {"use strict";
            const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');
            
            const personalMovieDB = {
                count: numberOfFilms,
                movies: {},
                actors: {},
                genres: [],
                privat: false
            };
            
            const movieName = prompt('Один из последних просмотренных фильмов?', ''),
                    movieRank = prompt('На сколько его оцените?', ''),   
                    movieName2 = prompt('Один из последних просмотренных фильмов?', ''),
                    movieRank2 = prompt('На сколько его оцените?', '');
            
            personalMovieDB.movies[movieName] = movieRank;
            personalMovieDB.movies[movieName2] = movieRank2;
            
            
            console.log(personalMovieDB.movies);
            console.log(typeof(personalMovieDB.movies));
            }

}

{//  214    ====    УСЛОВИЯ    ====

    // При выполнении условия в скобках выполняется следующий код в блоке, все условия приводятся к 
        // булевому значению true или false. Если true выполняется блок следующий за условием, если 
        // false тогда выполняется блок else если он есть, если его нету то ничего не происходит.



    // при условии 4 равно 4 выполнится следующий код, ***условие ПРЕОБРАЗУЕТСЯ к булевому

            if (4 == 4) {   
                console.log('Ok');
            }

        //Звучит как ЕСЛИ(IF) 4 равно 4 тогда в консоль выведется сообщение.



    // такое условие будет всегда true

            if (4) {   
                console.log('Ok');
            }



    // В некоторых случаях нужно пойти от обратного, тоесть если условие не правдивое, то выполнится 
        // код в ELSE
    
            if (4 == 9) {   // при этом условии выполнится блок елсе , в консоль выведется еррор
                console.log('Ok');
            } else {
                console.log('Error'); 
            }  


    //! В условие можно поместить содержимое какого то элемента на странице, если содержимое будет - то
        // условие будет true и выполнятся код, если содержимого не будет, ничего не передастся в условие
        // будет null или undefined - оно преобразуется к false и выполнится блок else.



    // Часто условий много поэтому они проверяются вложенностью условий  -  else if

            const num = 50;

            if (num < 49) {
                console.log('Error');
            } else if (num > 100) {
                console.log('Too much');
            } else {
                console.log('Ok');
            }



    // Запись условий при помощи ***тернарного(тройной) оператора

            const num = 50;

            (num === 50) ? console.log('Ok') : console.log('Error'); // Ок
    
        // Если условие правдивое (true) то выполнится код после знака вопроса и до двоеточия
        // console.log('Ok'), если условие окажется false тогда выполняется код после двоеточия
        // console.log('Error').



    //Когда много условий else if, запись становится неудобной альтернативой является конструкция 
        // switch. Классически она всегда использует *** СТРОГОЕ СРАВНЕНИЕ(по типам), и больше/меньше 
        // отсутствуют. Хотя существуют хаки как это обойти.

            const num = 50;
            switch (num){
                case 49:
                    console.log('not right');
                    break;
                case 100: 
                    console.log('not right');
                    break;
                case 50: 
                    console.log('right');
                    break;
                default:
                    console.log('Not this time');
                    break;
            }

        //После каждой проверки и кода ставится слово break; что бы после выполнения кода совпавшего кейса,
        // не выполнился следующий код. default - выполняется если ни одно условие не совпало.


}

{/*  215    ====    (Д) Логические Операторы    ====

    Или (||), И (&&), опратор отрицания НЕ (!). Все эти операторы возвращают результат true или false



    И (&&) - возвращает true если ВСЕ аргументы верны(правдивы - true), если операнды - булевые значения,
        если нет возвращается значение операнда(первого ложного или последнего правдивого если все операнды
        будут правдивы).
    
        
        оба значения были true, И(&&) проверил их и выдал общий результат true, код в условии 
        выполнился. */

            const hamburger = true
            const fries = true

            if (hamburger && fries) {
                console.log('Я наелся')
            }

            console.log((hamburger && fries)) // true - результат


        /* Если применим к реальности и поставим количество продуктов, картошка фри будет 0 - в реальности
        мы бы не смогли съесть и гамбургер и картошку , потому что картошка закончилась. */

            const hamburger = 5
            const fries = 0

        /* так и в js, для возвращения результата в булевом значении будет применена динамическая типизация
        (когда один тип данных переходит в другой автоматически - строка может стать числом "5" -> 5 и 
        наоборот, и что угодно может стать логическим значинеием - булевым true или false ), такая 
        типизация дает возможность условиям (if) или логическим операторам выполнять логические 
        преобразования,  5 приведется к true потому что это положительное число, а 0 приведется к false 
        потому что оно не положительное. *//*


        //! Принцип работы -  слева на право сначала выполняется преобразование перед оператором И, а 
        потом работает И, если видит false, то дальнейшие преобразования не выполняются 
        и вернется значение операнда который вызвал остановку, если все операнды будут true вернется 
        последний:  
        
            a1 = true && true;      // t && t вернёт true
            a2 = true && false;     // t && f вернёт false
            a3 = false && true;     // f && t вернёт false
            a4 = false && 3 == 4;   // f && f вернёт false
            a5 = "Cat" && "Dog";    // t && t вернёт "Dog"
            a6 = false && "Cat";    // f && t вернёт false
            a7 = "Cat" && false;    // t && f вернёт false
            a8 = "" && false;       // f && f вернёт ""
            a9 = false && "";       // f && f вернёт false


        //! В js есть 5 типов которые всегда преобразуются к false:

             0, пустая строка ""(без пробела, с любыми кавычками), null, undefined, NaN

            //! Все остальное всегда будет true, даже отрицательные числа. потому что они не 0.



        Определение И (&&) из MDN: 

        Логическое И (&&) вычисляет операнды слева направо, возвращая сразу значение
        первого попавшего ложноподобного операнда; если все значения истиноподобны, возвращается значение
        последнего операнда.

        Если значение может быть преобразовано в true, то оно рассматривается как истиноподобное (truthy).
        Если же значение может быть преобразовано в false, то оно называется ложноподобным (falsy).

        Оператор И возвращает небулевы значения как есть

        Несмотря на то, что оператор && может использоваться с операндами, не содержащие логических 
        значений, он всё равно останется булевым оператором, поскольку его возвращаемое значение всегда 
        можно преобразовать в булевый примитив. Чтобы явно преобразовать возвращаемое значение этого 
        оператора (или вообще любое выражение) в соответствующее значение булевого типа, используйте 
        двойной оператор НЕ (!!) или конструктор Boolean.




    Или (||) - будет true если хотябы один операнд будет true. Как только оператор ИЛИ находит правду, он
        перестает работать и возвращает значение этого операнда, если все операнды будут неправда, то 
        вернет последний. */

            const a = 3;
            const b = -2;

            console.log(a > 0 || b > 0);     // true
            console.log( a || b );           // 3


            o1 = true || true; // t || t вернёт true
            o2 = false || true; // f || t вернёт true
            o3 = true || false; // t || f вернёт true
            o4 = false || 3 == 4; // f || f вернёт false
            o5 = "Cat" || "Dog"; // t || t вернёт "Cat"
            o6 = false || "Cat"; // f || t вернёт "Cat"
            o7 = "Cat" || false; // t || f вернёт "Cat"
            o8 = "" || false; // f || f вернёт false
            o9 = false || ""; // f || f вернёт ""
            o10 = false || varObject; // f || object вернёт varObject
            


        //! Следующие выражения могут показаться эквивалентными, но это не так, потому что оператор &&
        //! выполняется до оператора ||.

            true || (false && false);   // вернёт true, поскольку сначала вычисляется &&
            (true || false) && false;   // вернёт false, поскольку у группировки выше приоритет 



    /* НЕ (!) - превращает в логический типа дынных и инвертирует, двойное не (!!) преобразует значение 
        операнда в булево. */

            let a = 2   - преобрезовалось бы в true 

            console.log(a)   // 2
            console.log(!a)  // false
            console.log(!!a) // true


}

{/*  216    ====    ЦИКЛЫ    ====

    Циклы используют когда нужно автоматизировать повторяющиеся(однотипные) действия. Одно выполнение цикла
        (один проход) называется - ИТЕРРАЦИЯ. */


    
    /* +++ WHILE(пока)
        пока условие верно, выполнять код. После выполнения кода первый раз, снова идет проверка, поэтому
        чтобы не сделать бесконечный код, нужно в данном случае увеличивать переменную num++; 
        Код выполняется до тех пор пока условие не станет false, 55 в консоль не выведется потому что при
        num 55 условие не выполнится, что бы оно вывелось можно прописать (num <= 55), тогда последнее 
        значение будет 55. */

            let num = 50;

            while (num < 55) {  // 50 51 52 53 54
                console.log(num);
                num++;
            }



    // +++ DO WHILE (1 раз выполняет код, а потом проверяет условие, если оно тру, то выполняется снова).
        // Используется чтобы выполнить код хотябы раз.

            do {
                console.log(num);
                num++;
            }
            while (num < 55);



    /* +++ FOR
        Самый часто использующийся цикл, потому что подробно настраивается, состоит из трех необязательных
        аргументов. Первый аргумент цикла - начальное условие let i = 1;  і - сокращение от итерратор.
        Когда цикл запустится создастся переменная i со значением 1, которая будет доступна только в этом
        цикле, извне к этой переменной обратится нельзя. Но можно вернуть финальное значение через return.
        Второй арг. - условие при котором цикл остановит свою работу.
        Третий арг. - это шаг цикла, что будт происходить каждый раз в новом цикле, чаще всего конструкция
        с инкрементом i++, тоесть с каждой итеррацией i будет увеличиваться на 1. */

            for (let i = 1; i < 8; i++){    // 1 2 3 4 5 6 7 - выполняется 7 раз
                console.log(i);
            }


            let num = 50;
            for (let i = 1; i < 8; i++){    // 50 51 52 53 54 55 56 - выполняется 7 
                console.log(num);           // раз потому что ориентируемся на условие по i.
                num++;
            }



    //! Нужно внимательно следить какое условие мы задаем, потому что можно создать бесконечный цикл
        //! и программа или браузер зависнет пример бесконечного цикла 
        
            for (let i = 1; i > 0; i++)     //  i - всегда будет больше 0, поэтому условие не сработает.


        //Можно досрочно завершить работу цикла при определенных условиях коммандой - break.

            for (let i = 1; i < 10; i++){   // 1 2 3 4 5  - прерывание цикла при условии i === 6
                if(i === 6) {
                    break;
                }
                console.log(i);
            }



    // Опертор continue

            for (let i = 1; i < 10; i++){   // 1 2 3 4 5 7 8 9  - пропуск итерации при условии i === 6
                if(i === 6) {
                    continue;
                }
                console.log(i);
            }


}

{/*  217    ====    Вложенность циклов, метки    ====

    Каждый день похож с некоторыми вариациями - тоесть дневной цикл, и каждый день мы делаем похожие
        действия - например готовим кушать 3 раза в день, это тоже цикл, получается цикл в цикле.
        Для программирования - цикл перебирает данные, натыкается на массив в котором тоже есть много
        данных, и ему их тоже надо перебрать, получается цикл в цикле.



    Для исключения коллизии имен нужно менять имя переменной внутреннему циклу. */

            for (let i = 0; i < 3; i++ ) {
                console.log(i)
                for (let j = 0; j < 3; j++ ) {
                    console.log(j)
                }
            }

        /*В таком случаее сначала выполнится вывод i - 0, потом внутренний цикл 0, 1, 2 - выполняется до
        завершения, далее снова внешний i - 1 и снова внутренний 0, 1, 2 до выполнения и так далее.
    

    //! Можно вложить цикл и во вложенный, но слишком увлекаться вложенностью не стоит, потому что код 
    //! будет трудно читать и может наступить предел по выделению памяти.



    ПРИМЕР: Нарисовать фигуру треугольник звездочками, есть много решений этой задачи, мы разберем 
            через цикл. Видим что есть строка в которой каждый раз выводится на 1 звездочку больше,
            итого можно сделать общий цикл который будет формировать перенос звездочек на новую строку
            и вложенный который будет формировать новую строку количеством звездочек.

            *
            **
            ***
            ****
            *****
            ******


        Выводить будем в консоль, звездочки записывать в одной строке с переносами на новую строку,
        создадим переменную для нее. Сделаем переменную для фиксации количества рядов звездочек, так как
        у нас 6 рядов, поместим в переменную цифру 7 и будем говорить что не больше 7ми(можно было бы 
        поместить 6 и использовать оператор <= ). Так как на первом рядке строки у нас 1 звезда, будем 
        начинать цикл с 1. Для формирования нового рядка в строке будем использовать внешний цикл, добавляя
        в строку символ нового рядка "\n", итерации будут ограничены переменной length, а внутренний цикл 
        будет выполняться столько раз сколько у внешнего записано в переменной і, для слежения за этим
        и выполнения соответствующего условия, переменную j начнем с 0. */

            let result = ''
            const length = 7

            for (i = 1; i < length; i++) {

                for ( j = 0; j < i; j++ ) {
                    result += "*"
                }

                result += "\n"
            }

            console.log(result)



    /*МЕТКИ используются для того чтобы обратиться к нужному циклу при использовании continue или break.
        Указывается с двоеточием перед циклом, а когда хотим применить continue или break конкретно к
        этому циклу после ключевого слова прописываем эту метку. */

            first: for (let i = 0; i < 3; i++ ) {
                console.log(`First: ${i}`)

                for (let j = 0; j < 3; j++ ) {
                    console.log(`Second: ${j}`)

                    for (let k = 0; k < 5; k++ ) {
                        if (k == 2) continue first
                        console.log(`Third: ${k}`)
                    }
                }
            }

        /*в этом примере вместо пропуска итерации цикла с к (тоесть без метки было бы 0, 1, 3, 4), будет
        выполнен переход сразу на запуск новой итерации самого верхнего цикла к которому обратились,
        таким образом у цикла к никогда не будет больше (0, 1) остальные циклы будут работать без 
        пропусков. 
        
        При использовании break срабатывает остановка самого верхнего цикла, поэтому будет (0 от первого,
        0 от творого, 0, 1 - от третьего)

        В реальности используется при переборе данных. Если на каком то уровне вложенности найдутся нужные
        данные, то перебор полностью остановится.


        //! Правила названия меток такие же как у переменных.


*/}

{//  218    ====    ПРАКТИКА 2. Применяем условия и циклы    ====

    /*ЗАДАНИЕ

        1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

        2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
        отменить ответ или ввести название фильма длинее, чем 50 символов. Если это происходит -
        возвращать пользователя к вопросам снова. (К любой строке можно обратиться str.length - получить
        ее длинну)

        3)При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
        "Просмотрено довольно мало фильмов", 10-30 "Вы классический зритель", больше 30ти "Вы киноман".
        Если не подошло ни одного варианта - "Произошла ошибка"

        4) Потренироваться и переписать цикл еще двумя способами. */



    //  +++ РЕШЕНИЕ
    {    "use strict";
        const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

        const personalMovieDB = {
            count: numberOfFilms,
            movies: {},
            actors: {},
            genres: [],
            privat: false
        };

        // При сравнении нажатий на кнопку отмена - null и кнопки ок без данных(пустой строки) - '', они 
        // превращаются в 0 и засчитывается первый ответ, а не ошибка, в последующем мы это исправим
        // такие случаи нужно держать в голове и уметь с ними работать.

        if (personalMovieDB.count < 10){
            console.log("Просмотрено довольно мало фильмов");
        }else if(personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
            console.log("Вы классический зритель");
        }else if(personalMovieDB.count >= 30) {
            console.log("Вы киноман");
        }else {
            console.log("Произошла ошибка");
        }


        for (let i = 0; i < 2; i++) {
            const movieName = prompt(`Один из последних просмотренных фильмов? ${i}`, ''),
                  movieRank = prompt('На сколько его оцените?', '');
            // первая и вторая переменная не равна null - который получаем при нажатии кнопки отмены и не 
            // равны пустой строке '' и первая переменная не длинее 50 символов. Что бы не было таких 
            // длинных цепочек можно называеть переменные которые не используются дальше в коде(технические)
            // короткими названиями a и b - например.
            if(movieName != null 
                && movieRank != null 
                && movieName != '' 
                && movieRank != '' 
                && movieName.length < 50) {
                    personalMovieDB.movies[movieName] = movieRank;
                    console.log('Done');
            }else{
                console.log('Enter valid data');
                i--;    // если введены неправильные данные то цикл вернется на 1 итерацию назад  
                        // уменьшая i на единицу и вопрос будет задан повторно
            }
        }

        console.log(personalMovieDB.movies);
        console.log(personalMovieDB);
    }


}

{/*  219    ====    ФУНКЦИИ, ФУНЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ, СТРЕЛОЧНЫЕ ФУНКЦИИ    ====

    Функции - это наши действия в JS. Используют различные типы данных и изменяют информацию так как мы 
        укажем. Также как циклы значительно сокращают код. Можно представить функцию как калькулятор мы 
        задаем числа и что с ними нужно сделать, а под капотом происходят вычисления.



    Объявление функции через ключевое слово function и название(имя функции) showFirstMessage. В круглые
        скобочки передаем аргументы функции если они нужны, в фигурных находится выполняемый код. 
        Аргументов может быть бесконечное количество, они записываются через запятую

            function showFirstMessage(text, arg, num) { executable code }


        //! Переменные созданные внутри функции с помощью let и const работают только в этой 
        //! функции(локальная область видимости), их называют локальные переменные. */

            function showFirstMessage(text) {
                console.log(text);
                let num = 20;       
            }


        /* ЧТобы функция начала работу необходимо ее вызвать - запустить, если функция использует 
        аргументы их тоже передаем при вызове.*/

            showFirstMessage('Hello World!'); //'Hello World!'


        /* Негласное правило - называть функцию глаголом с припиской того над чем выполняется действие. 
        showFirstMessage - показать первое сообщение, showForm, getName. Некоторые функции могут быть
        анонимными - без имени, они вызываются и используются тут и сейчас поэтому имя им не дают. */


        /* Чтобы изменять переменную при помощи функции в общей области видимости(глобально) нужно ее 
        объявить в общей области, а в функции уже просто с ней работать без объявления. */

            let num = 20;

            function showFirstMessage(text) {
                console.log(text);
                num = 10; 
            }

            showFirstMessage('Hello World!'); //'Hello World!'
            console.log(num); // 10 - значение переменной изменилось после вызова и отработки функции.
    
    
        /* Если в самой функции объявить такую же переменную но локальную let num = 10; то ошибки не будет, 
        но и при вызове функции глобальная переменная останется 20, и в консоль выведется тоже 20 потому
        что консоль лог нажодится в одной области видимости с глобальной переменной и ничего не знает про
        локальную. */



    /* Замыкание - это сама функция вместе со всеми внешними переменными которые ей доступны.
        Когда у нас в какой либо функции есть обращение к переменной, сначала функция ищет эту переменную
        внутри себя,  если не находит, то выходит на уровень выше и ищет там. */

            let num = 20;

            function showFirstMessage(text) {
                console.log(text);
                let num = 10; 
                console.log(num); // 10
            }

            showFirstMessage('Hello World!'); //'Hello World!'
            console.log(num);   // 20



    /* return - возвращает значение ф-и(в глобальную область видимости) из функции, и после этого слова
        она прекращает работать. */
    
            function calc(a, b) {   // эту функцию можно переиспользовать много раз с разными аргументами
                return (a + b);
                console.log('Hi');  // - этот код никогда не выполнится.
            }

            console.log(calc(1, 1)); // 2 
            console.log(calc(2, 2)); // 4


            function ret() {
                let num = 50;
                return num;
            }

            const anotherNum = ret(); // присваиваем переменной возвращенное значение(результат работы), 
                                        // чтобы к нему можно было обратиться (использовать).
            console.log(anotherNum);  // 50



    // КЛАССИФИКАЦИЯ ф-й

    /* Объявление функции (FUNCTION DECLARATION) - Создается до начала выполнения скрипта(до запуска кода) 
        при первом проходе браузера по коду когда он находит все переменные var и function declaration, 
        аналогично с переменной объявленной при помощи var, но в случае с функциями ошибок не возникает,
        можно вызвать перед объявлением */

            function ret() {
                код
            }   // - при этом способе точка с запятой не ставится



    /* Функциональное выражение (FUNCTION EXPRESSION) - Создается только тогда, когда доходит 
        очередь(поток кода), можно вызвать только после объявления(создания). */

            let ret = function() {
                код
            }; // - при этом способе точка с запятой обязательна, потому что мы создаем переменную



    // Стрелочные функции - не имеют своего контекста вызова (this)

            () => {};
            
            const calc = (a, b) => { 
                console.log('Hi');
                return a + b;
            };


        // Сокращенная запись если функция в одну строчку. 

            const calc = (a, b) => a + b;       //! если тело ф-и пишем в той же строке что и ее имя - 
                                                //! это заменяет return
            
            let sum = a => a * 2;             // если параметр один то можно записать без круглых скобок

            let sum = () => console.log("Hi");     // если параметров нету указываем пустые скобочки


    
    /* КОНСТРУКТОР.

        Ф-я создается при помощи ключевых слов new Function. Такая запись полезна когда нужно 
        сконструировать ф-ю во время выполнения программы, например из данных с сервера или от пользователя.
        Недостатки такой записи - трудно читаемость и возможная дырка в программе если придут невалидные 
        данные от пользователя. */

            let f = new Function("x", "y", "return x + y");
            console.log(f(1, 2));
    

}

{/*  220    ====    (Д) Аргументы функций (еще раз)    ====

    Если действие повторяется многократно, то вместо записи каждый раз в потоке кода этого действия с
        новыми значениями нужно создать ф-ю. Рассмотрим на примере пересчета курса валют, каждый раз когда
        юзер будет вводить новую сумму, будет запускаться ф-я и пересчитывать выдавая новый результат.
        28 это условный курс валюты. */

            function convert (amount) {
                console.log(28 * amount)
            }

            convert(500)


        /* обычно ф-я не знает какое значение введет юзер - amount, оно берется с сайта и подставляется в 
        момент вызова ф-и, курс валют тоже может быть не постоянным, а полученным от банка в момент 
        загрузки сайта. Можно сделать так, но тогда ф-я будет завязана на конкретный курс валюты, также
        может быть проблематично отслеживание работы ф-и если будет изменяться переменная */

            const usdCurr = 28

            function convert (amount) {
                console.log(usdCurr * amount)
            }

        
        /* а если нам нужно будет конвертировать другую валюту, тогда нужно будет брать курс из другой 
        переменной и нужно сделать ф-ю универсальной создав еще один аргумент ф-и в который будет 
        приходить нужный курс в момент запуска */

            const usdCurr = 36
            const euCurr = 38
            const userAmount = 500
            
            function convert (amount, curr) {
                console.log(curr * amount)
            }

            convert(userAmount, usdCurr)
            convert(userAmount, euCurr)


}

{/*  221    ====    (Д) Return - важно    ====

    return позволяет вернуть из функции результат ее работы или какое то значение или даже ф-ю, то что 
        будет записано после слова return. Весь код следующих строках после строки с  return на  будет 
        недостижимым, тоесть ф-я прекратит свою работу после return и дальше не будет выполняться.


        В таком примере мы ничего не возвращаем, а выводим в консоль */

            const usdCurr = 36
            
            function convert (amount, curr) {
                console.log(curr * amount)
            }

            convert(500, usdCurr)

            /*но если нужно работать в другой ф-и с результатом полученным в этой ф-и нам нужно вернуть 
            его через return.

        
        Создадим ф-ю которая подсчитывает скидку при обмене валюты. Она принимает результат просчитанный в
        другой ф-и как параметр и умножив на скидку выдает результат в консоль, поэтому в ф-и просчета
        курса валюты нужно вернуть результат, и вызов этой ф-и можно поместить сразу в аргумент при вызове
        ф-и со скидкой. */

            const usdCurr = 36
            const discount = 0.9
            
            function convert (amount, curr) {
                return curr * amount
            }

            function promotion (result) {
                console.log(result * discount)
            }

            promotion( convert(500, usdCurr) )


            /* при вызове promotion для использования аргумента, его сначала нужно вычислить, так как в 
            скобках вызов ф-и convert, после работы convert она вернет число которое и пойдет аргументом
            для вычисления при работе ф-и promotion.


        для улучшения читаемости может быть использована переменная в которую помещается вызов ф-и, как
        промежуточный результат, она будет хранить результат работы ф-и convert, и уже ее будем 
        использовать при вызове ф-и promotion */

            const res = convert(500, usdCurr)
            promotion(res)



    //! return можно использовать без значения, просто для остановки ф-и. При таком использовании 
        //! возвращает undefined. Если не прописывать return то на уровне самого JS любая ф-я тоже
        //! возвращает undefined, поэтому при использовании метода( ф-и которая записана в объекте)
        //! console.log(11) - в консоль выведется 11 и undefined, потому что ф-я отработала и вывела
        //! в консоль 11 и так как она что то должна возвращать то возвращает undefined.

            function test () {
                for (let i = 0; i < 5; i++){
                    console.log(i)
                    if (i === 3) return     // - написано без {} потому что в одну строку
                }
                console.log('done')
            }

            test()

            /* в этом примере при срабатывании условия выполнится return и он закончит не только работу цикла
            но и работу ф-и, консоль лог с done не запустится. */



    //! return возвращает только то что написано на его строке, если сделать перенос на другую строку кода
        //! то этот код окажется недостижимым, так как JS подставит после return точку с запятой и 
        //! код на следующей строке будет считаться не относящимся к return

            function convert (amount, curr) {
                return 
                curr * amount    - недостижимый код
            }


}

{/*  222    ====    МЕТОДЫ и СВОЙСТВА СТРОК и ЧИСЕЛ (ЧАСТОИСПОЛЬЗУЕМЫЕ)    ====

    Методы - вспомогательные ф-и, свойства - вспомогательные значения. Рассмотрим ОСНОВНЫЕ 
        (часто используемые). Все методы и свойства можно посмотреть в официальной документации 
        https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String - ссылка
        на строковые методы и свойства, они видны справа от основного контента. 
        
        //!Также их можно найти в консоли прописав console.dir(Number) - например для чисел, выведется 
        объект число со всеми его возможным методами и значениями.
                


    +++  СТРОКА  +++

        length - свойство для получения количества элементов различных типов данных. Свойства мы никак не 
        вызываем, прописываем  просто через точку, Методы(функции) вызываются при помощи круглых скобок. 
        //! при использовании свойства мы его НЕ запускаем через скобки как методы и ф-и */
            
            const str = 'test';
            const arr = [1, 2, 3];

            console.log(str.length); // 4 - количество элементов строки
            console.log(arr.length); // 3 - количество элементов массива

            console.log(str[2]);     /* s - получили символ под индексом 2, как в массивах
                                     /! так можно получить символ но не изменить его в строке  
            
            !Чтобы взаимодействовать со строкой сущестуют методы, тоесть вот так присвоить букву не 
            !получится str[2] = 'd'.
    


        МЕТОДЫ СТРОКИ 

        Изменение регистра */
            
            const str = 'teSt';

            str.toUpperCase(); // TEST - ВОЗВРАЩАЕТ НОВУЮ строку со всеми заглавными(большими) буквами
                                //! ***НЕ ИЗМЕНЯЕТ исходник
            
            str.toLowerCase(); // test - ВОЗВРАЩАЕТ НОВУЮ строку со всеми маленькими буквами 
                                //! ***НЕ ИЗМЕНЯЕТ исходник.  Используется для обработки данных из поля 
                                // ввода, что бы получать всегда однотипные строки и далее работать с ними 
                                // тоесть если юзер введет teSt он в поиске не найдет test в базе данных, 
                                // чтобы они совпадали и поск работал нужно их привести к одному регистру

    
        // Поиск подстроки (поиск буквы или выражения внутри строки)
            
            const fruit = "Some fruit";

            fruit.indexOf("fruit"); // 5 - возвращает индекс с которого начинается искомая буква или 
                                    // выражение включительно
            
            fruit.indexOf("q"); // -1 - когда искомый фрагмент в строке отсутствует выводит минус один


        /* Модификация строки 

        slice - ВОЗВРАЩАЕТ НОВУЮ СТРОКУ согласно заданым параметрам. 1й - с какого индекса  включительно,
        2й - по какой индекс  *НЕ включительно, возвращает строку.  //! ***НЕ ИЗМЕНЯЕТ исходник */
            
            const logg = "Hello world!"; // индекс - 10, символов - 11
            logg.slice(6, 11);  // world
            logg.slice(6);      // world - если указать только 1 аргум. С какого индекса и до конца.
            logg.slice(-6, -1); // world - отсчет идет с конца строки


        // substring (НЕ поддерживает отрицательные числа, если -6 - будет интерпретировано как 0, первое  
        // число можно задавать больше че второе).ВОЗВРАЩАЕТ НОВУЮ СТРОКУ. //! ***НЕ ИЗМЕНЯЕТ исходник
        // работает также как slice, что использовать выбираем сами
    
            logg.substring(6, 11);  //world 


        // substr - 1й арг указываем с какого индекса, 2й сколько символов нужно вернуть.
        // ВОЗВРАЩАЕТ НОВУЮ СТРОКУ.     //! ***НЕ ИЗМЕНЯЕТ исходник
            
            logg.substr(6, 5);  /*world 



    +++  ЧИСЛО  +++

        Math - библиотека для работы с числами встроенная в браузер  */
        // ВОЗВРАЩАЕТ НОВОЕ ЧИСЛО округленно к ближайшему целому   //! ***НЕ ИЗМЕНЯЕТ исходник                   
        
            const num = 12.2;
            Math.round(num);   // 12


        // parseInt - переводит число в другую систему исчисления (ВОЗВРАЩАЕТ НОВОЕ ЧИСЛО)     
        // для обрезания строки и перевода в целое число (часто можно получить такие размеры элемента со 
        // страницы) //! ***НЕ ИЗМЕНЯЕТ исходник

            const test = '12.2px';
            parseInt(test); // 12 - число


        // parseFloat - изначально служит для того что бы число или строку возвращать в десятичном 
        // варианте. ВОЗВРАЩАЕТ НОВОЕ ЧИСЛО   //! ***НЕ ИЗМЕНЯЕТ исходник
    
            parseFloat(test); // 12.2 - число c десятыми


}

{//  223    ====    ПРАКТИКА 3. Используем функции    ====

    /*ЗАДАНИЕ

        1) Первую часть повторить по уроку

        2) Создать ф-ю showMyDB, которая будет проверять свойство privat. Если оно false - выводит в 
            консоль глвный объект.

        3) Создать ф-ю writeYuorGenres в которой пользователь будет 3 раза отвечать на вопрос 
           "Ваш любимый жанр под номером ${номер по порядку}?". Каждый ответ записывается в массив данных
            genres.

        PS: ф-ии вызывать не обязательно
        
        


    +++ РЕШЕНИЕ */
    
    {"use strict";
        /* В ф-ю start поместим инициализирующий вопрос с которого начинается работа программы 
        const numberOfFilms = +prompt('С...
        также добавим проверку что бы пользователь не мог отменить вопрос, ввести пустую строку или нечисло.
        Что бы он вводил число мы ограничивались плюсом перед +prompt, но теперь этого мало. Проверка будет 
        на этапе выполнения, когда он нажал клавишу ОК. *Для проверки на этапе ввода в инпут нужно 
        использовать РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ которые изучим позднее. 

        При переносе numberOfFilms в ф-ю она станет локальной и мы не сможем записать ее в personalMovieDB
        напрямую(можно через return сделать ее вывод), поэтому мы объявим переменную numberOfFilms 
        глобально, а присваивание значения и вопрос пренесем в ф-ю и сменим объявление numberOfFilms с 
        const на let чтобы можно было ее изменять.

        Проверку на правильность ввода мы делали через цикл for и использовали проверку правдивости, но мы
        можем использовать и while, пойдем от обратного чтобы увидеть и другие логические конструкции. Тут
        мы будем проверять неправдивые(неправильные варианты) если это так то вопрос повторится, а если 
        все хорошо то цикл будет закончен. Проверяем numberOfFilms - пустая строка или null( кнопка 
        ОТМЕНА) или isNaN(numberOfFilms) - метод проверяет аргумент и если внутри не число то он 
        возвращает правду. Тоесть цикл будет продолжаться(задавать вопрос пользователю пока он будет вводить
        невалидные данные в поле ввода) до тех пор пока условия не станут ложными - тоесть введенные 
        значения будут валидными для условия проверки но невалидные для нас.  А когда значения  будут 
        невалидные для условия, но правильными для нас(числовой тип) тогда цикл остановится. 
        далее вызовем(запустим) ф-ю start */

        let numberOfFilms;

        function start () {
            numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

            while (numberOfFilms == '' || numberOfFilms == null || isNaN(numberOfFilms)){
                numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');
            }
        }

        start()


        const personalMovieDB = {
            count: numberOfFilms,
            movies: {},
            actors: {},
            genres: [],
            privat: false
        };

        // Сделаем обвертку ф-цией этого блока для того что бы вызывать его только по требованию в 
        // дальнейшем. А сейчас сделаем для нее вызов.
        function rememberMyFilms(){
            for (let i = 0; i < 2; i++) {
                const movieName = prompt(`Один из последних просмотренных фильмов? ${i}`, ''),
                    movieRank = prompt('На сколько его оцените?', '');
                
                if(movieName != null 
                    && movieRank != null 
                    && movieName != '' 
                    && movieRank != '' 
                    && movieName.length < 50) {
                    personalMovieDB.movies[movieName] = movieRank;
                    console.log('Done');
                }else{
                    console.log('Enter valid data');
                    i--;
                }
            }
        }

        rememberMyFilms();

        // Эту часть кода тоже оборачиваем в ф-ю. *Таким образом у нас появились ф-и к которым можно 
        // обратиться и вызвать их в нужное время или по событию.
        function detectPersonalLevel(){
            if (personalMovieDB.count < 10){
                console.log("Просмотрено довольно мало фильмов");
            }else if(personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
                console.log("Вы классический зритель");
            }else if(personalMovieDB.count >= 30) {
                console.log("Вы киноман");
            }else {
                console.log("Произошла ошибка");
            }
        }

        detectPersonalLevel();

        // Мое решение
        // function showMyDB(){
        //     if (personalMovieDB.privat){
        //         console.log('This is a privat object.');
        //     } else {
        //         console.log(personalMovieDB);
        //     }
        // }
        // showMyDB();

        // Сделаем передачу данных из personalMovieDB.privat в параметр hidden. Тогда условие звучит так,
        // если база НЕ скрыта(!hidden - нот тру) показываем. false передается в хидден и через ! 
        // становится тру и показывается база данных, а если в privat будет тру то оно превратится в фолс 
        // и не покажется.
        function showMyDB(hidden){
            if (!hidden){
                console.log(personalMovieDB);
                } else {
                console.log('This is a privat object.');
            }
        }
        showMyDB(personalMovieDB.privat);


        //Мое решение
        // function writeYourGenres(){
        //     for(let i = 1; i < 4; i++){
        //         personalMovieDB.genres[i-1] = prompt(`Ваш любимый жанр под номером ${i}?`);
        //     }
        // }
        // writeYourGenres();

        function writeYourGenres(){
            for(let i = 1; i <= 3; i++){
            // Первоначальный код через переменную
            // const genre = prompt(`Ваш любимый жанр под номером ${i}?`);
            // personalMovieDB.genres[i - 1] = genre; 

            //personalMovieDB.genres.push(genre);  - так тоже работало с переменной

            //Уменьшим код такой записью - код работает быстрее потому что не нужно создавать переменную
                personalMovieDB.genres[i-1] = prompt(`Ваш любимый жанр под номером ${i}?`);
            }
        }
        writeYourGenres();

        console.log(personalMovieDB.genres);
        console.log(personalMovieDB);
    }


}

{/*  224    ====    (Д) Метод Trim()    ====

    trim() - метод строки который позволяет удалять символы пробела в начале и в конце строки. Если строка
        состоит только из пробелов то она станет пустой. 
        //! Возвращает новую строку, НЕ изменяет оригинал



    Вспомним наш код где выполнялась проверка на правильность ввода 

            if(movieName != null && movieRank != null 
                        && movieName != '' 
                        && movieRank != '' 
                        && movieName.length < 50) {
                        personalMovieDB.movies[movieName] = movieRank;
                        console.log('Done');

        при такой проверке если юзер введет просто пробелы они засчитаются за правильный ответ, потому
        что строка не будет пустой. Можно для учитывания этого кейса написать дополнительные проверки 
        или использовать регулярные выражения которые изучим далее, но это сложнее чем применить к строке
        метод trim.
        

    Можно использовать уже на переменной в которую поместился ответ юзера и потом снова присвоить
        ей результат работы trim, а можно сразу на стадии получения ответа от юзера поместить
        этот ответ в скобки и применить к нему вызов trim и уже этот результат поместить в переменную. */

            const f = ( prompt('Один из последних просмотренных фильмов?', '') ).trim()


    //! также этот метод полезен когда нужно проверить корректность данных пришедших с сервера или
    //! убрать пробелы которые попадают в строку при выполнении некоторых ф-й
                            

}

{/*  225    ====    CALLBACK ФУНКЦИИ    ====

    Ф-я выполняет какой то код и если после нужно подождать какое то время, например для того что бы сервер 
        прислал данные, это ожидание можно сэмулировать такой конструкцией setTimeout в нее вкладываем ф-ю 
        которая будет выполнена через 0.5(500 мл секунд) секунды. */

            function first() {
                
                //do something

                setTimeout(function() {
                    console.log(1);
                }, 500);
            }
                            
            function second() {         // Эта ф-я выведет двойку в консоль без задержки
                console.log(2);
            }

            first();
            second();

        /* Вызываем ф-ии по порядку, они обе будут выводить в консоль значения
        В консоли получили рез-т сначала 2 потом 1, тоесть вторая ф-я сработала раньше чем первая. Но в
        реальной работе мы можем не знать что будет задержка(например через сколько ответит сервер), но 
        когда мы вызываем ф-и в коде в определенном порядке то нам нужно чтобы они  выполнились в
        этом порядке, а с неизвестной задержкой такого может не получиться и если вторая ф-я работает с 
        результатом первой то может произойти ошибка. Чтобы исключить такие ошибки придумана сallback ф-я
        
        ! если ф-ии в коде идут одна за другой это значит что запускаются они одна за другой но 
        ! результат могут отдать в разное время.



    сallback - по простому это ф-я которая начинает выполнятся после того как другая ф-я завершила 
        свою работу. 
        
        В этом примере ф-я callback выполнится после того как отработает console.log потому что
        мы передаем ее аргументом(не запуская) в другую ф-ю learnJS, а запускается она уже после того 
        кода который должен быть выполнен раньше в теле ф-и learnJS, тоесть отложенный запуск */

            function learnJS(lang, callback) {
                console.log(`Я учу ${lang}`);
                callback();
            }
    
            learnJS("Java Script", function() {
                console.log('Я прошел этот урок.')
            });

        /* Вызываем ф-ю learnJS. 1й аргумент строка которую нужно вывести первой, 2й - ф-я которая 
        отработает позже , таким образом всегда будет соблюдатся последовательное выполнение ф-й 

        в таком примере всю анонимную ф-ю написали сразу в аргументе 
        learnJS("Java Script", function(){сonsole.log('Я прошел этот урок.')} ); 
        

        Так как ф-я анонимная больше мы к ней не сможем обратиться и получить ее значения, но можно
        передавать и ф-ю с именем, при этом ф-я без скобок потому что мы ее не вызываем тут, а вызываем
        в learnJS этой строкой callback();  после выполнения предыдущего кода */
    
            function learnJS(lang, callback) {
                console.log(`Я учу ${lang}`);
                callback();
            }

            function done() {
                console.log('Я прошел этот урок.');
            }

            learnJS("Java Script", done);



    /* В практике колбеки используются постоянно при запросах к серверу или при срабатывании какого-то 
        события на странице, после клика пользователя 1й аргумент, передаем имя ф-и которая будет после 
        этого выполнятся. Или если осваивать серверное программирование на NOD.js там все построено на 
        колбэках. */


}

{/*  226    ====    ОБЪЕКТЫ и их ДЕСТРУКТУРИЗАЦИЯ    ====

    Углубимся в работу с методами объекта.  Создадим объект вторым способом, не через фигурные скобки. 
    Обычно им не пользуются, потому что такая  запись длинее   const obj = new Object();     */
   
            const options = {   //Создадим объект для практики обычным способом
                name: 'test',
                width: 1024,
                height: 1024,
                colors: {
                    border: 'black',
                    bg: 'red'
                }
            };

            console.log(options.name);                 // доступ к значению свойства почучаем через точку
            console.log(options['colors']['border']); //  или через квадратные скобки

    
            delete options.name;   // Для удаления из объекта используем метод delete если нужно удалить
                                  // много свойств используем перебор с delete в середине


        /* Для перебора  объекта используем метод for in. В скобках указываем переменную, обычно ее 
        называют key(ключ) потому что мы не знаем имен параметров в объекте, а имя такое потому что 
        используются пары - ключ + его значение и также указываем в каком объекте будем делать перебор 
        in options.  В середине как в обычном цикле задаем действия которые будут повторятся при каждой 
        итерации цикла, а итераций будет столько сколько свойств(ключей) у объекта. 
        !for of для объекта не работает. */
        
            for (let key in options) {
                console.log(`Свойство ${key} имеет значение ${options[key]}`);
                //! Обращение через точку не работает, потому что переменная
            }

        /* в консоль выводятся свойства объекта, а для colors вывелось свойство [object Object] дело в том
        что все значения выводятся в качестве строк, а значение colors это объект (вложенная конструкция)
        и когда JS натыкается на нее он не может объект превратить в строку поэтому и выводит строковое
        представление объекта. С этим просто нужно уметь работать, в переборах можно использовать рекурсию,
        но ее мы изучим позднее. 
        
        Но сейчас сделаем проверку внутри цикла перебора на значение объекта, и если его получим то можно
        запустить еще один перебор внутри основного перебора, с другим именем переменной. */

            for (let key in options) {
                if (typeof(options[key]) === 'object') {
                    for (let i in options[key]) {
                        console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
                    }
                } else {
                    console.log(`Свойство ${key} имеет значение ${options[key]}`);
                }
            }

        /* Теперь в консоль выводится правильные пары свойство(ключ) + значение. Чуть позже рассмотрим 
        рекурсию и по факту будет работать точно также но не с циклом, а с функцией.
    


    Рассмотрим стандартные(встроенные методы) объектов, их как всегда можно посмотреть в документации.
        В ней можно увидеть что в объекте нету свойства length, мы не можем узнать сколько элементов(пар)
        находится в объекте. Самый простой способ это создать такой перебор, а в нем переменную которая
        будет подсчитывать сколько свойств оказалось внутри, этот прием на первых порах используется очень
        часто. */

            let counter = 0;
            for (let key in options) {
                if (typeof(options[key]) === 'object') {
                    for (let i in options[key]) {
                        console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
                        counter++;
                    }
                } else {
                    console.log(`Свойство ${key} имеет значение ${options[key]}`);
                    counter++;
                }
            }
            console.log(counter); // 5 - полное количество объектов вместе со вложенными. 
            
            /*Если хотим получить только те которые на верхнем уровне тогда нужно удалить counter++; 
            из блока if отвечающего за  true, и получим значение 3 потому что условие пошло по другой 
            вилке if и не учло что есть вторая, чтобы учесть все свойства нужно убрать условие */

            for (let i in options[key]) {
                console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
            } else 


        // Поэтому классический метод перебора используемый для того что бы узнать количество свойств 
        // объекта такой

            let counter = 0;
            for (let key in options) {
                counter++;
            }
            console.log(counter); // 4 - как раз то что нужно


        /* Но каждый раз объявлять переменную и запускать перебор для того что б узнать количество свойств
        в объекте - слишком много кода, можно использовать стандартные(встроенные) методы объекта 
        Object.keys - он добавляет все ключи первого(верхнего) уровня вложенности в массив и возвращает 
        его, а в массиве мы уже можем узнать  его длинну через length */

            console.log(Object.keys(options)); // ['name', 'width', 'height', 'colors']
            console.log(Object.keys(options).length); // 4



        // Методы мы можем создавать вручную. Модифицируем объект.

            const options = {
                name: 'test',
                width: 1024,
                height: 1024,
                colors: {
                    border: 'black',
                    bg: 'red'
                },
                makeTest: function () {
                    console.log("It's test");
                }
            };

            options.makeTest(); 
            
            /* вызывается созданный метод как ф-я или метод через круглые скобки
            !Доступ к методу через [] - не работает.

        !Также в объектах есть - свойства акцессоры(access) get и set, рассмотрим позже. 



     +++ ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТА

        Ее можно провести и с массивами, разберем далее в курсе.
        Часто нужно достучаться до вложенных свойств и не очень удобно каждый раз использовать такую 
        конструкцию  options['colors']['border'], для избежания такого и существует деструктуризация - по 
        простому мы будем вытаскивать вложенные свойства в переменную в качестве отдельных 
        структур(коробочек) и там уже их использовать */
        
            const {border, bg} = options.colors; // вытаскиваем свойства вложенного объекта по названиям 
                                                // свойств и формируем переменные с таким же названием
                                                // получили 2 переменные
            console.log(border); // black - далее просто используем как переменную



    /* У обычной строки через просмотр ее свойств через console.dir() можно увидеть методы которых не 
        должно быть у строки, они приходят от прототипа объекта, это значит что в каком то объекте 
        прописан такой метод, почти все сущности JS сводятся к объектам. */


}

{/*  227    ====    МАССИВЫ  и ПСЕВДОМАССИВЫ    ====

    Массив - это структура которая содержит элементы по порядку(в определенном порядке)



    +++ МЕТОДЫ МАССИВОВ

        Создадим массив для практики */

            const arr = [1, 2, 3, 8, 6];

            arr.push(10);   // Добавляет заданный элемент в конец массива [1, 2, 3, 8, 10]
            
            arr.pop();      // Удаляет последний элемент массива [1, 2, 3, 8]
            
            arr.unshift(20);// Добавляет эл. в НАЧАЛО массива [20, 2, 3, 8, 10]
            
            arr.shift();    // Удаляет ПЕРВЫЙ элемент массива [2, 3, 8, 10]

        /* Методы работы с НАЧАЛОМ массива используются очень редко потому что при добавлении/удалении 
        первого элемента индексы всех остальных эл. меняются, это вносит неразбериху и если массив 
        содержит например 2 тысячи элементов, заставляет программу задействовать много ресурсов компьютера
        для смены индексов и увеличивает время выполнения программы. 
            


        Методы ПЕРЕБОРА массива.
    
        ! for  ***ИЗМЕНЯЕТ МАССИВ
        Для этого можно использовать цикл for. В условии пропишем что бы он работал до тех пор пока i
        будет меньше длинны массива  i < arr.length. Длинна массива 5 - элементов, на 1 больше чем 
        индексов в нем. Так как наша i = 0, то получится что мы выполним столько же итерраций цикла 
        сколько и элементов потому что индекс 4 все еще меньше длинны 5 и так элемент будет 
        перебран(прочитан).    */

            const arr = [1, 2, 3, 8, 6];
            for (let i = 0; i < arr.length; i++) {
                console.log(arr[i]);    // Все элементы выведутся по очереди в консоль, по одному 
                                        // за каждую итеррацию 1 2 3 8 6
            }


        //! for of  *** НЕ ИЗМЕНЯЕТ МАССИВ
        /* Также можно использовать конструкцию перебора for of. Объявляем переменную в которую будет 
        присваиваться значения массива по очереди, в данном случае value(можно любое) и указываем в каком
        массиве делать перебор of arr */
            
            for (let value of arr) {
                console.log(value);     // Все элементы выведутся по очереди в консоль 1 2 3 8 6
            }

            /* Этим методом мы //!НЕ можем перебрать объект, но можем перебрать массив и массивоподобные 
            сущности: строку, псевдомассив, определенные элементы со страницы и такие сущности как - 
            Map и Set( это коллекция и особый вид коллекции, про них поговорим в следующих уроках). */
        

        //! Обычно длинна масива равна количеству элементов. Но бывают случаи когда это правило нарушается.

            const arr = [1, 2, 3, 8, 6];
            arr[99] = 0;                // Поместим на 99 индекс число 0

            console.log(arr.length);    // 100 - получили длинну массива 100(вроде как 100 элементов, 
                                        // хотя мы знаем что их 6)
            console.log(arr);           // (100) [1, 2, 3, 8, 6, empty × 94, 0] - видим 94 пустых ячейки
        
            //! поэтому длинна массива length равна индексу последнего элемента +1, а не реальному 
            //! количеству элементов внутри.


        //! forEach ***ИЗМЕНЯЕТ МАССИВ
        /* Наиболее часто используется структура forEach() по факту он работает как и предыдущие методы 
        перебора, но его можно подробнее настроить. forEach в себя принимает callback ф-ю которая будет 
        выполнена каждый раз для каждого элемента массива она принимает 3 аргумента, 1й - элемент 
        массива(именовать можно как угодно), 2й - индекс элем.(номер по порядку) (именовать можно как 
        угодно) тоесть при переборе мы кроме значения можем также сохранить(обратиться) индекс элем., 
        3й - имя перебираемого массива */
        
            const arr = [1, 2, 3, 8, 6];
            arr.forEach(function(item, i, arr ) {
                console.log(`${i}: ${item} внутри массива ${arr}`);
            });
                // 0: 1 внутри массива 1,2,3,8,6
                // 1: 2 внутри массива 1,2,3,8,6
                // 2: 3 внутри массива 1,2,3,8,6
                // 3: 8 внутри массива 1,2,3,8,6
                // 4: 6 внутри массива 1,2,3,8,6

        /* Этот метод позволяет удобно манипулировать массивом, например элементами со страницы. Их можно
        перебрать и например каждой кнопке ${i} назначить дополнительный класс(значение) ${item}. Или
        взять каждый текстовы элемент по определенному селектору и модифицировать его.  */


        /*//! Когда использовать forEach а когда for of. обычно всегда используют forEach, но в for of мы 
        можем использовать ключевые слова break и continue, они очень важны если нам нужно будет или 
        остановить цикл или пропустить итерацию, а в forEach мы такого сделать не сможем.


        //! НЕ СООТВЕТСТВИЕ В УРОКЕ, на самом деле 
        метод forEach может изменять массив если мы это явно укажем. А методы map, filter, reduce - это 
        методы возвращающие новый массив не изменяя старый, every/some - возвращают булево значение 
        основанное на поиске заданного условия в массиве, также не изменяют исходный, для всех методов
        которые возвращают новое значение или массив нужно в теле прописывать return и присваивать 
        переменной чтобы работать с результатом этих методов.
    

        //!split ***НЕ ИЗМЕНЯЕТ исх. строку
        метод строки, для превращения ее в массив. Когда от пользователя или от сервера приходит большая
        строка с множеством например товаров разделенных каким то знаком например запятой. Для более 
        удобной работы с такой информацией ее лучше превратить в массив. split - принимает аргументом знак
        разделения по которому нужно отделить элементы строки один от другого и записать в массив по 
        порядку, при этом нам нужно точно знать какой разделить будет в строке в данном случае 
        запятая + пробел (", ") */
        
            const str = prompt("Введите товары через запятую", "");
            const products = str.split(", ");
            console.log(products);  

            /* такой код поделит строку только если слова будут разделены запятой + пробел, если просто 
            запятая, то будет 1 элемент массива. А если вписать просто запятую, то если пользователь будет
            вводить через запятую + пробел, в таких элементах  будет перед буквами пробел.


        ! join - преобразует массив в строку  ***НЕ ИЗМЕНЯЕТ исх. массив
        Это обратный метод, который из массива делает строку, например если нужно пользователю вывести 
        строкой список приглашенных. Аргументом принимает разделитель которым разделятся слова в строке. */

            const str = prompt("Введите товары через запятую", "");
            const products = str.split(", ");   // создаем массив из строки разделяя на эл. по 
                                                // запятой + пробел
            console.log(products.join('; '));   // из массива создаем строку с разделителями между
                                                /* словами  ('; ')


        !sort  ***ИЗМЕНЯЕТ исходный массив
        Метод сортировки массива(всегда сортирует элемент массива как СТРОКУ ) по алфавиту
        !При сортировке массива, отдается предпочтение словам начинающимся с большой буквы, тоесть Боб
        будет первее чем аня, поэтому при сортировке стоит приводить все слова к одному регистру. */

            const str = prompt("Введите товары через запятую", ""); // qqq, aaa, bbb
            const products = str.split(", "); 
            products.sort();                                        // отсортировалось по алфавиту
            console.log(products.join('; '));                       //  aaa; bbb; qqq


            // Но если нужно отсортировать числа то получим такое поведение

            const arr = [2,13, 26, 8, 10];
            arr.sort();     /* [10, 13, 2, 26, 8] - не по возрастанию как числа,

            сортирует как строки посимвольно, тоесть сначала все числа у которых 1, потом сравнивает
            вторые символы.
        
        ! Чтобы числа в массиве сортировались как числа нужно дописать ф-ю, назовем ее compareNum, в 
        которой будет 2 аргумента а и б(можно именовать как угодно) в них будут приходить соседние 
        элементы массива, и с ними будет  выполнятся отнимание, при этом они будут приводится к числовому
        значению, и если результат будет минусовое число или равен 0, то элементы остаются на своих местах,
        а если плюсовое число, тоесть первое больше, тогда меняются местами. И передать ф-ю как аргумент в
        метод sort */
            
            function compareNum(a, b) {
                return a - b;
            }

            const arr = [2,13, 26, 8, 10];
            arr.sort(compareNum);   // [2, 8, 10, 13, 26]

            /*Теперь сортировка числовых значений в массиве произошла правильно.



    +++ ПСЕВДОМАССИВЫ 
    
    //! в видео сказано что нету forEach но он есть в псевдомассивах наследуемых от NodeList которые 
    //! получены через новые методы получения елементов со страницы.
    
    Псевдомассивы получаются когда мы работаем с элементами на странице. По факту это такой объект 
    структура которого совпадает со структурой массива. Выглядят он также как обычные массивы, но у них
    нету методов( filter, push, pop, join, и т.д.), только свойство length, это просто структура которая 
    хранит данные по порядку. */


}

{/*  228    ====    Алгоритмы в целом и в JavaScript    ====
    
    По ссылке из курса http://mathhelpplanet.com/static.php?p=javascript-algoritmy-poiska


    Алгоритмы поиска на JavaScript

    Задача поиска связана с нахождением заданного значения, называемого ключом поиска (search key), среди
    заданного множества. Существует огромное количество алгоритмов поиска, так что есть из чего выбирать.
    Их сложность варьируется от самых простых алгоритмов поиска методом последовательного сравнения, до 
    чрезвычайно эффективных, но ограниченных алгоритмов бинарного поиска, а также алгоритмов, основанных 
    на представлении базового множества в иной, более подходящей для выполнения поиска форме. Последние из 
    упомянутых здесь алгоритмов имеют особое практическое значение, поскольку применяются в реально 
    действующих приложениях, выполняющих выборку и хранение массивов информации в огромных базах данных.


    Для решения задачи поиска также не существует единого алгоритма, который бы наилучшим образом подходил
    для всех случаев. Некоторые из алгоритмов выполняются быстрее остальных, но для их работы требуется 
    дополнительная оперативная память. Другие выполняются очень быстро, но их можно применять только для
    предварительно отсортированных массивов, и т.п. В отличие от алгоритмов сортировки в алгоритмах 
    поиска нет проблемы устойчивости, но при их использовании могут возникать другие сложности. В 
    частности, в тех приложениях, где обрабатываемые данные могут часто изменяться, причем количество 
    изменений сравнимо с количеством операций поиска, поиск следует рассматривать в неразрывной связи 
    с двумя другими операциями — добавления элемента в набор данных и удаления из него. В подобных 
    ситуациях необходимо видоизменить структуры данных и алгоритмы так, чтобы достигалось равновесие 
    между требованиями, выдвигаемыми к каждой операции. Кроме того, организация очень больших наборов 
    данных с целью выполнения в них эффективного поиска (а также добавления и удаления элементов) 
    представляет собой чрезвычайно сложную задачу, решение которой особенно важно с точки зрения 
    практического применения.



    --Линейный поиск на JavaScript
    Алгоритм линейного поиска (linear search) просто по очереди сравнивает элементы заданного списка с 
    ключом поиска до тех пор, пока не будет найден элемент с указанным значением ключа (успешный поиск) 
    или весь список будет проверен, но требуемый элемент не найден (неудачный поиск). Зачастую применяется 
    простой дополнительный прием: если добавить ключ поиска в конец списка, то поиск обязательно будет 
    успешным, следовательно, можно убрать проверку завершения списка в каждой итерации алгоритма. Далее 
    приведен код реализации данного алгоритма на JavaScript; предполагается, что входные данные имеют 
    вид массива. */

        function LinearSearch(t,A)      // t - искомый элемент,
        {                               // A - массив, в котором ищем.
            var n = A.length, i = 0;   
            
            A[n] = t;
            
            while (A[ i ] !== t) i++;
                                        
            if (i < n) return i;          // На выходе индекс искомого элемента.
            else return -1;               // Если искомого элемента нет в массиве, то -1.
        }



    /* --Бинарный (двоичный) поиск на JavaScript
    Поиск элемента в отсортированном массиве. Бинарный поиск (binary search) представляет собой в высшей 
    степени эффективный алгоритм для поиска в отсортированном массиве. Он работает путем сравнения 
    искомого ключа t со средним элементом массива A[k]. Если они равны, алгоритм прекращает работу. В 
    противном случае та же операция рекурсивно повторяется для первой половины массива, если t&lt;A[k], 
    и для второй, если t&gt;A[k].

    Стандартная реализация алгоритма бинарного поиска на JavaScript */

        function BinarySearch(t,A)         // t - искомый элемент,
        {                                  // A - упорядоченный массив, в котором ищем.
            var i = 0, j = A.length-1, k;   

            while (i <= j)
            {  k = Math.floor((i+j)/2);
            if (t === A[k]) return k;
            else if (t < A[k]) j = k-1;
            else i = k+1;
            }
                                        // На выходе индекс искомого элемента.
            return -1;                     // Если искомого элемента нет в массиве, то -1.
        }


    //Оптимизированный вариант

        function BinarySearch(t,A)       // t - искомый элемент,
        {                                // A - упорядоченный массив, в котором ищем.
            var i = 0, j = A.length, k; 
                                        
            while (i < j)                
            {  k = Math.floor((i+j)/2);
            if (t <= A[k]) j = k;
            else i = k+1;
            }
        
            if (A[ i ] === t) return i;     // На выходе индекс искомого элемента.
            else return -1;                 // Если искомого элемента нет в массиве, то -1.
        }



    /* --Интерполирующий поиск на JavaScript
    Рассмотрим алгоритм поиска в отсортированном массиве, который называется интерполирующим поиском 
    (interpolation search). В отличие от бинарного поиска, который всегда сравнивает ключ поиска со 
    средним значением отсортированного массива (а следовательно, всегда уменьшает размер задачи вдвое), 
    интерполяционный поиск учитывает значение ключа поиска при определении элемента массива, который будет 
    сравниваться с ключом. В определенном смысле алгоритм имитирует поиск имени в телефонной книге. Если 
    мы ищем в телефонной книге, например, Иванов — вряд ли мы будем открывать ее в средине или ближе к 
    концу, как поступили бы при поиске Петрова. */

        function InterpolationSearch(t,A)          // t - искомый элемент,
        {                                          // A - упорядоченный массив, в котором ищем.
            var mid, low = 0, high = A.length-1;

            while (A[low] < t && A[high] > t)
            {  mid = low + Math.floor( ((t-A[low])*(high-low))/(A[high]-A[low]) );
            if (A[mid] < t) low = mid+1;
            else if (A[mid] > t) high = mid-1;
            else return mid;
            }

            if (A[low] === t) return low;           // На выходе индекс искомого элемента.
            else if (A[high] === t) return high;    // Если искомого элемента нет в массиве, то -1.
            else return -1;
        }



    /* --Поиск подстроки на JavaScript
    Формально задачу поиска подстроки (substring search) можно сформулировать следующим образом. Пусть 
    есть некоторый текст \mathsf{str} символов с длиной N, и шаблон \mathsf{sub} с длиной n~ (n\leqslant N)
    в виде строки. Если для некоторого значения i\in[0;N-n+1) выполняется равенство 
    \mathsf{str}[ i],\ldots,\mathsf{str}[i+n-1]= \mathsf{sub}[0],\ldots,\mathsf{sub}[n-1], т.е. если для 
    всех j\in[0;n) справедливо равенство \mathsf{sub}[j]=\mathsf{str}[i+j], то будем говорить, 
    что шаблон \mathsf{sub} входит в текст \mathsf{str} со сдвигом i. Задача поиска подстроки состоит в 
    определении сдвига, с которым шаблон \mathsf{sub} входит в текст \mathsf{str} (или установлении того 
    факта, что текст не содержит подстроки, соответствующей шаблону). Проще говоря, нужно определить 
    индекс i крайнего слева символа первой соответствующей шаблону \mathsf{sub} подстроки в тексте 
    \mathsf{str}

        (например, если str = "Lorem ipsum" и sub = "ips", то i=6).


    Простейший алгоритм поиска состоит в непосредственной проверке всех возможных смещений. Проверка 
    заключается в последовательном сравнении символов шаблона \mathsf{sub} с символами строки \mathsf{str};
    при первом же обнаруженном несовпадении символов проверка прекращается и переменная внешнего цикла 
    увеличивается на 1. */

        function SubstringSearch(sub, str)    // sub - искомая подстрока
        {                                     // str - строка, в которой ищем
            var i, j, n = sub.length,
                N = str.length - n + 1;
            
            for (i = 0; i < N; i++)
            {  j = 0;
            while (j < n && sub.charAt(j) === str.charAt(i+j)) j++;
            if (j === n) return i;
            }                                // На выходе индекс 1-го символа подстроки.
                                            // Если искомой подстроки нет в строке, то -1.
            return -1;                       // Например,
        }                                    // SubstringSearch('ips', 'Lorem ipsum') = 6,
                                            // SubstringSearch('dolor', 'Lorem ipsum') = -1.


}

{/*  229    ====    ПЕРЕДАЧА ДАННЫХ по ССЫЛКЕ или по ЗНАЧЕНИЮ, Spread оператор (ES6-ES9)

    Многие новички делают ошибки не различая передачу данных по ссылке и по значению. 
    


    ПЕРЕДАЧА ДАННЫХ

    Рассмотрим пример, создаем переменную а и в нее помещаем 5, создадим переменную b и в нее 
    поместим значение а. Далее к значению b приплюсуем 5 и ожидаем что в b у нас окажется 10. */

        let a = 5,  
            b = a;          // присваивается значение 5

        b = b + 5;

        console.log(b);     // 10 - как мы и ожидали.
        console.log(a);     // 5 - а при этом не изменяется


    /* Теперь создадим переменную obj с объектом и поместим ее в переменную copy. Потом в переменной 
    copy изменим значение свойства а на 10 и проверим что случилось с нашими объектами. */

        const obj = {
            a: 5,
            b: 1
        };

        const copy = obj;   // присваивается ссылка на объект в переменной obj
        copy.a = 10;

        console.log(copy);  // { a: 10, b: 1 }
        console.log(obj);   // { a: 10, b: 1 }

        /* Значение свойства а изменилось и в переменной obj, так получилось потому что const copy = obj; 
        сработало не так как мы расчитывали. Так получается потому что объект был передан по ссылке. 

    При работе с примитивами (строки, числа, лог. значения) - они передаются по значению(значение 
    копируется). Когда же мы работаем с объектами к которым относятся: массивы, функции и 
    спец.объекты(Объекты даты), передача идет не по значению а по ссылке, тоесть объект не копируется 
    в новую переменную, а туда заносится ссылка на первоначальные объект, и если мы обратимся к такой
    переменной она будет через ссылку работать с первоначальным объектом.


    ! Чтобы СКОПИРОВАТЬ(клонировать) объект существуют разные способы. Существуют поверхностные и 
    ! глубокие копии, далее в курсе будем рассматривать глубокое копирование, а пока рассмотрим 
    ! поверхностное копирование.


    ! ЦИКЛ. 
    Создадим ф-ю которая аргументом будет принимать копируемый объект mainObj. Внутри создадим
    переменную для нового объекта objCopy и через перебор for in переберем свойства текущего объекта. 
    При этом видим что переменную key можно создать вне цикла for in. В цикле создаем новое свойство 
    у нового объекта objCopy[key] - с таким же именем как у копируемого обекта key и в его значение 
    присваиваем значение этого же свойства из копирумого объекта  objCopy[key] = mainObj[key]; После 
    завершения копирования нужно вернуть новый скопированный объект наружу через  return objCopy;*/
    
        function copy(mainObj) {
            let objCopy = {};

            let key;
            for (key in mainObj) {
                objCopy[key] = mainObj[key];
            }
            return objCopy;
        }


    // Создадим объект вместе со вложенным объектом что бы проверить как отработает наша ф-я

        const numbers = {
            a: 2,
            b: 5,
            c: {
                x: 7,
                y: 4
            },
            func: function(){
                console.log('hey');
            }
        };
    
        const newNumbers = copy(numbers); //Пробуем скопировать в переменную newNumbers
        console.log(newNumbers);        // {a: 2, b: 5, c: {x: 7, y: 4}, func: ƒ} - * метод работает
        
        newNumbers.a = 10;
        console.log(newNumbers);    // {a: 10, b: 5, c: {x: 7, y: 4}, func: ƒ}
        console.log(numbers);       // {a: 2, b: 5, c: {x: 7, y: 4}, func: ƒ}
        // При изменении свойства newNumbers видим что первоначальный объект остался не тронутым
        // Таким образом мы клонировали(скопировали) объект numbers в новый newNumbers. 
        
        // Но если мы изменим свойство х
        newNumbers.с.x = 10;
        console.log(newNumbers);    // {a: 10, b: 5, c: {x: 10, y: 4}, func: ƒ}
        console.log(numbers);       // {a: 2, b: 5, c: {x: 10, y: 4}, func: ƒ}

        // видим что это свойство изменилось у обоих объектов.

    /* При таком способе клонирования мы сделали ПОВЕРХНОСТНУЮ копию объекта, тоесть все элементы на
    первом уровне скопируются правильно, но если есть вложенный объект или массив или ф-я, его 
    значение все равно передается по ссылке и ведет к первоначальному объекту.


    ! Object.assign 
    У глобального типа Object, есть метод assign. Этот метод позволяет соединять несколько объектов.
    Соединим объект numbers c объектом add. Первым аргументом передаем тот объект в который мы хотим 
    поместить второй, второй аргумент - тот объект который мы помещаем. */
        
        const add = {
            d: 17,
            e: 20
        };

        const numbers = {
            a: 2,
            b: 5,
            c: {
                x: 7,
                y: 4
            }
        };
        
        console.log(Object.assign(numbers, add)); // {a: 2, b: 5, c: {x: 7, y: 4}, d: 17, e: 20}

        /* Таким образом у нас сформировалась независимый объект ни от numbers(не считая вложенного 
        объекта) ни от add, и если мы присвоим его какой то переменной то сможем с ним работать независимо. 
        Тоже самое можно сделать с пустым объектом что бы просто создать ПОВЕРХНОСТНУЮ копию объекта.*/

        const clone = Object.assign({}, add);


    
    /* КОПИЯ МАССИВА.

    ! slice
    Копию массива можно сделать также через цикл, но есть еще специальный метод slice. 
    Массив скопируется поверхностно, тоесть если копировать такой массив
    const oldArr = ['a', ['b', 'j'], 'c']; 
    и его элемент с индексом 1 полностью заменить на новое значение newArr[1] = 'yoyoyo'; то получим 
    изменения только в новом массиве ["a", "yoyoyo", "c"], а в старом значения останутся прежними, 
    но если попробовать изменить значение одного элемента вложенного массива newArr[1][1] = 'yoyoyo';
    тогда изменения окажутся и в старом массиве ["a", ["b", "yoyoyo"], "c"]. */

        const oldArr = ['a', 'b', 'c'];
        const newArr = oldArr;        // передастся ссылка
        const newArr = oldArr.slice();  // скопирует массив (поверхностно!)

        newArr[1] = 'yoyoyo';
        console.log(newArr);    // ["a", "yoyoyo", "c"]
        console.log(oldArr);    // ["a", "b", "c"]

    

    /* НОВЫЕ МЕТОДЫ ES6 и ES9
        
    SPREAD
    Оператор разворота. В ES6 он появился для массивов, а в ES9 уже и для объектов. Он разворачивает 
    структуру и превращает ее в набор данных. Можно использовать для поверхностного клонирования массива */

        const arr = ['a', 'b'];
        const newArr = [...arr];


    /* Создаем три переменных. В двух лежат массивы с данными, а в третий нам нужно поместить данные из 
    первых двух. Можно сделать это через цикл, или посмотреть методы для массивов может там есть метод для
    этой задачи, но самый простым способом соединить два массива в новом будет использовать спрэд 
    оператор(...) что бы он развернул заданные массивы на элементы в новом массиве, при этом можно еще
    добавть свои данные. */

        const video = ['youtube', 'vimeo', 'rutube'],
              blogs = ['wordpress', 'Livejournal', 'blogger'],
              internet = [...video, ...blogs, 'vk', 'facebook'];

        console.log(internet);  
        // ["youtube", "vimeo", "rutube", "wordpress", "Livejournal", "blogger", "vk", "facebook"]


    /* Рассмотрим пример посложнее. Ф-я принимает 3 аргумента и выводит их в консоль. Массив num содержит 
    числа, но вместо них нам могли с сервера прийти данные о видео 1 - сылка на видео, 2 - ссылка на 
    заглушку, 3 - ссылка например на автора и эти данные нам нужно передать в ф-ю log. Но ф-я принимает 
    отдельные аргументы. а не массив. Тут нам помогает спред оператор, он развернет массив в скобках при 
    запуске ф-и. */

        function log (a, b, c) {
            console.log(a);
            console.log(b);
            console.log(c);
        }
        
        const num = [2, 5, 7];

        log(...num); // 2 5 7


    // Клонироване объекта методом spread оператора

        const obj = {
            one: 1,
            two: 2
        }

        const newObj = {...obj};
        console.log(newObj);

        
}

{/*  230    ====    ОСНОВЫ ООП, прототипно-ориентированное наследование    ====
    
    Когда-то программы состояли просто из набора ф-й, которые вызывали друг друга в нужный момент, в таком
    функциональном подходе много недостатков и программисты стремились усовершенствовать свои техники.
    Так появились: истинно ф-й подход, объектно ориентированный подход, процедурный и другие.
    JS - объектно ориентированный язык и главную роль в нем играет объект, он может содержать в 
    себе свойства, методы и любой тип данных, представляя из себя целостную сущность.

    Прототипно-ориентированное программирование это стиль объектно ориентированного программирования(ООП). 
    Смысл ООП заключается в том что мы представляем любую вещь как объект с набором свойств и методов.


    Если мы работаем со строкой то можно увидеть что у нее есть свойство - длинна строки(length) и методы 
    для изменения ее регистра, модификации, и т.д. и можно подумать что это уже целый объект. Но если 
    строка написана в таком виде "Some string" - это обычный примитив(простой тип данных). Но когда мы 
    вызываем у нее свойство или какой-то метод JS оборачивает ее в объект и после модификации возвращает 
    строку на место.

    ПРИМЕР
        Создадим строку разными способами и посмотрим их тип */
        let str = "some";               // обычный способ
        let strObj = new String(str);   // способ через new (конструктор) помещаем нашу первоначальную
                                        // строку в конструкцию

        console.log(typeof(str));       // string
        console.log(typeof(strObj));    // object
        
        /* Примерно так происходит создание строки из нашей первоначальной строки когда мы вызываем 
        свойство или метод на обычной строке. Примитив оборачивается в объект используется какой то метод 
        который есть у этого объекта и далее из объекта снова превращается в примитив


    Откуда же JS знает как это делать. Представим легковое авто, они все разные: разных марок, количества 
    мест, цветов но они все построены по одному прототипу. От этого прототипа и отпочковался каждый новый
    экземпляр. У них могут быть разные двигатели, диаметр колес, форма кузова, но все эти свойства есть у 
    каждого легкового автомобиля, это и есть применение ООП и прототипно ориентированного программирования
    в реальной жизни.


    Когда мы создаем строки или массивы они будут совершенно разными по наполнению, но каждый из них 
    обладает одними и теми же методами которые можно использовать на любом экземпляре. Когда мы создаем
    массив мы создаем новый экземпляр прототипа массивов */

        console.dir([1, 2, 3]); 
        
        /* получаем экземпляр массива в котором если его раскрыть можно увидеть свойство _proto_
        Array(3)0: 1 1: 2 2: 3 length: 3 __proto__: Array(0) - а в нем и лежит прототим массива Array
        благодаря которому мы и можем создавать свои массивы. Если раскрыть его можно увидеть все
        методы которые применимы к массивам и в конце мы снова обнаружиаем свойство _proto_ которое
        ссылается на объект __proto__: Object. 
            

    ! Тоесть все методы и свойства которые мы можем использовать на массиве приходят через _proto_ из
    ! прототипа массива Array.prototype, а которых в Array нету (например toString) приходят через _proto_
    ! из Object.prototype. Такая же ситуация и с функциями и с числами - к их прототипам недостающие методы
    ! или свойства также приходят из главного прототипа Object.
        

        
    В реальных проектах мы сами будем создавать такие прототипы что бы от них создавать другие объекты. 
    Например, модального окна у которого по умолчанию будут свойства - ширина, высота, и базовые ф-ции. От
    него мы сможем создавать много других модальных окон которые будут отличаться по какой то
    характеристике(свойству) */

        const soldier = {   // Создаем прототип солдата
            health: 400,
            armor: 100
        };

        const john = {      // Создадим конкретного солдата джона у которого мало здоровья
            health: 200
        }


    /* Теперь установим связь. чтобы Джон умел делать все тоже что и солдат и свойства которых у него
    не достает добавились, но личные свойства что бы остались своими health: 200, сделать это можно
    несколькими способами.


    ! УСТАРЕВШИЙ формат
    потому что он может встречаться в коде и нужно знать как с ним работать, но в новых проектах уже 
    НЕ стоит его использовать. */

        john.__proto__ = soldier;
        console.log(john);          // {health: 200} - видим единственное свойство 
        console.log(john.armor);    // 100 - но если обратимся к свойству  armor, то оно у него будет
                                    // благодаря прототипу который мы только что указали.


    //! Object.create
    /* Сейчас вместо __proto__ нужно использовать 

    Object.create()          - создает объект с определенным прототипом
    Object.getPrototypeOf () - получает прототип
    Object.setPrototypeOf () - устанавливает(назначить) прототип */


    // Так назначаем уже существующему объекту john прототип soldier, если объект john уже существует

        Object.setPrototypeOf (john, soldier); // современная запись john.__proto__ = soldier;


    // Так создаем объект john который будет прототипно наследоваться от soldier в момент создания

        const john = Object.create(soldier);    // Создаем новый объект john с прототипным наследованием 
                                                // от soldier 

        john.health = 200                       // устанавливаем личное свойство health для john 

        console.log(john);


}

{/*  231    ====    ПРАКТИКА 4. Используем объекты    ====

    Сделаем РЕФАКТОРИНГ кода - переписывание кода под новые услови и новые задачи.


    ЗАДАНИЕ
    1)  Нужно переписать наше приложение состоящее из ф-й так, чтобы все ф-ии стали методами объекта 
        personalMovieDB. Такое случается в реальных продуктах при смене технологий или подхода к 
        аритектуре программы.

    2) Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false
        он будет переключать его в true, и наоборот. Протестировать вместе с showMyDB.

    3) В методе writeYourGenres запретить поользователю нажать кнопку "отмена" или оставлять пустую строку. 
        Если он это сделал возвращать его к вопросу заново. После того как все жанры введены - при помощи
        метода forEach вывести в консоль сообщение в таком виде "Любимый жанр #(номер по порядку начиная
        с 1) - это (название из массива)"
    */



    //  +++ РЕШЕНИЕ

    {"use strict";
    /* При переносе ф-и start в объект нужда в переменной numberOfFilms отпадает. Мы установим для 
    свойства count значение равное 0, а в ф-и вместо переменной numberOfFilms пропишем путь к count куда
    и будет присваиваться результат personalMovieDB.count  */

    const personalMovieDB = {
        count: 0,
        movies: {},
        actors: {},
        genres: [],
        privat: false,
        start: function () {
            personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
        
            while (personalMovieDB.count == '' || personalMovieDB.count == null || isNaN(personalMovieDB.count)){
                personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
            }
        },
        rememberMyFilms: function() {
            for (let i = 0; i < 2; i++) {
                const movieName = prompt(`Один из последних просмотренных фильмов? ${i}`, ''),
                    movieRank = prompt('На сколько его оцените?', '');
                
                if(movieName != null && movieRank != null && movieName != '' && movieRank != '' && movieName.length < 50) {
                    personalMovieDB.movies[movieName] = movieRank;
                    console.log('Done');
                }else{
                    console.log('Enter valid data');
                    i--;
                }
            }
        },
        detectPersonalLevel: function (){
            if (personalMovieDB.count < 10){
                console.log("Просмотрено довольно мало фильмов");
            }else if(personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
                console.log("Вы классический зритель");
            }else if(personalMovieDB.count >= 30) {
                console.log("Вы киноман");
            }else {
                console.log("Произошла ошибка");
            }
        },
        showMyDB: function (hidden){
            if (!hidden){
                console.log(personalMovieDB);
                } else {
                console.log('This is a privat object.');
            }
        },
        // Так как цикл у нас уже есть, нам осталось добавить условие. Добавим переменную для хранения
        // ответа - genre, чтобы подставлять в условие.
        writeYourGenres: function (){
            for(let i = 1; i <= 3; i++){
                let genre = prompt(`Ваш любимый жанр под номером ${i}?`);
                            
                if (genre == '' || genre == null){
                    console.log("Вы ввели некорректные данные или не ввыели их вовсе.")
                    i--;
                } else {
                    personalMovieDB.genres[i-1] = genre;
                };

                personalMovieDB.genres.forEach((item, i) => {
                    console.log(`Любимый жанр №${i + 1} - это ${item}`);
                });
            }
        },
        toggleVisibleMyDB: function() {
            if (personalMovieDB.privat) {
                personalMovieDB.privat = false;
            } else {
                personalMovieDB.privat = true ;
            };
        }

    };

    //! Альтернативный вариант
    /* Реализуем метод writeYourGenres с использованием другого подхода. Изменим вопрос, теперь ожидаем 
    одну строку с ответами через запятую чтобы потом разделить через split и создать из нее массив. 
    Значит вопрос будет задан 1 раз, и нам не нужно 3 итерации, изменим i <= 3 на i < 2
    и передадим в genres - массив полученный из строки ответа пользователя через метод split с 
    разделителем (", "). Потом отсортируем массив по алфавиту.

    ! При сортировке массива, отдается предпочтение словам начинающимся с большой буквы, тоесть Боб будет
    первее чем аня, поэтому при сортировке стоит приводить все слова к одному регистру, допишем к
    полученному ответу .toLowerCase(); */
        
    function writeYourGenres (){
        for(let i = 1; i < 2; i++){
            let genres = prompt(`Введите ваши любимые жанры через запятую.`).toLowerCase();
            
            if (genres == '' || genres == null){
                console.log("Вы ввели некорректные данные или не ввели их вовсе.")
                i--;
            } else {
                personalMovieDB.genres = genres.split(", ");
                personalMovieDB.genres.sort();
            };
            
            personalMovieDB.genres.forEach((item, i) => {
                console.log(`Любимый жанр №${i + 1} - это ${item}`);
            });
        }
    };

    writeYourGenres();
    console.log(personalMovieDB);
    }

    {//Мое решение - убрал трим потому что с ним были проблемы, переписал условие в detectPersonalLevel
     // потому что не правильно срабатывало

        const personalMovieDB = {
        count: 0,
        movies: {},
        actors: {},
        genres: [],
        privat: false,
        start: function () {
                this.count = +prompt('Сколько фильмов вы уже посмотрели?', '');

                while (this.count == '' || this.count == null || isNaN(this.count)) {
                    this.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
                }
            },
        detectPersonalLevel: function () {
                if (personalMovieDB.count < 10) {
                    console.log("Просмотрено довольно мало фильмов")
                } else if (personalMovieDB.count > 30) {
                    console.log("Вы киноман")
                } else if (10 <= personalMovieDB.count && personalMovieDB.count <= 30) {
                    console.log("Вы классический зритель")
                } else {
                    console.log("Произошла ошибка");
                }
            },
        rememberMyFilms: function () {
                for (i = 0; i < 2; i++) {
                    const f = (prompt('Один из последних просмотренных фильмов ?', ''))
                    const r = +prompt('На сколько его оцените (ответ числом)?', '')

                    if (!!f && !!r && f.length < 20) {
                        personalMovieDB.movies[f] = r
                        console.log('Done')
                    } else {
                        i--
                        console.log('Error. Enter valid data')
                    }
                }
            },
        showMyDB: function () {
                if (!personalMovieDB.privat) {
                    console.log(personalMovieDB)
                }
            },
        writeYourGenres: function () {
                let favMovie
                for (i = 1; i <= 3; i++) {
                    favMovie = prompt(`Ваш любимый жанр под номером ${i}?`) 
                    if (favMovie == '' || favMovie == null) {
                        console.log('You enter invalid data or not enter it at all')
                        i--
                    } else {
                        personalMovieDB.genres[i - 1] = favMovie
                    }
                }

                this.genres.forEach((el, ind, genres) => {
                    console.log(`Любимый жанр #${ind+1} - это ${el}`)
                });
                 
            },
        toggleVisibleMyDB: function () {
                this.privat = !this.privat
            }
        }

        personalMovieDB.start()
        // personalMovieDB.toggleVisibleMyDB()
        personalMovieDB.detectPersonalLevel()
        personalMovieDB.rememberMyFilms()
        personalMovieDB.writeYourGenres()
        personalMovieDB.showMyDB()
    }


}

{/*  232    ====    ОТЛАВЛИВАЕМ ОШИБКИ при помощи КОНСОЛИ разработчика. Breakpoints    ====

    //! Вкладки консоли
    Elements
        ХТМЛ структура + стили которые применяются к каждому отдельному тегу. Тут можно посмотреть 
        псевдоклассы, псевдоселекторы

    Sources
        Вкладка со всем исходными материалами которые нам доступны в проекте который сейчас открыт.

    Network
        Отвечает за работу с сетью. Тут мы можем как быстро происходит загрузка скриптов, картинок, хтмл 
        структуры. Но самое главное тут можно отслеживать запросы которые будут уходить на сайт.
    
    Perfomance
        тут можно увидеть как работает(загружается) какая то структура.

    Memory
        Сколько потребляет памяти наш сайт

    Application
        Можно увидеть подключенные апликухи(приложения). С Local storage мы еще будем работать. */
    
    

    // Будем тренироваться на данном коде
        "use strict";

        function hello () {
            console.log("Hello World");
        }

        hello();

        function hi () {
            console.log("Say hi");
        }

        hi();

        const arr = [1, 14, 4, 30, 54],
            sorted = arr.sort(compareNum);

        function compareNum (a, b) {
            return a - b;
        }

        console.log(sorted);

        // в консоль будет выведено это 
        // Hello World
        // Say hi
        // (5) [1, 4, 14, 30, 54]


    /* //! Консоль рассматриваем в Гугл хром, в Эдж вкладки отличаются на русском языке.

    Посмотрим как дебажить наш код, как получить промежуточные результаты которые возникают на том или 
    ином шаге выполнения нашей программы. Обратимся к Sources, тут мы можем устанавливать 
    breakpoint(брейкпоинт - точка остановки), это такая метка которая позволяет останавливать код в 
    определенном участке.

    В окне  слева выберем наш файл с кодом(скриптами JS) видим код, и кликаем на номер строки где хотим 
    установить брейкпоинт 7 hello(); и 13 hi();. 

    Теперь перезапускаем страницу и получаем сообщение что наш сайт остановлен в дебаггере. Сообщения может
    и не быть, но в панели справа от кода будет эта надпись. В console никаких значений еще не будет. 
    

    Посмотрим на кнопки над правой панелью. 

        1 - переходит на следующий брейкпоинт

        2 - показывает вызывающиеся ф-ии или объявление переменных.

        3 - точки где происходит изменение данных (заходит внутрь ф-й). Если поставить брейкпоинт в 
            compareNum на саму сортировку return a - b; можно увидеть значения ф-ии в каждой 
            итеррации(какие элементы сравниваются и что возвращает return), также тут видно что код 
            выполняется справа - на лево. 

        4 - выход из ф-и. Аналогична предыдущей ф-ции, но если предыдущая return a - b; выполняла в 2 
            действия, сначала сравнивала числа, потом выполняла return, то эта кнопка делает эту комманду 
            за 1 действие, тоесть если много раз сравниваются данные или происходит какое то действие, 
            этой кнопкой проклацать ф-ю будет быстрее.

        5 - стрелочка "Шаг вперед", проходит выполнение кода пошагово в последовательности выполнения.

        6 - деактивировать брейкпоинты, тоесть они остаются, что бы мы их не ставили заново, но программу 
            не останавливают


    Вкладки Sources под кнопками справа (зайдем в ф-ю hello третьей кнопкой, так что бы выбралась 4я 
    строчка)

        watch - позволяет следить за определенными выражениями

        call stack - (стек вызовов) последовательность операций которая привела к данной строчке
            ( по простому это как код пришел к данной строчке ), строчка 4 выделенная в окне  hello - 4 стр,
            (anonymus) - 7 стр. Тоесть код на 4й строке был вызван с 7й.

        scope - (область) переменные с которыми мы работаем в этой строке. Тут переменные разделены на local
            и global. Их тут мало перейдем на 19 строку return a - b; для примера. Теперь видим что 
            в call stack  что 19 строка была запущена из 16й sorted = arr.sort(compareNum). А в scope видим
            Local a:14 b:1 this:undefined, также через шаг в этом меню видно что возвращает return. Global 
            свернуто и добавилась вкладка Script в которой находится наш массив над которым выполняются 
            действия.

        breakpoints - показывает в каких строках установленны брейкпоинты

        XHR/fetch Breakpoints - брейпоинты для обращений к серверу

        Dom Breakpoints - рбота с элементами на странице

        Event listener/Global listenet - работа с обработчиками событий.


    ! Поставить брейкпоинт можно и в самом коде написав ключ. слово debugger; - тогда код остановится на
     этой точке как будто мы ее ставили из консоли разработчика. */


}

{/*  233    ====    ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ    ====

    Повторим типы данных
        ПРОСТЫЕ: числа, строки, логические(булиновые), null, undefined, Symbol, BigInt
        ОБЪЕКТЫ: обычные объекты,
                 специальные объекты: массивы, функции, объект Даты, регулярные выражения, ошибки.


    ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ - возможность одного типа данных превращаться в другой. Тоесть число может стать
        строкой, строка числом, а объект - булиновым значением. В других языках статическая типизация,
        когда число всегда остается числом.



    //! ПРИМЕРЫ

    TO STRING (как можно превратить в строку)

        //! String - самый старый и редкоиспользуемый способ(потому что не очень удобный) */

            console.log(String(null));          // "null" - взяло в кавычки само слово
            console.log(typeof(String(null)));  // string

            console.log(String(4));          // "4" - взяло в кавычки число
            console.log(typeof(String(4)));  // string


        //! Конкатенация - при сложении любого типа со строкой получаетсяя строка

            console.log(4 + '');            // "4" - сложили с пустой строкой
            console.log(typeof(4 + ''));    // string

            console.log(undefined + '');            // undefined
            console.log(typeof(undefined + ''));    // string


        /* Создадим реальный пример, с УСТАРЕВШИМ (потому что есть новый - ИНТЕРПОЛЯЦИЯ) методом 
        конкатенации такой код еще встречается например у нас есть путь и нам нужно динамически 
        сформировать путь на 5ю категорию для перехода в нее */

            const num = 5;
            console.log("https://facebook.com/catalog/" + num); 
            
            /* тут динамически формируется строка адресса куда уже можно перейти

        Также часто нужно изменять стили ксс при помощи JS и для этого нужно передавать их в виде строки. 
        Нам приходит в переменную fontSize число 26(новый размер) и теперь нам нужно его передать в стиль,
        в строке потому что нужно указать что это будут пиксели или % или еще что то. */

            const fontSize = 26 + 'px';



    // NUMBER (как можно превратить в число)

        //! Number - самый старый и редкоиспользуемый способ(потому что не очень удобный) 

            console.log(Number('4'));          // 4
            console.log(typeof(Number('4')));  // number


        //! "+" - унарный плюс - наиболее часто используемый

            console.log(+'4');          // 4
            console.log(typeof(+'4'));  // number


        //! parseInt (*2й аргумент - 10(десятичная система)) - неочевидное применение данного метода
        
            console.log(parseInt('15px', 10));          // 15 
            console.log(typeof(parseInt('15px', 10)));  // number


        // Пример нужно получить из поля ввода пользователя именно числовой тип данных

            let answer = +prompt("Сколько вам лет?", "");

        /* Мы не можем таким образом запретить пользователю ввести буквы, но если он введет нужные значения
        они будут преобразованы в число. А что бы совсем убрать у него возможность ввести не число, нужно
        использовать регулярное выражение, с ним познакомимся дальше в курсе. */


    //! Все данные которые получаем от пользователя имеют тип СТРОКА (значение из prompt, input, 
    //! textarea, и т.д.)


    /* TO BOOLEAN (как можно превратить в булиновый тип)

    Если перед нами пустота(null) или ничего - всегда будет ложь(false);
    Эти типы и значения ВСЕГДА превращаются в false:
        0(ноль), ''(ПУСТАЯ строка, " "- это строка с пробелом, уже не пустая), null, undefined, NaN
    
    Всё остальное будет превращаться true:
        строки, пустые массивы, пустые объекты, и т.д.


        ! Нативный
        Преобразование в условии. Пример переменная switcher(переключатель) содержит начальное значение null,
        так часто указывают что бы потом присвоить другое значение по мере выполнения программы. */

            let switcher = null;        

            if(switcher) {      // преобразуется в (false) - условие не выполнится и код не сработает
                console.log(" Something working");
            }

            switcher = 1;       // происходит смена значения переменной в процессе выполнения программы

            // Какая то ф-я снова запускает проверку
            if(switcher) {      // теперь 1 будет - true - условие  выполнится и код сработает
                console.log(" Something working");
            }

        /* Такойже подход используют и для элементов на странице. Пока у нас какого то элемента не 
        существует, вместо него будет null, программа работает и периодически происходит проверка условия.
        И в какой то момент элемент появляется на странице при этом в switcher помещается новый элемент 
        который присутствует на странице, снова проверится условие, увидит что элемент появился и начнет 
        выполнять какие-то действия. */


        //! Boolean - редкоиспользуемый способ

            console.log(Boolean('4'));          // true
            console.log(typeof(Boolean('4')));  // boolean

        //! !! - два знака отрицания

            console.log(!!"444");               // true
            console.log(typeof(!!"444"));       // boolean


}

{/*  234    ====    Замыкание И Лексическое Окружение    ====

    JS довольно гибкий язык - можно в любой момент создавать переменные, ф-и, вложенные ф-и, передавать их
    как аргументы и многое другое. Чтобы мы и браузер не запутался в таком коде необходим механизм 
    контроля.


    ПРИМЕР */

        let number = 5

        function logNumber () {
            console.log(number)
        }

        number = 6

        logNumber()

    /* Что выведет консоль? 
    
    Код пойдет по порядку, сначала создаст переменную number которая изначально undefined, потом в нее 
    присвоит 5. 
    
    Далее натыкается на ф-ю logNumber у которого значение будет тоже undefined - потому что при первом 
    проходе браузера из-за того что ф-я создана через function declaration, тоесть ф-я уже существует и 
    можно было даже вызвать ее выше до е объявления. А теперь при втором проходе браузера идет собственно
    объявление содержимого ф-и и она запоминает что она должна делать - консоль лог идет с сылкой на number,
    а так как аргумента в саму ф-ю logNumber не передается то number нужно гдето взять.

    Далее в number записывается значение 6

    Дальше идет запуск ф-и logNumber, при этом она обращается к какому то number и выводит его в консоль.

    Получаем 6 потому что выводится актуальное значение number, так как в момент объявления содержимого
    ф-и в консоль логе запомнилась именно ссылка на переменную, а не на ее значение(которое в этот момент
    равнялось - 5) и при вызове ф-ии она посмотрела на number увидела там новое значение и вывела его в 
    консоль



    ! ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ (lexical environment)

    В JS у каждой выполняемой ф-и, блока кода, скрипта есть связанный с ними внутренний(скрытый от нас)
    объект - лексическое окружение. Оно делится на внутренее и на внешнее.

    Модифицируем код, что теперь будет выведено. Ответ 4  */

        let number = 5; debugger

        function logNumber () {
            let number = 4; debugger
            console.log(number)
        }

        number = 6

        logNumber(); debugger

        /* Пропишем debugger в нескольких местах и разберемся почему так происходит. Потому что теперь в 
        ф-и появилась своя внутреннея переменная, ф-я ее нашла и использовала. А если бы локальная не
        нашлась, сработалобы замыкание и ф-я начала искать переменную в более глобальной области видимости,
        тоесть на уровень выше.

        Запустим код в браузере и посмотрим на Scope справа в вкладке Sources. Видим код остановился на 
        первом дебагере и в скоупе видно number: 5 - в вкладке Script(автор запускал файл с кодом) и также
        глобальный объект Window его пока не рассматриваем.

        Проклациваем код второй кнопкой со стрелочкой над точкой, чтобы переместиться дальше по коду,
        перескочили на присвоение number = 6, клацаем снова и теперь находимся на строке с запуском ф-и.
        В Scope теперь видно что number поменялся на 6.

        Теперь нажимаем 3ю кнопку чтобы войти в ф-ю. Scope поменялся, теперь появились локальные переменные
        this: undefined и number: undefined - потому что переменная только объявлена, далее в нее поместится
        4ка. Ф-я при этом имеет доступ к обоим number и локальному и скриптовому. 


    Теперь можно дать определение разделению лексического окружения на 2 части:

        1) Внутреннее лексическое окружение (environment record) - объект в котором как свойства хранятся
        все локальные переменные этой ф-и и другая инфа, такая как значение this. В нем есть ссылка на 
        внешнее лексическое окружение, для того чтобы искать переменные которые ф-я не нашла в локальном
        (внутреннем окружении). //! Ф-я ВСЕГДА получает текущее значение глобальных переменных, тоесть
        ! актуальное на момент вызова ф-и, старые значения переменных нигде не сохраняются.

        2) Внешнее лексическое окружение - то которое соответствует коду снаружи этой ф-ии, тоже объект.


    ! В момент когда ф-я после запуска отработала(завершила свою работу) её лексическое окружение 
    ! удаляется за ненадобностью.

    ! Каждый вызов ф-и это создание нового лексического окружения со своими специфическими для этого вызова
    ! локальными  переменными и параметрами


    Самое сложное начинается при комбинации ф-й, когда идет возврат из ф-и другой ф-и. Самый частый пример
    со счетчиками, его дают на собеседованиях.  */

        function createCounter() {
            let counter = 0

            const myFunction = function() {; debugger
                counter = counter + 1; debugger
                return counter; debugger
            }

            return myFunction
        }
        debugger
        const increment = createCounter(); debugger
        const c1 = increment(); debugger
        const c2 = increment(); debugger
        const c3 = increment(); debugger

        console.log(c1, c2, c3)

        /* При создании increment в него поместится возвращенное значение ф-и createCounter, а именно 
        другая ф-я - myFunction, таким образом increment получается ф-ей и теперь его можно использовать.
        
        Создадим три переменных и в них положим запуск ф-и increment. В консоль выведется 1 2 3

        Рассмотрим как работает этот код.
        При создании increment запускается createCounter() в нем создается counter = 0 и происходит 
        объявление(создание) ф-и myFunction которая положится в переменную myFunction, при этом в локальное
        окружение myFunction уже записалась ссылка на counter со значением 0. далее return возвращает 
        ф-ю myFunction с этими созданными объектами и она присваивается переменной increment.

        Далее создается с1 и запускается increment() и так как по сути это myFunction, происходит запуск
        myFunction() и из-за того myFunction была присвоена increment, тоесть инкремент как бы хранит в 
        себе ссылку на нее, а в себе myFunction хранит ссылку на counter то всё это лексическое окружение
        не было удалено чтобы была возможность выполнять ф-ю increment. 
        
        В момент запуска increment() видим что в Scope появилось новое свойство Closure (замыкание) в 
        котором и хранится ссылка на counter который равен 0. Происходит его увеличение и возвращение 
        значения.

        Далее запускается с2 и снова идет запуск increment() из него запускается myFunction() в которой
        все еще хранится ссылка на counter который теперь уже 1. 


        ! Как ф-я знает что помещать в лексич. окружение. Ф-я использует скрытое свойство environment которое
        ! ссылается на лексическое окружение места(в коде) где эта ф-я была создана. Тоесть когда myFunction
        ! была создана, она получила ссылку на лексическое окружение места где была создана, тоесть на
        ! createCounter поэтому лекс. окруж. createCounter не было удалено.  Если myFunction не присваивать
        ! переменной, а написать просто - function myFunction() {; код работает также. */


    //todo прочитать статьи  http://jsflow.org/docs/js-engines/ и https://learn.javascript.ru/function-object
        
    {/* Объяснение из learn.javascript
        
    //!Возврат функции
        Давайте вернёмся к примеру с makeCounter: */

            function makeCounter() {
                let count = 0;

                return function() {
                    return count++;
                };
            }

            let counter = makeCounter();

            alert( counter() ); // 0
            alert( counter() ); // 1
            alert( counter() ); // 2

        /* //! В начале каждого вызова makeCounter() создается новый объект лексического окружения, в 
        ! котором хранятся переменные для конкретного запуска makeCounter.

        Таким образом, мы имеем два вложенных лексических окружения

        Во время выполнения makeCounter() создается крошечная вложенная функция, состоящая всего из одной
        строки: return count++. Мы ее еще не запускаем, а только создаем.

        !Все функции помнят лексическое окружение, в котором они были созданы. 
        Технически здесь нет никакой магии: все функции имеют скрытое свойство [[Environment]], которое
        хранит ссылку на лексическое  окружение, в котором была создана функция:

        Таким образом, counter.[[Environment]] имеет ссылку на {count: 0} лексического окружения. Так
        функция запоминает, где она была создана, независимо от того, где она вызывается. 
        ! Ссылка на [[Environment]] устанавливается один раз и навсегда при создании функции.

        ! Впоследствии, при вызове counter(), для этого вызова создается новое лексическое окружение, а его
        ! внешняя ссылка на лексическое окружение берется из counter.[[Environment]]:

        Теперь, когда код внутри counter() ищет переменную count, он сначала ищет ее в собственном 
        лексическом окружении (пустом, так как там нет локальных переменных), а затем в лексическом 
        окружении внешнего вызова makeCounter(), где находит count и изменяет ее.

        Переменная обновляется в том лексическом окружении, в котором она существует.

        Если мы вызовем counter() несколько раз, то в одном и том же месте переменная count будет 
        увеличена до 2, 3 и т.д.


    !Замыкания
        В программировании есть общий термин: «замыкание», – который должен знать каждый разработчик.

        Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
        В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы 
        получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются 
        замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

        То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], 
        и все они могут получить доступ к внешним переменным.

        Когда на собеседовании фронтенд-разработчику задают вопрос: «что такое замыкание?», – правильным 
        ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются 
        замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, 
        как работает лексическое окружение.



    !Сборка мусора
        ! Обычно лексическое окружение удаляется из памяти вместе со всеми переменными после завершения 
        ! вызова функции. Это связано с тем, что на него нет ссылок. Как и любой объект JavaScript, оно 
        ! хранится в  памяти только до тех пор, пока к нему можно обратиться.

        ! Однако если существует вложенная функция, которая все еще доступна после завершения функции, то 
        ! она имеет свойство [[Environment]], ссылающееся на лексическое окружение.

        ! В этом случае лексическое окружение остается доступным даже после завершения работы функции

        Например: */

            function f() {
                let value = 123;

                return function() {
                    alert(value);
                }
            }

            let g = f();    // g.[[Environment]] хранит ссылку на лексическое окружение
                            // из соответствующего вызова f()

        /* Обратите внимание, что если f() вызывается много раз и результирующие функции сохраняются, 
        то все соответствующие объекты лексического окружения также будут сохранены в памяти. 
        В приведенном ниже коде – все три: */

            function f() {
                let value = Math.random();

                return function() { alert(value); };
            }

            // 3 функции в массиве, каждая из которых ссылается на лексическое окружение
            // из соответствующего вызова f()
            let arr = [f(), f(), f()];

        /* Объект лексического окружения исчезает, когда становится недоступным (как и любой другой объект).
        Другими словами, он существует только до тех пор, пока на него ссылается хотя бы одна вложенная 
        функция.

        В приведенном ниже коде после удаления вложенной функции ее окружающее лексическое окружение 
        (а значит, и value) очищается из памяти: */

            function f() {
                let value = 123;

                return function() {
                    alert(value);
                }
            }

            let g = f(); // пока существует функция g, value остается в памяти

            g = null; // ...и теперь память очищена.



    //! Оптимизация на практике
        /*Как мы видели, в теории, пока функция жива, все внешние переменные тоже сохраняются.

        Но на практике движки JavaScript пытаются это оптимизировать. Они анализируют использование 
        переменных и, если легко по коду понять, что внешняя переменная не используется – она 
        удаляется.
        
        Одним из важных побочных эффектов в V8 (Chrome, Edge, Opera) является то, что такая переменная
        становится недоступной при отладке.
        
        Попробуйте запустить следующий пример в Chrome с открытой Developer Tools.
        
        Когда код будет поставлен на паузу, напишите в консоли alert(value). */
        
            function f() {
            let value = Math.random();
            
            function g() {
                debugger; // в консоли: напишите alert(value); Такой переменной нет!
            }
            
            return g;
            }
            
            let g = f();
            g();

        /* Как вы можете видеть – такой переменной не существует! В теории, она должна быть доступна, 
        но попала под оптимизацию движка.
        

        Это может приводить к забавным (если удаётся решить быстро) проблемам при отладке. Одна из
        них – мы можем увидеть не ту внешнюю переменную при совпадающих названиях: */
        
            let value = "Сюрприз!";
            
            function f() {
            let value = "ближайшее значение";
            
            function g() {
                debugger; // в консоли: напишите alert(value); Сюрприз!
            }
            
            return g;
            }
            
            let g = f();
            g();

        /* Эту особенность V8 полезно знать. Если вы занимаетесь отладкой в Chrome/Edge/Opera, рано
        или поздно вы с ней столкнётесь.
        
        Это не баг в отладчике, а скорее особенность V8. Возможно со временем это изменится. Вы
        всегда можете проверить это, запустив примеры на этой странице. */
    }


}

{/*  235    ====    ЗАДАЧИ С СОБЕСЕДОВАНИЙ на понимание основ    ====

    Попробуем решить сами

    1)	Какое будет выведено значение: let x = 5; alert( x++ ); ?      

    2)	Чему равно такое выражение: [ ] + false - null + true ?         

    3)	Что выведет этот код: let y = 1; let x = y = 2; alert(x); ?     

    4)	Чему равна сумма [ ] + 1 + 2?                                   

    5)	Что выведет этот код: alert( "1"[0] )?                          

    6)	Чему равно 2 && 1 && null && 0 && undefined ?                   

    7)	Есть ли разница между выражениями? !!( a && b ) и (a && b)?     

    8)	Что выведет этот код: alert( null || 2 && 3 || 4 ); ?           

    9)	a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?            

    10)	Что выведет этот код: alert( +"Infinity" ); ?                   

    11)	Верно ли сравнение: "Ёжик" > "яблоко"?                          

    12)	Чему равно 0 || "" || 2 || undefined || true || falsе ?     */    


    
    // Разберем ответы

    // 1) 
        let x = 5; alert( x++ );  // 5 - сначала вернет значение х , а потом постфиксно(после этой строчки
                                  // увеличит на единицу)
                   alert( ++x );  // 6


    //  2) разобьем код на части [ ] + false - null + true. ВЫПОЛНЯЕТСЯ с ЛЕВА на ПРАВО
     
        console.log(typeof([ ] + false));   // "false" - строка

        /* когда мы работаем с пустым массивом то в конкатенации он приводится к типу строка, а так как он
        пустой то получим пустую строку, "" + false  и добавляя false его просто оборачивает строкой и 
        добавляет пустую строку. */

        console.log([ ] + false - null);    // NaN - когда проводим мат. операцию не с числом( кроме + со
                                            // строкой) получаем НЕ ЧИСЛО NaN

        console.log([ ] + false - null + true); // NaN добавляя к НЕ ЧИСЛУ булиновое значение все равно
                                                // получаем НЕ ЧИСЛО


    /* 3) let y = 1; let x = y = 2; alert(x); 
        Цепочка ПРИСВАИВАНИЯ выполняется справа на лево, сначала 2 присвается y а потом его значение, 
        тоесть уже 2 присваеваем x. */


    /* 4) [ ] + 1 + 2 ВЫПОЛНЯЕТСЯ с ЛЕВА на ПРАВО
         Пустой массив приравнивается к пустой строке и добавляется 1, получаем строку "1" к ней добавляем
          число 2 получая "12" */

    
    /* 5) alert( "1"[0] ) 
        Когда разбирали строки говорили что к каждому эл. строки можно обратиться по индексу, и нулевой
         индекс строка - "1" */


    /* 6) 2 && 1 && null && 0 && undefined
        Оператор И(&&) выведет true если все элементы истины(true), но если будет ложь то он выведет 
        первый ложный элемент. Он проверяет с ЛЕВА на ПРАВО 2 && 1 - true, далее он проверяет 1 && null - 
        false и он вернет значение этого ложного элемента - тоесть null. Запинается на лжи возвращает его
        значение прекращая дальнейшее выполнение выражения. Если все элементы правдивы, возвращается 
        последний правдивый элемент. */


    /* 7) !!( a && b ) и (a && b). Воспрос есть ли разница - значит проверяем через строгое (===)
        Так как a и b - нам не известны, но они разные по значению, можно заменить эти буквы на числа 
        а - первая буква алфавита - 1 ,  b - вторая буква, заменим на 2 и сравним 
        !!( 1 && 2 ) === (1 && 2) - НЕ равны потому что двойной знак восклицания превращает следующее за
        ним выражение в булиновое = true, а из вторых скобок вернется 2, при сравнении в первых скобках
        будет true а во вторых оператор И вернет последюю правду - 2, итого true НЕ равно 2 - false */


    /* 8) alert( null || 2 && 3 || 4 );
        Когда не уверенны какой из операторов сработает первым, нужно смотреть таблицу приоритетов 
        операторов JS. Гуглим. Видим что выполняется первее тот оператор у которого приоритет(число) больше,
        у И = 6, у ИЛИ = 5. Поэтому сначала выполнится И, а потом будут выполнятся ИЛИ. Значит из 2 && 3 - 
        возврщается 3, потом так как остается такое выражение  (null || 3 || 4), код пойдет с ЛЕВА на ПРАВО
        Аналогично тому как И запинается на лжи, ИЛИ запинается на правде и возвращает первое его значение 
        НЕ прекращая выполнять код, сравнивает вернувшуюся правду со ледующим значением. 
        Итого сравнивается null || 3 - возвращается 3(как единственная правда), далее сравнивается 3 || 4 - 
        и возвращается ПЕРВАЯ правда (так как они оба правда). */


    /* 9) a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b?
        объяснени лектора на примере из реального мира а - 1й ящик с 3мя яблоками, b - второй ящик с 3мя 
        яблоками, да они идентичны, но оне НЕ одинаковы. Так как это частный случай объекта, а объекты 
        передаются по ссылке, то в каждой переменной лежит своя ссылка на одинаковые массивы, и сравнивая
        ссылки - они будут не равны. */


    /* 10) alert( +"Infinity" ); 
        Так как "Infinity" это строка, то с унарным плюсом ее переведет в число Infinity. */


    /* 11)  "Ёжик" > "яблоко"
        Сравнение идет по Юникоду. Маленькие буквы имеют большее значение перед большими и чем дальше в
        алфавите буква тем больше ее значение. Cамая большая я, наименьшая А, потом идет 
        от я(U+044F) - а(U+0430), потом Я(U+042F) - А(U+0410). Сравнение идет посимвольно, если первые 
        буквы одинаковые, переходит ко вторым буквам. Так как у нас первые буквы неодинаковые и "я" имеет 
        наибольший приоритет то "яблоко" будет больше "Ёжик". Итого выражение вернет false. */


    /* 12) 0 || "" || 2 || undefined || true || falsе
        После ПЕРВОЙ правды код дальше не идет, в принципе это логично учитывая что из предыдущего(8го)
        примера все равно вывелась только ПЕРВАЯ правда. Теперь мы не смотрим по парам а смотрим по одному
        числу. Итого 0 - ложь, "" - пустая строка - ложь, 2 - правда, код выведет 2 и дальше не пойдет. */


    //! Код выполняется слева на право. А если идет несколько присвоений то выполняются справа на лево.


}

{//  236    ====    GET ELEMENTS FROM PAGE    ====  

    /* Будем получать элементы со страницы в JS скрипт и использовать его.

    ! DOM - document object model(объектная модель документа). Что бы ее увидеть вживую откроем 
    заготовленную страницу пример.
    
    
    Для урока используются файлы с названием elements_index, elements_style, elements_script. В ксс заданы
    стили, и при открытии elements_index в браузере видим большой красный квадрат, 5 кнопок, 3 синих круга
    в столбце и 3 красных сердечка в ряду
    

    Структура индекса */

        <body>
            <div class="box" id="box"></div>
            <button>1</button>
            <button>2</button>
            <button>3</button>
            <button>4</button>
            <button>5</button>

            <div class="circle"></div>
            <div class="circle"></div>
            <div class="circle"></div>

            <div class="wrapper">
                <div class="heart"></div>
                <div class="heart"></div>
                <div class="heart"></div>
                
            </div>

            <script src="js/script.js"></>
        </body>


    /* Весь ХТМЛ код является обычным документом у которого есть своя структура. И этот документ можно 
    представить как дерево узлов, при этом узлы связаны между собой отношениями родительский - дочерний.
    Все элементы которые находятся в теге body являются его дочерними эл., а он по отношению к ним является
    родительским. Такую структуру мы создаем во время верстки страницы. Когда такой документ сформирован
    мы его можем представить в виде объекта, и как у любого объекта у него могут быть свои методы, их мы
    и будем использовать чтобы иметь доступ к определенным эл. на странице. Чтобы отбратиться к DOM нужно
    использовать такую сущность(глобальный объект) как document. Если в консоли написать document и 
    поставить точку document. то высветится список из доступных ему свойств и методов, часть из которых мы
    и будем использовать. 
    
    ! document - существует только в браузере, поэтому и работать с ним нужно в браузере */



    //! Работаем в файле со скриптом elements_script.
    /* Создадим переменную в которую будем получать элементы через методы - const box 

    Методы можно разделить на :
        1) устоявшиеся(старые) методы  
        2) которые появились недавно (новые). 

    сначала мы всегда обращаемся к document, (позже рассмотрим как обращаться не через него) и так как это
    методы ставим для их вызова - (). */


    //! 1) СТАРЫЕ МЕТОДЫ
    /* В скобках передаем просто строку без точек или хештегов с именем id, tag, class - потому что
    в самом запросе мы указываем к чему хотим обратиться.

    ! По id. 
    Получаем эл. по айди(id) - уникальный идентификатор, как и название переменной он может быть только
    один на странице, соответственно и получаем в переменную только 1 элемент. 
    let box = document.getElementById(); В данном случае мы получим элемент красного квадрата. 
    <div class="box" id="box"></div> */

        const box = document.getElementById("box");   
        console.log(box);       /* <div class="box" id="box"></div> - получили элемент


    ! По TAG.
    Получаем элементы по названию тега. Так как элементов с одинаковыми тегами много то мы получим 
    ПСЕВДОМАССИВ со всеми элементами с именем такого тега, и обращаемся к тамим элементам во МНОЖЕСТВЕННОМ
    числе Elements. 

    Так как это псевдо массив то у него не будет никаких методов, только свойство length, потому что он
    наследуется не от [[Prototype]]: Array, а от различных других объектов (более 50ти различный, вот
    небольшой список из них DOMTokenList, NamedNodeMap, DOMStringMap, HTMLCollection, NodeList, 
    HTMLAllCollection, StyleSheetList, DOMStringList, HTMLMapElement, CSSRuleList)

    Что бы получить конкретный эл. из этого псевдомассива нужно указать индекс этого элемента.
    
    ! Даже если такой элемент будет 1 на странице мы все равно получим псевдомассив с одним элементом, 
    и что бы взаимодействовать с этим элементом все равно нужно обратиться к нему таким образом
    btns[0] - по индексу 0.

    todo Преобразование псевдомассива в массив https://habr.com/ru/post/336136/
    
    Получаем эл сразу. */

        btns = document.getElementsByTagName("button")[1];  // <button>2</button> - эл.
        
        
    // Получаем эл из массива прямо перед его использованием

        const btns = document.getElementsByTagName("button"); // псевдомассив
        console.log(btns[1]);                               /* <button>2</button> - эл. под индексом 1
        
        
    !По CLASS.
    По имени класса, аналогично TAG. */

        const circles = document.getElementsByClassName("circle");
        console.log(circles[1]);


    //! По NAME.
    /* document.getElementsByName() - используется очень редко и даже в старом коде мы врядли его встретим.
    Работает аналогично TAG, потому что Elements.



    ! 2) СОВРЕМЕННЫЕ МЕТОДЫ
    более функциональны поэтому их чаще используют в проектах. Обращаемся по ксс
    селектору и записывать его нужно как и в ксс  - тег 'button', имя класса '.heart' (с точкой), 
    ID - '#box' (хэштег). Ксс селектор может быть любой: вложенность классов, псевдоклассы, аттрибуты, 
    непосредственных потомков, первых правых соседей, и т.д. комбинация всего этого.

    todo Виды селекторов и как они записываются https://learn.javascript.ru/css-selectors


    ! querySelectorAll
    ВСЕ элементы по данному ксс селектору. Мы получаем псевдомассив который умеет работать с методом
    forEach, потому чnо наследуется от [[Prototype]]: NodeList, а не от [[Prototype]]: HTMLCollection 
    как в случае со старыми методами. Поэтому можно сделать перебор псевдомассива таким способом. */

        const hearts = document.querySelectorAll('.heart'); 
        console.log(hearts);    // [div.heart, div.heart, div.heart]

    /* Таким способом перебора будем пользоваться часто для смены стилей сразу у всех эл. псевдомассива,
    перебирая и каждому присваивая какой-то стиль */

        hearts.forEach(item => {
            console.log(item);  // <div class="heart">...<div class="heart"></div> - 3 эл.
        });
    

    //! querySelector
    // Позволяет получить только ПЕРВЫЙ подходящий элемент
        
        const oneHeart = document.querySelector('.heart'); 
        console.log(oneHeart);


}

{/*         ====    ВИДЫ СЕЛЕКТОРОВ и как они записываются https://learn.javascript.ru/css-selectors

    CSS3-селекторы – фундаментально полезная вещь.

    Даже если вы почему-то (старый IE?) не пользуетесь ими в CSS, есть много фреймворков для их 
    кросс-браузерного использования CSS3 из JavaScript.



    //! Основные виды селекторов
    Основных видов селекторов всего несколько:

        * – любые элементы.
        div – элементы с таким тегом.
        #id – элемент с данным id.
        .class – элементы с таким классом.
        [name="value"] – селекторы на атрибут (см. далее).
        :visited – «псевдоклассы», остальные разные условия на элемент (см. далее).


    Селекторы можно комбинировать, записывая последовательно, без пробела:

        .c1.c2 – элементы одновременно с двумя классами c1 и c2
        a#id.c1.c2:visited – элемент a с данным id, классами c1 и c2, и псевдоклассом visited
        

        
    //! Отношения
    В CSS3 предусмотрено четыре вида отношений между элементами.

    Самые известные вы наверняка знаете:

        div p – элементы p, являющиеся потомками div.
        div > p – только непосредственные потомки
        
    Есть и два более редких:

        div ~ p – правые соседи: все p на том же уровне вложенности, которые идут после div.
        div + p – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div 
        (если есть).


    Посмотрим их на примере HTML: 

        <h3>Балтославянские языки</h3>

        <ol id="languages">
        <li>Славянские языки
            <ol>
            <li>Славянские микроязыки</li>
            <li>Праславянский язык</li>
            <li id="e-slavic">Восточнославянские языки <code>#e-slavic</code></li>
            <li>Западнославянские языки <code>#e-slavic ~ li</code></li>
            <li>Южнославянские языки <code>#e-slavic ~ li</code></li>
            <li> ... <code>#e-slavic ~ li</code></li>
            </ol>
        </li>
        <li>Балтийские языки
            <ol>
            <li>Литовский язык</li>
            <li id="latvian">Латышский язык <code>#latvian</code>
                <ol>
                <li>Латгальский язык <code>#latvian *</code></li>
                </ol>
            </li>
            <li>Прусский язык <code>#latvian + li </code></li>
            <li>... (следующий элемент уже не <code>#latvian + li</code>)</li>
            </ol>
        </li>
        </ol>

    CSS-селекторы: 

        #languages li {
            color: brown;   /* потомки #languages, подходящие под селектор  LI 
        }
        
        #languages > li {
            color: black;   /* первый уровень детей #languages подходящих под LI 
        }
        

        #e-slavic { font-style: italic; }
        
        #e-slavic ~ li {  /* правые соседи #e-slavic с селектором LI 
            color: red;
        }
        
        #latvian {
            font-style: italic;
        }
        
        #latvian * {      /* потомки #latvian, подходяще под * (т.е. любые) 
            font-style: normal;
        }
        
        #latvian + li {  /* первый правый сосед #latvian с селектором LI 
        color: green;
        } 
        */

        
    //! Фильтр по месту среди соседей
    /* При выборе элемента можно указать его место среди соседей.
    
    Список псевдоклассов для этого:
        
        :first-child – первый потомок своего родителя.
        
        :last-child – последний потомок своего родителя.
        
        :only-child – единственный потомок своего родителя, соседних элементов нет.
        
        :nth-child(a) – потомок номер a своего родителя, например :nth-child(2) – второй потомок. 
                        Нумерация начинается с 1.
        
        :nth-child(an+b) – расширение предыдущего селектора через указание номера потомка формулой, 
                            где a,b – константы, а под n подразумевается любое целое число.
        
            Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо n. 
            Например: -:nth-child(2n) даст элементы номер 2, 4, 6…, то есть чётные.
            
            :nth-child(2n+1) даст элементы номер 1, 3…, то есть нечётные.
            :nth-child(3n+2) даст элементы номер 2, 5, 8 и так далее.


    
    !Фильтр по месту среди соседей с тем же тегом
    Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:
        
        :first-of-type
        :last-of-type
        :only-of-type
        :nth-of-type
        :nth-last-of-type

    Они имеют в точности тот же смысл, что и обычные :first-child, :last-child и так далее, но во 
    время подсчёта игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.
        
    
        
    ! Селекторы атрибутов
    На атрибут целиком:
        
        [attr] – атрибут установлен,
        [attr="val"] – атрибут равен val.
        

    На начало атрибута:
        
        [attr^="val"] – атрибут начинается с val, например "value".
        [attr|="val"] – атрибут равен val или начинается с val-, например равен "val-1".
        

    На содержание:
        
        [attr*="val"] – атрибут содержит подстроку val, например равен "myvalue".
        [attr~="val"] – атрибут содержит val как одно из значений через пробел.
        Например: [attr~="delete"] верно для "edit delete" и неверно для "undelete" или "no-delete".
        

    На конец атрибута:
        
        [attr$="val"] – атрибут заканчивается на val, например равен "myval".
        


    ! Другие псевдоклассы

        :not(селектор) – все, кроме подходящих под селектор.
        
        :focus – в фокусе.
        
        :hover – под мышью.
        
        :empty – без детей (даже без текстовых).
        
        :checked, :disabled, :enabled – состояния INPUT.
        
        :target – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.
        
        Например, если на странице есть элемент с id="intro", то правило :target { color: red } подсветит 
        его в том случае, если текущий URL имеет вид http://...#intro.
        
        
        
    ! Псевдоэлементы ::before, ::after
    «Псевдоэлементы» – различные вспомогательные элементы, которые браузер записывает или может записать в
    документ.
    
    При помощи псевдоэлементов ::before и ::after можно добавлять содержимое в начало и конец элемента:
        
        <style>
            li::before {
            content: " [[ ";
            }
        
            li::after {
            content: " ]] ";
            }
        </style>
        
        <ul>
            <li>Первый элемент</li>
            <li>Второй элемент</li>
        </ul>
        
    Псевдоэлементы ::before/::after добавили содержимое в начало и конец каждого LI.
        
    :before или ::before?
    Когда-то все браузеры реализовали эти псевдоэлементы с одним двоеточием: :after/:before.
    
    Стандарт с тех пор изменился и сейчас все, кроме IE8, понимают также современную запись с двумя 
    двоеточиями. А для IE8 нужно по-прежнему одно.
    
    Поэтому если вам важна поддержка IE8, то имеет смысл использовать одно двоеточие.


*/}

{ /*        ====    Преобразование ПСЕВДОМАССИВА в МАССИВ https://habr.com/ru/post/336136/

    В этой статье я расскажу про псевдомассивы: «Что это?», «Как с ними работать?», «Чем они отличаются от
    массива?», «Как преобразовать их в массив?».

    Так же, прежде чем начать, я уточню, что данная информация касается только JavaScript. То есть, я буду
    рассказывать о псевдомассивах в языке JavaScript.


    ! Что такое псевдомассив (массивоподобный объект или коллекция)?

    Псевдомассив — это объект, который структурно похож на массив. То есть у него есть числовые свойства 
    (индексы) и свойство length.

    Пример:
    {0: 'Значение 1', 1: 'Значение 2', 2: 'Значение 3', length: 3};


    ! Чем псевдомассив отличается от массива?

    Главным отличием псевдомассива от массива является его наследование прототипа, то есть свойство 
    __proto__.

    Когда мы посмотрим в свойства массива, то увидим, что он наследует прототип Array объекта. То есть, 
    все свойства, которые есть в объекте Array.prototype будут доступны для любого массива. Если же 
    посмотреть в свойства какого-либо псевдомассива, то можно заметить, что он наследует прототип другого 
    объекта вместе с другими свойствами.

    
    ! Список типов объектов, которые относятся к псевдомассивам

    Псевдомассив может наследовать прототипы различных объектов. Вот маленький список типов объектов — 
    псевдомассивов:

        DOMTokenList
        NamedNodeMap
        DOMStringMap
        HTMLCollection
        NodeList
        HTMLAllCollection
        StyleSheetList
        DOMStringList
        HTMLMapElement
        CSSRuleList

    Это маленькая часть из полного списка типов псевдомассивов, который имеет в себе более пятидесяти типов.
    Из этого вытекает следующий пункт статьи.


    !Как отличить обычный объект от псевдомассива?

    Я дня три разбирал данный вопрос читая различные статьи и в итоге составил всего одно условие: если 
    объект является псевдомассивом, то у него должно быть свойство length, которое должно являться целым 
    числом и быть больше либо равно нулю.

        Number.isInteger(Number(object.length)) && Number(object.length) >= 0


    Это условие я составил откинув следующие пункты:

    Нельзя равняться на числовые свойства, ведь если не указать их, то это не значит, что их не будет. Они
    просто будут равны значению undefined.  Когда я посмотрел типы псевдомассивов, то увидел, что в их 
    типах содержится слово Collection, Map либо List. Но данная идея сразу развеялась, так как псевдомассив
    может иметь тип обычного объекта — Object, и вообще это глупо, ведь под этот пункт даже обычный массив 
    не попадёт. Так же нельзя равняться и на нечисловые свойства, ведь нечисловое свойство может быть и в
    массиве.

    Но JavaScript «сказал», что и моё условие слишком жестокое. Когда я проанализировал варианты 
    конвертирования псевдомассива в массив, то понял, что JavaScript «съест» псевдомассив, в котором 
    свойство length равно числу, которое больше либо равно нулю.

        typeof object.length === 'number' && Number(object.length) >= 0

    И не обязательно, чтобы число было целым (кроме некоторых случаев). JavaScript просто переведёт 
    дробное число в наибольшее целое число, меньшее, либо равное указанному.


    Пример:
    Array.from({0: 'Значение 1', 1: 'Значение 2', length: 1.6}); // ['Значение 1']

    Array.from({0: 'Значение 1', 1: 'Значение 2', 2: 'Значение 3', length: 2.3}); 
                                                    / ['Значение 1', 'Значение 2']


    !Как конвертировать псевдомассив в массив?

    Чтобы преобразить псевдомассив в массив, есть несколько вариантов:

    Перебрать значения псевдомассива в обычный массив
    
    !Первый вариант, который приходит в голову новичкам — с помощью цикла перебрать все значения из
    псевдомассива в массив.

        var object = {0: 1, 1: 2, 2: 3, length: 3}
        var array = [];

        for (var i = 0; i < object.length; i++) {
        array.push(object[i]);
        };

        console.log( array ); // [1, 2, 3]


    ! С помощью функции Array.from()
    Данный вариант немного спорный, так как таблицы, поддержки браузерами данной функции, на разных сайтах
    разные. Но я с уверенностью могу сказать, что во всех современных браузерах данный метод будет работать.

        var object = {0: 1, 1: 2, 2: 3, length: 3}

        var array = Array.from(object);

        console.log( array ); // [1, 2, 3]


    ! С помощью функции Array.prototype.slice.call() ( [].slice.call() )
    Этот метод «наших дедушек и бабушек», который работает до сих пор.

        var object = {0: 1, 1: 2, 2: 3, length: 3}

        var array = Array.prototype.slice.call(object); // Или сокращённая форма: [].slice.call(object);

        console.log( array ); // [1, 2, 3]

    
    !С помощью spread оператора
    Данный метод во время написания данной статьи является довольно спорным, так как поддерживается до 
    сих пор не всеми браузерами и будет работать только с «корневыми» псевдомассивами 
    (NodeList, HTMLCollection и прочее).

        var object = document.querySelectorAll(selector);

        var array = [...object];

        console.log( array ); // [element, element, element]


    !С помощью изменения свойства __proto__
    Про это свойство я упоминал в начале статьи. Если мы изменим свойство __proto__ объекта на 
    Array.prototype, то псевдомассив преобразуется в массив. Но этот метод входит в те самые «кроме 
    некоторых случаев», про которые я писал више, так как, для полного преображения в массив, свойство 
    length должно являться целым числом.

        var object = {0: 'a', 1: 'b', 2: 'c', length: 3}
        
        object.__proto__ = Array.prototype; / Меняем __proto__ объекта

        console.log(object); // ['a', 'b', 'c']


    Так же тут есть одна особенность: если мы укажем length число, которое будет меньше чем количество
    записей в псевдомассиве, то у нас получится массив с количеством записей указанных в length и с 
    дополнительными свойствами из остатка записей.

        var object = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', length: 3}

        object.__proto__ = Array.prototype;

        console.log(object); // ['a', 'b', 'c', 3: 'd', 4: 'e']


    И ещё одна заметка: данный метод не сделает объект настоящим массивом, хоть и даст ему нужные 
    параметры. В этом можно убедиться, если проверить объект с помощью функции Array.isArray();.

        var object = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', length: 3}

        object.__proto__ = Array.prototype;

        console.log( Array.isArray(object) ); // false


    !Это самые популярные методы преображения. Так же нужно сказать, что эти все методы можно не 
    использовать, если вам нужно, к примеру, перебрать псевдомассив с помощью forEach или отфильтровать 
    его функцией filter. Для таких целей в функциях есть дополнительная функция .call(), которая даёт 
    возможность работать с псевдомассивами.

    Пример:
        var object = {0: 'a', 1: 'b', 2: 'c', length: 3}
        
        object = Array.prototype.map.call(object, v => 'Буква: ' + v);  
        / Создаём массив из значений псевдомассива или сокращённо: [].map.call(object, v => 'Буква: ' + v)
        
        console.log(object); // ['Буква: a', 'Буква: b', 'Буква: c']
    

*/}

{//  237    ====    INTERACTION WITH ELEMENTS    ====

    /* Используем файлы из предыдущего урока. 


    ! СТИЛИ. 
    У нас уже есть элементы которые мы получили со страницы, теперь будем с ними работать. Научимся 
    изменять их стили */

        let box = document.getElementById("box"),
            btns = document.getElementsByTagName("button"),
            circles = document.getElementsByClassName("circle"),
            wrapper = document.querySelector(".wrapper"),
            hearts = document.querySelectorAll('.heart'),
            oneHeart = document.querySelector('.heart'); 

            
    /* Чтобы понимать что мы можем сделать с элементом на странице, посмотрим на него с помощью console.dir
    Раскроем объект и тут можно видеть какие у него есть свойства и методы. Через поиск найдем свойство 
    style: CSSStyleDeclaration. Его тоже раскрываем и видим еще одну большую структуру, это объект внутри 
    объекта. Тут мы видим различные пустые свойства которые сейчас и будем изменять.

    ! ВСЕ свойства в объекте style - ИНЛАЙН свойства(которые прописываются в style в теге на странице). 
    ! Свойства записываются в инлайн строку, прямо в хтмл, поэтому по приоритету они будут главнее чем сss
    ! свойства из ксс файла */
        
        console.dir(box);   // div#box.box - вывелся объект


    /* Изменяем инлайн(inline) свойство - обращаемся к элементу box потом к его объекту style и теперь 
    прописываем нужное свойство только если в ксс стиль писался через тире(background-color) то в JS 
    пишется кемел кейсом(backgroundСolor) потом присваиваем ему нужное значение в формате строки. Изменим 
    также ширину width - если просто указать 500 - это не сработает потому что для ксс нужно указать 
    единицы и поэтому нам нужно передавать это в виду строки '500px' */
        
        box.style.backgroundColor = 'green';    
        box.style.width = '500px';  
        
        //Видим что цвет и размер квадрата поменялся.

 
    /* Работаем с кнопками. Хотим обратиться к одной определенной кнопке 2. Для этого укажем индекс 
    кнопки [1]. Изменим закругление углов кнопки  borderRadius укажем 100% строкой, теперь она похожа на
    овал. */

        btns[1].style.borderRadius = "100%";


    /* Самая частая ошибка новичков, когда мы хотим поменять цвет фона первого элемента из кружков
    не обращаться непосредственно к елементу, а обратится к псевдомассиву
    circles.style.backgroundColor = "red"  
    нужно прописывать код также как для кнопки, с индексом потому что тут тоже псевдомассив хоть и с
    одним элементом */

        circles[0].style.backgroundColor = "red";


    //!Задаем множество инлайн свойств для одного элемента за один раз.  
    /* Для этого есть спец. свойство - csstext - оно может передавать стили в качестве текста - в нем мы 
    прописываем ксс свойства не кемел кейсом, а так как оно пишеться в ксс файле. Так же в эту конструкцию
    можно подставлять переменные. Это очень полезно если какие то параментры у нас динамически 
    рассчитываются, например ширину модального окна в зависимости от устройства с которого зашел 
    пользователь. */

        let num = 400;
        box.style.cssText = `background-color: blue; width: ${num}px`;


    /* Чтобы назначить инлайн свойство сразу нескольким элементам массива, ведь неудобно и долго будет 
    прописывать для каждого ел. одну и туже строку меняя только индекс. Можно использовать цикл, или
    конструкцию for of или метод forEach(только если псевдомассив был получен querySelectorAll).
        
    Цикл. 
    ! Когда перебираем массив нужно указывать i = 0 что бы не потерять первый элемент. */

        for (let i = 0; i < hearts.length; i++){
            hearts[i].style.backgroundColor = "blue";
        }


    // forEach
    // Вместо циклов в основном используем перебирающие методы

        hearts.forEach(item => {
            item.style.backgroundColor = "blue";
        });
    


    //! МЕТОДЫ    
    // Очень часто части сайта создаются(генерируются) при помощи JS, на таком принципе построен React.

    //!Методы для создания элементов на лету

        const div = document.createElement("div"); // создали элемент <div></div> он существует только в JS,
                                                   // на странице мы его пока не видим
                                                    

    // также создается и текстовый узел(нода)(внутреннее наполнение тега), но этот метод используется редко

        const text = document.createTextNode("Новый текст");  


    /* Теперь можем ЗАСТИЛИЗОВАТЬ эл. который сущетвует только внутри JS - ДОБАВИТЬ к визуальной оболочке. 
    Если мы хотим ПОЛНОСТЬЮ поменять эл. кардинальным образом то чаще всего мы не прописываем целую кучу 
    стилей и даже не используем cssText, мы модифицируем ксс КЛАССЫ элементов - можем их добавить или 
    удалить. 
    
    ! В реальных проектах мы редко будем устанавливать инлайн стили, а будем работать с 
    ! ксс классами. Обычно объекту назначают класс что бы применить сразу много аттрибутов.

    Есть простое свойство className - в нем мы через пробел указываем классы которые нужно добавить к эл. 
    Но пользоваться им не стоит потому что оно устаревшее и неудобное. 
    
    Вместо него используем classList - в нем через точку можем писать действия с нашим классом(удаление,
    добавление, переключение, проверка на содержаие(наличие класса), определение количества примененных 
    классов к элементу).

    Берем переменную div с созданным элементом через точку указываем classList и еще через точку выбираем
    метод свойства класслист - add - добавляет определенный класс. В ксс файле есть стиль black - его и 
    назначим. */

        .black{
            width: 150px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            background-color: black;
            margin-bottom: 30px;
            margin-top: 30px;
            color: #fff;
        }

        div.classList.add("black");
        // Теперь стили элемента созданы и хоть он лежит только в переменной в JS, а на странице его нету. 
    


    //! ДОБАВЛЕНИЕ(вставка) елемента на страницу
    /* Любой элемент можно вставить в конец, после определенного эл., удалить или заменить, но только по
    отношению к другому элементу, потому что нам нужно отталкиваться от структуры ДОМ что бы четко сказать
    где разместить новый элемент.

    Рассмотрим современные методы для работы со страницей, их небольшая проблема в том что в устаревших
    браузерах они не будут работать. Можно это посмотреть на сайте https://caniuse.com/?search=prepend 
    и введя нужный метод, например prepend, красными квадратами показаны те браузеры и их версии в которых
    не будет работать данный метод. В готовом проекте который будем выкладывать на хостинг нам нужно будет
    их перевести в старый стандарт чтобы проект работал на старых браузерах тоже(это не всегда необходимо),
    этим занимается спец. технология без нашего участия, ее мы изучим позже.

    После современных рассмотрим устаревшие методы, потому что они все равно будут встречаться в коде и 
    знать их нужно.


    Рассмотрим самый простой вариант - добавим наш див в конец страницы(body), что бы мы его уже смогли 
    увидеть на странице. Обращаемся к document потом к тегу body и выбираем метод append 
    (appendChild - устаревший) */

        document.body.append(div); // созданный див добавился в КОНЕЦ тега body


    /* Можно вставить эл. не только в конец верстки, а и в любого другого родителя. Например у нас есть 
    обертка сердец, див wrapper. Если элемент используется только 1 раз его не обязательно помещать в 
    переменную поэтому пишем сразу document выбираем элемент querySelector(".wrapper") и присоединяем к 
    нему созданный элемент append(div) */

        document.querySelector(".wrapper").append(div);  // эл. в КОНЦЕ тега  wrapper после сердечек 
        
        // Нам этот эл. еще несколько раз понадобится поэтому присвоим его переменной
        const wrapper = document.querySelector(".wrapper");
        
        // теперь можно произвести тоже действие не обращаясь к document потому что к нему мы обращались 
        // в переменной wrapper, а  подставим сразу переменную для обращения к ней

        wrapper.append(div); // С переменной
        wrapper.appendChild(div); // УСТАРЕВШИЙ метод (разницы нету)

        
    // Присоединяем в НАЧАЛО обертки. Сначала получаем элемент к которому присоединяем
    
        wrapper.prepend(div); //Прикрепляем в НАЧАЛО тега


    /* ПЕРЕД и ПОСЛЕ какого то элемента. Но сначала нужно эти элементы получить в переменную querySelector 
    будет искать .heart внутри wrapper,  wrapper должен быть получен перед этим запросом. Можно получить 
    эти переменные внутри wrapper обращаясь сразу к нему а не к document как в начале урока */

        wrapper = document.querySelector(".wrapper");   // 1 эл. wrapper, содержащий эл-ты heart(блок эл-тов)
        oneHeart = wrapper.querySelector('.heart');     // Получаем 1 эл. heart из блока эл-тов wrapper
        hearts = wrapper.querySelectorAll('.heart');    // ПСЕВДОМАССИВ (узел) из блока эл-тов wrapper
    
        hearts[1].before(div);  // перед вторым сердечком
        hearts[1].after(div);   // после второго сердечка

        wrapper.insertBefore(div,  hearts[1]); //СТАРЫЙ метод для бефор, приходилось получать родителя эл.



    //! УДАЛЕНИЕ со страницы

        circles[1].remove();
        wrapper.removeChild(circles[1]); // СТАРЫЙ метод


    //! ЗАМЕНА одного элемента другим

        hearts[2].replaceWith(circles[0]); // Сердце заменяем кругом
        wrapper.replaceChild(circles[0], hearts[2] ); // СТАРЫЙ метод, приходилось получать родителя эл.
                                                      // который меняется



    //! ВСТАВКА ТЕКСТА в элемент на странице  

    // Первый Метод Для вставки ТЕКСТА или ХМТЛ СТРУКТУРЫ (динамическое формирование структуры хтмл )

        div.innerHTML = "<h1>Hello World</h1>";


    /* Второй Метод ТОЛЬКО для ТЕКСТА (безопасность при вводе пользователем данных, что бы он случайно 
    или намеренно не вставил какую то конструкцию и не сломал верстку или даже тег script который ведет на
    сторонный ресурс и тогда может положить сайт) */

        div.textContent = "Hello";


    /* Для вставки КУСКА ХТМЛ кода ПЕРЕД или ПОСЛЕ определенных ТЕГОВ. В первый аргумент прописываем
    слово для указания места вставки хтмл структуры, есть 4 значения:
        beforebegin - вставит перед елементом
        afterbegin - в середину ел. в начало(перед всеми дочерними, как препенд)
        beforeend - в середину элемента в конец(после всех дочерних) 
        afterend - после элемента 
    Второй аргумент принимает хтмл структуру которую вставляем */

        div.insertAdjacentHTML("beforebegin", "<h2>Hello</h2>"); 
        // вставляем "<h2>Hello</h2>" перед див



    // При таком получении елемента, не обращаясь через document, можно четко задать место поиска этих
    // элементов чтобы не захватить лишние и не сделать ошибку.

        wrapper = document.querySelector(".wrapper");   // 1 эл. wrapper, содержащий эл-ты heart(блок эл-тов)
        oneHeart = wrapper.querySelector('.heart');     // Получаем 1 эл. heart из блока эл-тов wrapper
        hearts = wrapper.querySelectorAll('.heart');    // ПСЕВДОМАССИВ (узел/) из блока эл-тов wrapper


}

{/*  238    ====    PRACTICE 5 - INTERACTION WITH ELEMENTS    ====

    С Консольным приложением закончили, теперь будем работать со страницей. Распакуем файлы из архива 
    в practice_project.


    ЗАДАНИЕ на урок:

    1) Удалить все рекламные блоки со страницы (правая часть сайта)

    2) Изменить жанр фильма, поменять "комедия" на "драма"

    3) Изменить задний фон постера с фильмом на изображение "bg.jpg". Оно лежит в папке img.
    Реализовать только при помощи JS

    4) Список фильмов на странице сформировать на основании данных из этого JS файла.
    Отсортировать их по алфавиту 

    5) Добавить нумерацию выведенных фильмов */

        'use strict';
        const movieDB = {
            movies: [
                "Логан",
                "Лига справедливости",
                "Ла-ла лэнд",
                "Одержимость",
                "Скотт Пилигрим против..."
            ]
        };


    
    {// РЕШЕНИЕ
        const movieDB = {
        movies: [
            "Логан",
            "Лига справедливости",
            "Ла-ла лэнд",
            "Одержимость",
            "Скотт Пилигрим против..."
        ]
    };

    /* 1 Через инспектор кода наводимся на элементы и находим их в верстке. Видим это это картинки(img) 
    внутри блока с классом promo__adv. Пропишем ппеременную adv и в нее через querySelectorAll получим все
    картинки( теги img ) внутри тега с классом .promo__adv. Теперь когда мы их получили можно их удалить.
    Так как у нас получен ПСЕВДОМАССИВ элементов, мы НЕ можем сделать adv.remove() - потому что у него 
    нету такого метода. Нужно взять каждый элемент из этого псевдомассива и каждый удалить. Можно 
    воспользоваться циклом, но давайте делать сразу правильно, так как псевдомассив получен через
    querySelectorAll у него есть метод forEach, воспользуемся им. */
        
        const adv =  document.querySelectorAll('.promo__adv img');
        
        adv.forEach(item => {
            item.remove();
        });
        // Обычная ф-я вместо стрелочной    adv.forEach( function (item){


    /* 2 находим эл. на странице, получаем его в переменную и изменяем "внутренности". В 3м задании нужно
    поменять фоновую картинку у элемента в котором находится нужный нам сейчас элемент. Поэтому можем 
    сразу в переменную взять родительский эл., а потом в нем найти элементы для этого задания. Для 
    простого изменения текста используем метод textContent. */
        
        const poster = document.querySelector(".promo__bg"),
              genre = poster.querySelector(".promo__genre");

        genre.textContent = "Драма";


    // 3 Элемент получен. Поэтому обращаемся к нему. Путь к картинке прописываем относительно файла 
    // index.html

        poster.style.backgroundImage = 'url("img/bg.jpg")'; 
        //Прописываем внутри другие кавычки что бы избежать конфликта


    /* 4  Для начала удалим элементы которые есть в статичной верстке. Получае их родителя
    .promo__interactive-list.  Используем один селектор querySelector что бы получить доступ к родителю 
    списка как к элементу чтобы у него был метод innerHTML. */

        let movieList =  document.querySelector(".promo__interactive-list"); 

        movieList.innerHTML = ""; //Очистили список на странице ничего не передав

        movieDB.movies.sort(); 
        // Так как это массив - сортируем по алфавиту перед добавлением на страницу

    /*Теперь формируем верстку при помощи JS и поместим(вставим/добавим) ее на страницу, каждый раз 
    когда в массиве будет проходить новый элемент(итерация forEach) будет динамически добавленна 
    строка, таким образом все фильмы из массива поместятся на страницу. Если делать это через 
    createElement вручную создавать эл., добавить ему класс, потом добавить внутренность из массива 
    и потом поместить на страницу это не самый оптимизированный способ(много операций). Легче сразу 
    вставить конструкцию(часть хтмл кода) с переменной внутри, которая будет меняться в зависимости от
    содержимого элемента массива.
    
    //! Дополнительное присваивание (+=) - плюс равно(может использоваться и минус "-") это сокращенная
    форма записи такой конструкции   a = a + 1 или a += 1; используется что бы в переменную ДОБАВЛЯТЬ
    новое значение. В данном случае для того что бы у нас не заменялось каждый раз содержимое тега, 
    а оставалось старое и к нему добавлялось новое. 
    
    Так как вставляемая верстка будет строкой можно сделать интерполяцию и добавлять номер фильма из
    индекса + 1  ${i+1}  */

        movieDB.movies.forEach((film, i) =>{
                movieList.innerHTML += ` 
                        <li class="promo__interactive-item">№${i + 1} ${film}
                            <div class="delete"></div>
                        </li>`;
        });
    

    /* Также как и очистить элемент movieList.innerHTML = "",  innerHTML нам может вернуть, содержимое
    тега на текущий момент.  Для этого присвоим его какой то переменной и получим кусок верстки в строке.
    Таким же образом его можно и присвоить для родительского тега. */

        const inner = movieList.innerHTML;
        console.log(inner);
            // <li class="promo__interactive-item">ЛОГАН
                        
            // </li>
            // <li class="promo__interactive-item">ЛИГА СПРАВЕДЛИВОСТИ
            //     <div class="delete"></div>
            // </li>
            // <li class="promo__interactive-item">ЛА-ЛА ЛЭНД
            //     <div class="delete"></div>
            // </li>
                            // <li class="promo__interactive-item">ОДЕРЖИМОСТЬ
            //     <div class="delete"></div>
            // </li>
            // <li class="promo__interactive-item">СКОТТ ПИЛИГРИМ ПРОТИВ...
            //     <div class="delete"></div>
            // </li>
    }

    {/* Мое решение
            'use strict';

            const movieDB = {
                movies: [
                    "Логан",
                    "Лига справедливости",
                    "Ла-ла лэнд",
                    "Одержимость",
                    "Скотт Пилигрим против...",
                    "Алешки",
                    'Алексеи',
                    'Акведуки'
                ]
            };
            let sortDB = movieDB.movies.sort();
            
            let listFilms = document.querySelectorAll(".promo__interactive-item");

            for (let i = 0; i < listFilms.length; i++ ){
                listFilms[i].innerHTML = `№${i + 1} ${sortDB[i]}`;
            }
    */}

    {/* Решение rework

    const reklamaBlock = document.querySelector('.promo__adv')
    reklamaBlock.innerHTML = '';

    const genre = document.querySelector('.promo__genre')
    genre.textContent = 'Драма'

    const bg = document.querySelector('.promo__bg')
    bg.style.cssText = `background: url('./img/bg.jpg') center top no-repeat;`

    const movieDB = {
        movies: [
            "Логан",
            'Алиса',
            "Лига справедливости",
            "Ла-ла лэнд",
            "Одержимость",
            "Скотт Пилигрим против..."
        ]
    };
    const filmListparent = document.querySelector('.promo__interactive-list')
    filmListparent.innerHTML = ''

    movieDB.movies.sort();
    movieDB.movies.forEach((movie, ind) => {
        filmListparent.innerHTML +=  `<li class="promo__interactive-item">#${ind+1} ${movie}
        <div class="delete"></div>
    </li>`
    })
    
    */}

    
}

{/*  239    ====    EVENT LISTENER (События и их обработчики)    ====

    Событие - сигнал от браузера о том что что-то произошло(клик, двойной клик, наведение мыши на эл., 
    убирание мыши, прокрутка колеса мыши, отправка данных из формы, нажатие клавиш на клавиатуре и т.д.).
    
    Список событий в JS https://oddler.ru/blog/i63 ,  https://developer.mozilla.org/ru/docs/Web/Events
    
    Мы их можем отлавливать - следить когда они происходят.

    Что бы использовать любое событие ему нужно назначить обработчик события - это ф-я которая срабатывает
    как только событие произошло. Способа назначить обработчики событий всего 3: 
        
    //! 1) использовать хтмл аттрибут который записывается прямо в верстке 
    и в этот аттрибут можно прямо передать ф-ю из JS. Выбираем элемент на который хотим назначить 
    обработчик события и прописывам событие с приставкой "on". Тоесть событие называется click, а мы пишем
    onclick (при нажатии). Необходимо комбинировать кавычки чтобы избежать ошибки. В реальных проектах 
    такой способ не используется. Либо в совсем маленьких скриптах либо в тестовых проектах */
       
        <button onclick="alert('Click')" id="btn">Нажми меня</button>


    //! 2) Используем СВОЙСТВО DOM дерева для событий.
    /* при этом способе мы можем забыть что этот обработчик событий у нас уже используется на кнопке или 
    из другого скрипта на него навесится другой обработчик, тогда последний обработчик заменит все 
    предыдущие, и поэтому код который написан до этого перестанет работать(потеряется функционал). 
    Еще один минус в том что иногда обработчики событий нам нужно удалять (допустим единоразовое нажатие
    на кнопку на странице), то при таком способе назначения обработчика удалить его потом мы не сможем. */

        let btn = document.querySelector("button"); // button - тег - не псевдомассив
        
        btn.onclick = function(){
            alert("Knock");
        };

        btn.onclick = function(){
            alert("Second cilck");
        };


    //! 3) addEventListener
    /* Берем все тот же элемент и добавляем к нему конструкцию addEventListener (слушатель событий). В нем
    первый аргумент click - название события(без "on"), второй аргумент коллбек функция с кодом который
    должен выполниться. */

        let btn = document.querySelector("button");
        
        btn.addEventListener("click", () => {
            alert("click");
        });

        btn.addEventListener("click", () => {
            alert("second click");
        });

        btn.addEventListener("mouseenter", () => { // при наведении на элемент
            console.log("Hover");
        });

        //! При таком способе можно на один элемент назначать несколько обработчиков событий, которые 
        //! выполняться все поочередно.

    /* События в JS выполняются в очередности их проишествия( одна большая очередь из всех событий).



    ! Получение данных о событии
    Иногда необходимо получить данные об элементе(что за событие только что произошло, что за эл. 
    используется, получить координаты этого объекта). Для этого есть спец. объект Event, он передается как
    первый аргумент в callback функцию (e) - имя для него можно использоваеть любое (event). Поэтому если
    нужно передать еще и свои аргументы ставим запятую и передаем следующими аргументами после события е
    ("mouseenter", (e, "text message") => { */

        btn.addEventListener("mouseenter", (e) => { 
            console.log(e); // при наведении получаем ОБЪЕКТ в консоль
        });

    /* В этом объекте много разных данных координаты, type:"mouseenter" - тип события который произошел, 
    target: button#btn - тот эл. на котором произошло событие. Эти свойства будем использовать очень часто.
    Для того чтобы получать не весь объект, а сразу необходимый элемент можно через точку сразу указывать 
    что мы хотим получить console.log(e.target), и теперь получаем сам елемент, с ним взаимодействовать: 
    перекрасить, поменять класс или удалить. */
        
        btn.addEventListener("mouseenter", (e)=>{ 
            console.log(e.target);  // при наведении получаем на каком объекте сработало
            e.target.remove();      // получаем элемент и удаляем его после наведения
        });



    //! removeEventListener
    /* Для назначения обработчика события мы пишем ф-ю, чтобы удалить ее тоже пишем ф-ю, но как и в
    задаче на массивы которые одинаковые или нет a = [1, 2, 3]; b = [1, 2, 3]; тут ф-я объект - и прописав
    второй раз новую ф-ю, это будет уже другая ф-я, не сможем обратится к первой чтобы удалить, поэтому
    нужно сразу присвоить ф-ю обработчика события переменной, чтобы потом на нее ссылаться. */

        const deleteElement = (e) => {
            console.log(e.target);
        }

        btn.addEventListener("click", deleteElement); // передаем имя переменной в назначаемый обработчик
        btn.removeEventListener("click", deleteElement); // при клике удаляет обработчик с этого элемента.
        
        //todo Оба обработчика срабатывают сразу и ничего не происходит ???


    // Рассмотрим более функциональный пример. Создадим переменную  i = 0, а в ф-ю допишем i++; 
    // и когда i == 2 удаляем обработчик с кнопки  btn.removeEventListener("click", targetElement);
                
        let i = 0;
        const targetElement = (e)=>{ 
            console.log(e.target);
            i++;
            if(i == 2){
                btn.removeEventListener("click", targetElement); //Удаление 
            }
        };

        btn.addEventListener("click", targetElement);
        


    //! Всплытие событий
    /* Всплытие событий(не путать со всплытием переменных hoisting, это другое) - когда событие 
    срабатывает сначала на вложенном элементе(на который назначен обработчик события), а потом на родителе
    поднимаясь все выше и выше если есть большая вложенность. 

    Поместим кнопку в див с классом overlay, теперь вокруг кнопки на странице - появился широкий контур.
    Назначим обработчик события на кнопку btn и на ее родителя overlay( в котором она лежит). */
        
        const overlay = document.querySelector(".overlay"); //найдем ел. оверлея

        const targetOverlay = (e)=>{ 
         // console.log(e.target);          // на каком елементе произошло событие
            console.log(e.currentTarget);   // Показывает на каком елементе произошло событие СЕЙЧАС
            console.log(e.type);            // Тип произошедшего события
        };
        btn.addEventListener("click", targetOverlay);
        overlay.addEventListener("click", targetOverlay);
        
    /* При нажатии на кнопку получили 2 раза вывод в консоль(двойное срабатывание ф-и) тоесть событие 
    сначало сработало на вложенной кнопке, а потом поднялось выше(всплыло) и сработало на родителе 
    overlay. Причем в консоль 2 раза выводился элемент на котором сработало событие изначально. Но если 
    заменить свойство target на (e.currentTarget); тогда увидим на КАКОМ именно элементе событие произошло
    СЕЙЧАС. Теперь в консоль выводится вторым элементом overlay. 


    ! Отмена стандартного поведения
    На практике будем использовать свойство target, так как оно удобнее. Всплытые события можно отменять,
    но на практике это не особо нужно, потому что может доставить нам еще больше проблем. Поэтому 
    будем отменять только стандартное поведение елемента в браузере. 

    СТАНДАРТНОЕ поведение
    При клике на ссылку в браузере, страница перейдет по этой ссылке взяв URL путь(Uniform Resource
    Locator. URL это лишь адрес, который выдан уникальному ресурсу в интернете) из аттрибута href, это 
    СТАНДАРТНОЕ поведение ссылки. Отправка данных из формы при нажатии кнопки submit, выделение текста
    при зажатии правой кнопки мыши. все эти стандартные поведения мы можем отменять. Есть 2 способа:

        1) Вернуть в обработчике события return false; - в самом конце. Но этот способ устаревший и им 
    почти никто не пользуется потому что есть второй вариант
    
        2) Предполагает использование МЕТОДА который есть у ОБЪЕКТА СОБЫТИЯ. Будем использовать очень часто,
    когда дойдем до веб приложений, там будет много ссылок, но при этом мы не хотим переходить на другую 
    страницу или перезагружать эту страницу, а будем назначать свои события на них, и каждый раз будем 
    использовать preventDefault  Получим элемент ссылки а , и навесим на него обработчик
     <a href="https://www.youtube.com/">https://www.youtube.com/</a> */
        
        const link = document.querySelector("a"); // получение елемента ссылки, по тегу
        link.addEventListener("click", function(event){
            event.preventDefault();     // отмена стандартного поведения, //! всегда прописываем ВНАЧАЛЕ 
            console.log(event.target);  // вместо перехода по ссылке выполняется дальнейший код
        });



    //! Применение обработчика события к МНОЖЕСТВУ элементов
    /* Частая ошибка новичков если нужно повесить обработчик события сразу на несколько однотипных 
    елементов, новички получают все элементы через querySelectorAll */

        const btns = document.querySelectorAll("button");

    /* и потом просто берут и назначают  btns.addEventListener("click", targetOverlay); и такой код 
    работать не будет, потому что у переменной btns нету такого метода, потому что в ней псевдомассив.
    Поэтому нужно его перебрать и навесить обработчик на каждый элемент псевдомассива( можно использовать
    цикл, for of, но так как псевдомассив получили через querySelectorAll - удобнее использовать forEach)*/

        btns.forEach(btn => {
            btn.addEventListener("click", targetOverlay);
        });



    //!ОПЦИИ СОБЫТИЯ (options)
    /* третий аргумент EventListener (type, listener, options).  options: capture, once, passive, 
    mozSystemGroup. once - опция хорошая альтернатива removeEventListener, потому что не нужно теперь 
    прописывать удаление обработчика а можно прописать опцию once, которая сделает выполнение ОДИН РАЗ. */

        btns.forEach(btn =>{
            btn.addEventListener("click", targetOverlay, {once: true});
        })


}

{/*  240    ====    NAVIGATION IN DOM, DATA ATTRIBUTES, FOROF преимущества    ====

    Научимся путешествовать по ДОМ дереву. Есть задача взять эл. и обратиться к его родителю или к 
    следующему эл. и уже у них поменять класс. Для тестов открываем заготовку 040 index.


    Мы уже можем получать эл. из body. Также можем получить эл. из head например для динамической смены
    стилей. получаем тег боди со всеми эл-ми. При наведении в консоли все эл. подсвечиваются */

        console.log(document.body); // <body>...</body> - 
        

    /* Также можем получить и head но эти элементы мы не увидим на странице. Видим содержимое head, 
    таким образом мы можем сменить title, добавить метатег, динамически подключить стили или шрифты. */

        console.log(document.head);
    

    /* Если смотреть на уровень выше от хед и бади, то увидим их родителя тег ХТМЛ (<html lang="en">). Его 
    мы можем получить через такое свойство. Это родительский эл. - объединяет находящиеся внутри него эл.
    </html> */

        console.log(document.documentElement);  //- получаем ХТМЛ тег со всем содержимым



    //! Дочерние эл.(внутренние) можем получить при помощи 3х методов(команд)
        
    // Самая полезная на практике childNodes. Получает узлы которые являются детьми у бади
    // - document.body.childNodes
    
        console.log(document.body.childNodes); //- NodeList(4) [text, div.wrapper, text, script]

    /* псевдомассив(NodeList) узлов(нод) боди 4 эл., а если их раскрыть то получаетс 8 эл.
    0: text 1: div.wrapper 2: text 3: script 4: text 5: comment 6: text 7: script 8: text 
    
    Разберем что за эл. Заходим в Elements открываем body видим что сначала идет текстовый узел между body
    и оболочкой wrapper (== $0), его в обычной верстке не видно, только если нажать на эл. в этой вкладке 
    в браузере - это обычный перенос строки, он считается текстовой нодой(узлом). Дальше вторым эл. идет
    эл. wrapper. После него снова идет text - перенос строки(== $0). И дальше идет script где мы 
    используем JS.

    text - перенос строки ( в браузере его видно как == $0). 8 их потому что лайв сервер добавляет
    свой comment + переносы

    При первом рендере страницы этих эл. всего 4. Остальные элементы 8 когда раскрываем подставились нам
    из-за работы live server. Он подставляет свой комментарий в верстку + 2 переноса строки до и после
    коментария и еще один перенос идет после тега script.


    ! Разница между ДОМ эл. и узлом в том что все элементы могут быть узлами, но не все узлы
    ! могут быть эл-ми.

    Как я понимаю ВСЕ элементы в тегах, которые видно в верстке в редакторе кода и они выступают узлами 
    если берется псевдомассив эл-в, а некоторые узлы видно только в браузере во вкладке Elements и в
    псевдомассиве. Узлами выступают переносы строки, текстовые узлы. Например лист айтем <li>1</li> - 
    это элемент, но в нем есть текстовый узел "1".


    Можно получить первого ребенка(узел) */
    
        console.log(document.body.firstChild); // #text - первая Нода(узел переноса строки)


    // Можно получить последнего ребенка(узел)
    
        console.log(document.body.lastChild);
        // <script>...</script> - последняя Нода(тег script с содержимым)



    //!Аналоги для получения ЭЛЕМЕНТОВ 

    //Можно получить первый элемент

        console.log(document.body.firstElementChild); // <div class="wrapper"> - первый эл. бади

    //Можно получить последний элемент
    
        console.log(document.body.lastElementChild); // <script>...</script> - последний эл. бади


    //*! Аналога childNodes для получения псевдоколлекции ТОЛЬКО ЭЛЕМЕНТОВ - НЕТ. 
    /* Тогда метод создают вручную. Можно использовать forEach для перебора псевдоколлекции но в этом 
    случае нужно использовать перебор for of  потому что в нем есть break и continue - которым мы будем 
    отсеивать(пропускать) текстовые ноды(Только те у которых NodName: "#text"- узлы переносы на новую 
    строку), если будет какой то коментарий добавленый вучную(<!-- comment -->), его тоже оставит. */

        for(let node of document.body.childNodes){
            if(node.nodeName == "#text"){ // пропускаем узлы содержащие в свойстве NodName: "#text"
                continue;              
            }
            console.log(node);
        }


    /* Мы отталкивались от родительского элемента, теперь рассмотрим методы которые позволяют 
    оттолкнуться от любого эл. на странице. Они позволяют получить, родителя, соседей и детей. Получим
    элемент <button id="current"></button> по айди так как будем использовать 1 раз то не помещаем его в 
    переменную */

        console.log(document.querySelector("#current"));
    

    /* Посмотрим на верстку. Этот эл. у нас кнопка которая находится между двумя другими кнопками для 
    которых родителем выступает <div class="first">. Допустим задача - при клике на кнопку получить 
    её родителя. */

        console.log(document.querySelector("#current").parentNode); 
        // <div class="first">...</div> - получаем родительскую ноду 


    // Если нам нужно получить родителя еще на уровень выше коим является <div class="wrapper"> пропишем
        
        console.log(document.querySelector("#current").parentNode.parentNode);
        // получаем ноду родителя еще на уровень выше
        

    // *! Получаем родительский ЭЛЕМЕНТ. Таким образом мы ТОЧНО знаем что получим элемент.

        console.log(document.querySelector("#current").parentElement); // получаем ЭЛЕМЕНТ



    //! Data аттрибуты. 
    /* Когда пишем скрипты нам не хватает ориентиров, конечно мы можем везде в верстке расставить 
    id(айдишники), но у этого способа есть минус, поговорим дальше о нем. Для удобного ориентирования были
    созданы data аттрибуты с таким синтаксисом <li data-current="3">3</li>. Всегда начинаем его с этой 
    части "data-" , а дальше пишем абсолютно все что хотим, например data-current или data-modal(модальное 
    окно) или data-close(этот эл. будет что то закрывать.) Если оставить без значения data-current то оно 
    будет приравниваться к data-current = true, означает что этот аттрибут у нас существует, но можно и 
    присвоить значение data-current="3". 
    
    Для получения эл. по аттрибуту ставим [] квадратные скобки. *!комбинация кавычек */

        console.log(document.querySelector("[data-current='3']"));// элем по дата аттрибуту 


    // Методы получени следующей и предыдущей НОДЫ(узел)
        
        console.log(document.querySelector("[data-current='3']").nextSibling); 
        //#text - Следующая нода(узел переноса строки)

        console.log(document.querySelector("[data-current='3']").previousSibling); 
        //#text - Предыдущая нода


    // Аналогичные методы для ЭЛЕМЕНТОВ
        
        console.log(document.querySelector("[data-current='3']").nextElementSibling);   
        // <li>4</li> -Следующий элемент

        console.log(document.querySelector("[data-current='3']").previousElementSibling);
        // <li>2</li> -Следующий элемент


}

{/*  241    ====    РЕКУРСИЯ    ====

    Рекурсия - функция которая вызывает сама себя.



    Класический пример - ф-я возведения в степень. Тоесть умножение числа на самого себя заданное 
    количество раз. Такие результаты нужно получить */

        pow(2, 1)   // 2
        pow(2, 2)   // 4
        pow(2, 3)   // 8
        pow(2, 4)   // 16
        

    // Можно написать ф-ю двумя подходами.

    /* 1) функция принимает 2 аргумента: 1 - базовое число, 2 - в какую степень его возвести. Сделаем 
    переменную result с числом по умолчанию, поместим в него 1(единицу), потому что далее мы будем множить 
    это число на первый аргумент, и если присвоить 0(ноль) тогда не получим нужный результат, так как 
    любое число в 0 степени равно 1 поэтому и присваиваем 1, тогда цикл не сработает ни разу и из ф-и
    вернется 1, а если будет хотя бы в степени 1, тогда цикл сработает один раз и мы получим то число
    которое задавали первым аргументом.

    Сделаем цикл который будет работать пока итератор i будет меньше чем передаваемая степень, так как i
    начинается с 0, то итераций будет как раз столько сколько значение n. В цикле - result умножится на 
    нужное число, примет его значение и в следующих итерациях уже получается что result будет заданным 
    числом и будет множится на самого себя. 
    result *= x   оператор дополнительного умножения, как и в случае с += он заменяет более длинный 
    синтаксис  result = result * x

    возвращаем результат  */

        function pow(x, n) {
            let result = 1

            for(i=0; i < n; i++){
                result *= x
            }

            return result
        }


    /* 2) Второй метод. Вместо цикла будем использовать саму же ф-ю которая возводит в степень, чтобы
    она запускала себя столько раз сколько заданная степень. 

    Сделаем условие что если степень 1 тогда просто вернем заданное значение, но если степень отличается,
    тогда будем возвращать число умноженное на ф-ю( степень pow(x, n-1) ). 
    
    Как работает:
    если приходит (2, 2) тогда в else вместо х подставляется 2, которое будет умножено на
    результат этой же ф-и но в которую передано (2, 1), потому что отняли 1 от степени, и тогда в этой
    ф-и сработает if и из нее вернется 2. Тогда в первой ф-и 2 умножится на 2.

    если приходит (2, 3) тогда также ф-и запускаются пока множитель не будет (2, 1) степени его результат
    вернется как 2 - потому что пойдет по другой ветке условия if и больше не запустит саму себя( с этого
    момента пойдут вычисления в ф-ях запущенных выше) и умножится на 2 в ф-и выше становясь 4, которая 
    вернется в ф-ю выше и умножится на 2 вернув искомое 8  */

        function pow(x, n) {
            if(n === 1) {
                return x
            } else {
                return x * pow(x, n - 1 )
            }
        }


    
    //! База рекурсии
    /* Это случай когда возвращается само переданное значение, не запуская при этом вложенную ф-ю(саму
    себя), в примере выше это if (n === 1) при передаче (2, 1).  */


    //! Шаг рекурсии
    // З апуск вложенной ф-и но уже с другим значением. В примере выше это единица  n - 1 


    //! Глубина рекурсии
    // Общее количество вложенных вызовов вместе с самым первым. В примере выше это число n.


    //! Максимальная глубина рекурсии 
    // составляет около 10 000, зависит от сложности расчетов внутри ф-и и железа на котором запускают код



    //! Какой способ использовать, с циклом или с рекурсией если понятно что оба варианта возможны?
    /* выбор всегда за програмистом, но есть нюансы. Обычно подход с циклом обычно эффективнее, это
    связанно с внутренним устройством языка и такими вещами как контекст и стек вызова. Хотя с другой
    стороны рекурсия делает ф-и проще. */

    //! большинство программистов отдают предпочтение рекурсии и вот почему, рассмотрим пример.
    /* Из объекта со студентами нужно посчитать общий прогресс по ученикам. Можно воспользоваться
    или циклом или рекурсией. Напишем оба варианта и сравним. Также рассмотри пару полезных методов.

    Для вычисления среднего прогресса - нужно посчитать всех студентов, просуммировать их прогресс и
    это число поделить на количество студентов. */

        let students = {
            js:[{
                name: 'John',
                progress: 100
            }, {
                name: 'Ivan',
                progress: 60
            }],

            html: {
                basic:[{
                    name: 'Peter',
                    progress: 20
                }, {
                    name: 'Ann',
                    progress: 18
                }],

                pro: [{
                    name: 'Sam',
                    progress: 10
                }]
            }
        }


    /* 1) Рассмотрим через перебор циклом. Ф-я будет возвращать результат деления прогресса на количество
    студентов.

    Для того чтобы получить значения свойств объекта используем метод Object.values() который возвращает
    массив с значениями. Воспользуемся циклом for of чтобы перебрать этот массив.
    
    Назовем переменную course в которую будем получать массив елемент полученного массива - массив из 
    свойства js и объект из свойства html или любого другого который будет в любом объекте с которым нужно
    работать. Будем пребирать Object.values(data) в который передаем data которая пришла в ф-ю. При этом
    объект вместе с названиями свойств у нас отпадает и получается массив с двумя значениям в которых 
    будет лежать то что раньше было в js и html и теперь каждый этот элемент массива при переборе for of
    будем получать в переменную course. 
    
    Теперь в course у нас лежит массив и объект( ну или может быть любой тип данных), но в данном
    случае будем предполагать именно эти два типа данных, а значит нам нужно сделать для каждого типа
    развилку со своими действиями через условие.

    В условии нужно проверять тип который в переменной course, и если будем использовать typeof то на 
    массиве тоже получим object, поэтому нужно воспользоваться другим методом Array.isArray() - который 
    возвратит true если массив или false в другом случае. 

    Если попали на массив(тру) тогда считаем количество студентов и суммируем их свойства прогресса, снова
    через цикл вытаскивая свойство прогресс у каждого ел. массива и суммируем в total, далее узнаем другие
    способы как это можно сделать. Количество студентов получаем из длинны массива course.length.
    
    Если не массив тогда снова получаем его значения в массив через Object.values но называем елемент
    subcourse, и делаем такие же шаги как для массива выше но без проверки на массив, потому что мы знаем
    что дальше вложенности нету.  */

        function getTotalprogressByIteration(data) {
            let total = 0
            let students = 0

            for ( let course of Object.values(data)) {
                if (Array.isArray(course)) {
                    students += course.length

                    for ( let i = 0; i < course.length; i++) {
                        total += course[i].progress
                    }
                } else {
                    for ( let subcourse of Object.values(course)) {
                        students += subcourse.length

                        for ( let i = 0; i < subcourse.length; i++) {
                            total += subcourse[i].progress
                        }
                    }
                }
            }

            return total / students
        }

        console.log(getTotalprogressByIteration(students))


    /* 2) 
    А если внутри html появится еще какая то вложенность, свойство в котором будет еще свойство,
    а потом уже массив. Тогда наш код не сработает, потому что мы ориентировались на готовую структуру
    и на последующие вложенности не рассчитывали. В таком случае придется еще усложнять наш код писать
    проверку на уровне subcourse. Это очень не удобно и притом код повторяется. Таким образом если
    написать код через рекурсию в нее мы заключим повторяющиеся действия и она будет вызывать саму себя 
    столько раз сколько нужно.

    Сначала нужно определится с базовыми понятиями рекурсии. Что у нас будет базой - которая заканчивает
    вызов самой себя. В этом объекте это будет нахождение массива, значит в середине будут только студенты
    и можно начать считать.

    Может быть что students сразу будет массивом со студентами, поэтому построим подсчет на таком случае.
    ! Можно заметить что при использовании рекурсии у нас отсутствуют переменные для хранения промежуточных
    ! результатов, так происходит потому что они высчитываются на уровне ф-и (в блоке else в примере со
    ! степенью) и таким образом снова попадают как аргументы в ф-ю. В самом конце приходя к базе и 
    ! произведя все подсчеты получим итоговый результат.

    Значит нужно подумать как обойтись без переменных. Для total все же придется создать переменную, а
    общее количество студентов (students) в массиве будем вычислять как data.length. После выполнения
    ! подсчетов нужно возвращать результат(для вывода из ф-и или для использовании в последующей итерации
    ! запуска этой ф-и), но тут нам нужно вернуть 2 значения, а return возвращает только одно. Сделать это
    ! можно разными способами, но самый простой вернуть массив.

    Теперь напишем вторую часть - это уже будет сама рекурсия, когда попадаем на объект(или какой то 
    другой тип, но в данном примере - объект). //! Для промежуточных результатов нам всеже нужны 
    ! переменные, создадим массив с двумя значениями - под общее количество студентов и для прогресса.
    ! Так как для нашего случая мы точно знаем что в else получим точно объект, значит сделаем перебор
    ! массива subData получившегося из него после применения Object.values(data).
    ! Самый важный момент всей рекурсии, нужно запустить саму же ф-ю снова (на вложенных данных в объекте,
    ! в данном случае свойстве html). Так как мы знаем что из этой же ф-и когда она дойдет до базы нам
    ! возвращается массив с данными return [total, data.length] мы назовем его subDataArr и в эту 
    ! переменную ложим результат запуска изначальной ф-и(которая проверят на массив) 
    ! getTotalprogressRecursion, а в нее передаем subData. Таким образом у каждый раз будет запускаться
    ! рекурсия и она внутри себя будет запускать случай до тех пор пока не дойдет до базы.

    ! Теперь в subDataArr у нас лежит возвращенный массив с данными return [total, data.length] и нужно
    ! его данные добавить в массив total(потому что у нас цикл фор оф и нужно сохранить эти данные, а то
    ! они пропадут) который мы создали чтобы его вернуть из блока else для использования в ф-ях 
    ! запущенных выше.  
    
    Получим такой массив в переменную result, но нам же нужно получить средний прогресс, поэтому выполним
    деление result[0]/result[1] */

        function getTotalprogressRecursion(data) {
            if (Array.isArray(data)) {
                let total = 0

                for ( let i = 0; i < data.length; i++) {
                    total += data[i].progress
                }

                return [total, data.length]
            } else {
                let total = [0, 0]

                for (let subData of Object.values(data)) {
                    const subDataArr = getTotalprogressRecursion(subData)
                    total[0] += subDataArr[0]
                    total[1] += subDataArr[1]
                }

                return total
            }

        }

        const result = getTotalprogressRecursion(students)
        console.log(result[0]/result[1])


}

{/*  242    ====    PRACTICE 6 USE eventListeners    ====
        
    Будем использовать проект с фильмами из прошлой практики в - 200\rework_practice_238


    ЗАДАНИЕ:

    1) Реализовать функционал, после заполнения формы и нажатия кнопки "Подтвердить" - новый фильм 
    добавляется в список movieDB. Страница не должна перезагружаться.
        
    *Для получени доступа к значению input обращаемся к нему как input.value; - тут есть несколько 
    вариантов решения.


    2) Если название фильма больше чем 21 символ, обрезать его и добавить три точки

    3) При клике на мусорную корзину (на против фильма) - элемент будет удаляться из списка (сложно).

    4) Если в форме стоит галочка - "Сделать любимым" - в консоль выводится сообщение "Добавлен любимый 
    фильм"

    5) Фильмы сортируются по алфавиту
    */



    //  +++ РЕШЕНИЕ    

    {'use strict';

    /* Некоторые страницы плохо оптимизированы, и так как построение ДОМ дерева идет сверху вниз и там
    будут тяжелые картинки например, элементы могут долго появляться на странице, а наш код уже может
    обращаться к странице для получения эл. которых еще нету. Чтобы наш код не начал работать раньше чем
    страница загрузиться нужно обернуть весь код в обработчик события с callback функцией которая начнет 
    работать ТОЛЬКО при ПОЛНОМ ПОСТРОЕНИИ ДОМ дерева. 
    

    Для этого у нас есть 2  отслеживаемых события: 

        1) load - когда страница ПОЛНОСТЬЮ загрузилась со всеми скриптами и картинками; 

        2) DOMContentLoaded - при этом мы ждем не полной загрузки всех элементов на странице, а только 
        построение ДОМ структуры, тоесть когда наше дерево тегов (DOM) сформируется полноценно для 
        нормальной работы с ним, тогда наши скрипты начинают работать а картинки и остальное еще 
        подгружаются. */

        document.addEventListener('DOMContentLoaded', () =>{ // - скрипт начнет работу при полной загрузке
                                                             // ДОМ дерева
        const movieDB = {
            movies: [
                "Логан",
                "Лига справедливости",
                "Ла-ла лэнд",
                "Одержимость",
                "Скотт Пилигрим против..."
            ]
        };
        
        const adv =  document.querySelectorAll('.promo__adv img');  // Удаление рекламы
        const bg = document.querySelector(".promo__bg"),     
        genre = bg.querySelector(".promo__genre");
        let movieList =  document.querySelector(".promo__interactive-list"); // Доступ к родителю списка
    


    /* 1) На сайте при нажатии на кнопку "Подтвердить" идет отправка формы на серверер и стандартное 
    действие при этом - перезагрузка страницы. Можно решить парой способов:
    
        1) когда отправляется форма - добавляем новые данные в массив и после этого заново строим список
        фильмов; 
        
        2) делаем это паралельно, добавляем новый эл. в верстку и новый эл. в массив. 
        
    На этом проекте разницы в быстродействии не будет, но второй способ тяжее реализовать, поэтому 
    разберем только первый способ. */

        // Получим эл. с которыми будем работать.
        const addForm = document.querySelector("form.add"); //<form class="add"> - форма с классом add
        const addInput = addForm.querySelector(".adding__input"); // в теге form ищем класс 
        const checkbox = addForm.querySelector("[type=checkbox]");  // ищем по аттрибуту 


        // Для отслеживания отправки формы используем обработчик событий по событию submit

        addForm.addEventListener('submit', (event)=>{
            event.preventDefault();         // отменяем стандартное поведение формы

            let newFilm = addInput.value;   // берем введенный пользователем текст
            const favorite = checkbox.checked; // обращаемся к чекбоксу по свойству checked, оно вернет 
                                                // булево при изменении состояния галочки(onchange)
            
            if(newFilm) {  // Проверка на пустую строку(если ничего не ввели - false)
                if(newFilm.length > 21){
                    newFilm = `${newFilm.substring(0, 22)}...`; //проверяем на длинну и добавляем точки
                }
                if(favorite){
                    console.log("Добавляем любимый фильм");
                }
                    movieDB.movies.push(newFilm);  // пушим фильм в массив
                    sortArr(movieDB.movies);        // заново сортируем список
                    
                    createMovieList(movieDB.movies, movieList); // заново строим список на странице
            }
        
            event.target.reset(); //! удаляем текст из формы (addForm заменили на event.target разницы нет)
        });


        // Создаем функцию для вывода списка чтобы ее можно было вызвать при нажатии и добавляем аргументы
        // чтобы отойти от переменных, а ф-я узнавала с чем она работает только в момент вызова.

            function createMovieList(films, parent){
                parent.innerHTML = ""; //Очистили список на странице
                sortArr(films);         // При загрузке страницы  createMovieList вызывается тоже 
                                        // и сортирует
                films.forEach((film, i) =>{    // a = a + 1 или a += 1;
                    parent.innerHTML += ` 
                                <li class="promo__interactive-item">№${i+1} ${film}
                                    <div class="delete"></div>
                                </li>
                        `; 
                });

        /* Корзинка на которую нужно нажать чтобы удалился фильм создается динамически с помощью CSS. В 
        верстку в браузере к каждому фильму элементу с фильмом после построения списка фильмов добавляется
        див с классом delete  <div  class="delete" - это и есть та самая корзинка. Чтобы корзинка 
        соответствовала тому фильму на против  которого расположена нам нужно брать список(массив) 
        корзинок после построения нового списка и вешать на каждую обработчик события для удаления 
        родителя корзинки + к этому нужно будет удалить фильм из базы данных и перестроить список. */

            document.querySelectorAll(".delete").forEach((btn, i)=>{ //получаем кнопки удаления 
                btn.addEventListener("click", ()=> {
                    btn.parentElement.remove();
                    movieDB.movies.splice(i, 1); //удаляем 1 элемент под индексом i из массива(базы данных)
                                                //! потому что индексы ел-в перебираемого массива кнопок 
                                                //! совпадают с инд. в массиве с фильмами 
                    createMovieList(films, parent); //заново перестраиваем список,
                                                    // вызывая функцию внутри себя (Рекурсия)
                });
            });
        }  


        // Оборачиваем удаление рекламы в ф-ю что бы ее вызвать и добавляем параметры что бы отвязаться
        // от переменных.

            const deleteAdv = (arr)=>{
                arr.forEach(item=>{
                    item.remove();
                });
            };


        // Оборачиваем два действия в ф-ю

            let makeChanges = () =>{
                genre.textContent = "Драма";
                bg.style.backgroundImage =  "url('img/bg.jpg')";
            };


        // Создадим дефолтную ф-ю для сортировки для того если наша ф-я будет дополняться, например
        // добавится проверка сортируемых эл., возможно подключить доп. ф-ю сортировки как мы делали
        // с числами.

            let sortArr = (arr) =>{
                arr.sort();
            };
            
            deleteAdv(adv);
            makeChanges();
            createMovieList(movieDB.movies, movieList); // вызываем первый раз для построения 
                                                        // первоначального списка
        });

    }

    {// Мое решение
        'use strict';

        const movieDB = {
        movies: [
            "Логан",
            "Лига справедливости",
            "Ла-ла лэнд",
            "Одержимость",
            'Алешки',
            "Скотт Пилигрим против..."
        ]
        };
            
        const adv =  document.querySelectorAll('.promo__adv img');
        
            adv.forEach(item => {
                item.remove();
        });
            
        const poster = document.querySelector(".promo__bg"),
                genre = poster.querySelector(".promo__genre");
    
        genre.textContent = "Драма";
    
        poster.style.backgroundImage = 'url("img/bg.jpg")'; 
    
        let movieList =  document.querySelector(".promo__interactive-list"); 
    
        // 30 lesson
            
        let btn = document.querySelector('button');
        let input = document.querySelector('.adding__input');
        let mark = document.querySelector('[type=checkbox]');
    
        btn.addEventListener("click", (event) => {
            event.preventDefault();         // 1)
    
            if( input.value.length < 21) {  // 2)
            movieDB.movies.push(input.value);
            } else {
                movieDB.movies.push(input.value.slice(0, 21) +"...");
            }
    
            if(mark.checked) {              // 4)
                console.log("Добавлен любимый фильм");
            }
    
    
            movieList.innerHTML = ""; 
    
            movieDB.movies.sort();          // 5)
    
            movieDB.movies.forEach((film, i) =>{    
                movieList.innerHTML += ` 
                        <li class="promo__interactive-item">№${i + 1} ${film}
                            <div class="delete"></div>
                        </li>
                `;
            });
            // console.log(movieDB.movies);
        });
        // 3) При клике на мусорную корзину (на против фильма) - элемент будет удаляться из списка (сложно).
            // НЕ СДЕЛАЛ

    }

    {// Решение rework
    'use strict';
    const reklamaBlock = document.querySelector('.promo__adv')
    const genre = document.querySelector('.promo__genre')
    const bg = document.querySelector('.promo__bg')
    const filmListparent = document.querySelector('.promo__interactive-list')
    const submitBtn = document.querySelector('button')
    const userInput = document.querySelector('.adding__input')
    const checkbox = document.querySelector('.checkbox')
    let deleteBtns = document.querySelectorAll('.delete')
    
    
    const movieDB = {
        movies: [
            "Логан",
            'Алиса',
            "Лига справедливости",
            "Ла-ла лэнд",
            "Одержимость",
            "Скотт Пилигрим против..."
        ]
    };
    
    reklamaBlock.innerHTML = ''
    genre.textContent = 'Драма'
    bg.style.backgroundImage = `url('./img/bg.jpg')`
    
    function deleteBtnsEvents() {
        deleteBtns = document.querySelectorAll('.delete')
        deleteBtns.forEach((el) => {
            el.addEventListener('click', (e) => {
                let elementText = e.target.parentElement.textContent.slice(2).trim()
    
                let filterMovies = movieDB.movies.filter((el, ind, arr) => {
                    return (el != elementText)
                })
    
                movieDB.movies = filterMovies
    
                sortAndView()
            })
        })
    
    }
    
    function sortAndView() {
        filmListparent.innerHTML = ''
        movieDB.movies.sort()
        
        movieDB.movies.forEach((movie, ind) => {
            filmListparent.innerHTML +=  `<li class="promo__interactive-item">#${ind+1} ${movie}
            <div class="delete"></div>
        </li>`
        })
        deleteBtnsEvents()
    }
    
    submitBtn.addEventListener('click', (e)=> {
        e.preventDefault()
        let value = userInput.value
        if(value.length >= 15) {
            value = value.slice(0, 16) + '...'
        }
        movieDB.movies.push(value)
        sortAndView()
        if(checkbox.checked){
            console.log("Добавлен любимый фильм")
        }
        
    })
    
    sortAndView()

    }


}

{//  243    ====    EVENTS on MOBILE devices    ====

    /* Главное отличие моб. браузеров от обычных - в них не происходят события связанные с мышкой
    (клик, наведения мыши на эл., и т.д.). Вместо них есть tap - прикосание пальцем к экрану, также 
    пальцев может быть несколько, поэтому поддерживается мультитач.

    ! Моб. браузеры нормально отрабатывают с обычными сайтами, если мы установили событие - клик, то оно
    будет корректно отрабатывать на мобильном. JS сам запускает сразу серию событий чтобы ничего не 
    пропустить.


    Событий на моб. браузерах 6 и все они начинаются со слова touch.

        1) touchstart - срабатывает при касании к элементу
        2) touchmove - коснулись к элементу и двигаем палец, будет срабатывать при каждом перемещении
                         пальца
        3) touchend - когда палец перестает касаться (оторвался от эл.)
        4) touchenter - ведем пальцем по экрану и наскакиваем на эл.(заход на пределы элемента)
        5) touchleave - противоположное, когда палец уходит с эл. но не оторвался от экрана
        6) touchcancel - возникает когда точка соприкосновения не регистрируется, когда не отрывая пальца
                            он выходит за пределы браузера на рабочий стол или другое приложение.


    Посмотрим на практике как это работает. Навесим обработчик события для того что бы скрипт начал
    работать при полной загрузке ДОМ дерева. Работаем с файлом с названием 043_индекс. У нас есть один 
    эл. для начала работы получим его в переменную. */

        window.addEventListener('DOMContentLoaded', () => {
            const box = document.querySelector('.box');

            box.addEventListener('touchstart', (e) => {
                e.preventDefault();
                console.log('start!');
                console.log(e.touches); // {0: Touch, length: 1} объект с одним пальцем под индексом 0
            });

            box.addEventListener('touchmove', (e) => {
                e.preventDefault();
                console.log('Move');
                console.log(e.targetTouches[0].pageX); // 78.33332 - коорд. касания ПЕРВОГО пальца по Х
            });

            box.addEventListener('touchend', (e) => {
                e.preventDefault();
                console.log('End');
            });
        });

    /* Назначили сенсорное событие которое произойдет если будет касание пальца. В браузере можем
    эмулировать мобильное устройство. Для этого нужно открыть панель разработчика и нажать вторую кнопку
    в левом верхнем углу Toggle device toolbar ctrl+shift+m. Теперь при нажатии на эл. срабатывает событие
    касания пальцем.

    Добавим еще 2 самых частых события touchmove и touchend. touchmove - зажав кнопку и ведя по элементу
    появляется много сообщений move, при малейшем сдвиге мышки, даже на 1 пкс. touchend - срабатывает при
    отжатии кнопки.

    Эти события полезно знать потому что на телефоне есть swipe - смахивание пальцем на следующий эл., 
    такое поведение генерируется при помощи сенсорных событий. Также действие "щипок" - когда мы 
    увеличиваем или уменьшаем что то на экране тоже генерируется этими событиями.


    Когда работаем с сенсорными устройствами у объекта элемента (e) есть дополнительные свойства:

        1) touches - свойство выдает список всех пальцев взаимодействующих сейчас с ЭКРАНОМ. Если раскрыть
                        такой список можно увидеть target - с чем было произведено действие, координаты,
                        угол наклона.
        2) targetTouches - показывает список всех пальцев которые взаимодействуют сейчас с ЭЛЕМЕНТОМ.
        3) changedTouches - список пальцев которые участвуют В СОБЫТИИ. Например если это событие touchend
                        то список будет содержать и палец который был убран, даже если только 4 пальца
                        у нас на экране.


    Рассмотрим как можно в простом варианте реализовать отслеживание движения пальцев в єлементе.
    В touchmove в консоль будем выводить не просто сообщение, а (e.targetTouches[0].pageX) - координаты
    касания ПЕРВОГО [0] пальца по иксу, которые будут выводиться как только положение пальца по 
    горизонтали будет изменяться. Если координаты перейдут через определенное значение(границу) то 
    произойдет переключение слайда в слайдере, тут нужно будет строить логику под каждый отдельный скрипт.
    В реальных проектах с нуля такие большие сложные объекты мы врятли будем создавать, для них есть уже
    готовые библиотеки такие как hammer.js https://hammerjs.github.io  */


}

{//  244    ====    Async, defer, Динамические скрипты    ====

    /* Будем оптимизировать загрузку скриптов на страницу. Как правильно это делать и как оптимизировать.
    Повторим действия браузера. Когда он открывает индекс.хтмл - браузер считывает DOCTYPE понимает что
    это ХТМЛ страница, видит какой язык установлен основным, дальше начинает загружать head: подгружает 
    meta теги - устанавливаетих на странице, потом устанавливает title. Дальше подгружает стили которые 
    тут прописаны.
    
    Потом переходит к body и начинает строить верстку тег за тегом сверху вниз, в конце если подключен
    скрипт - загружается скриптовая структура и идет дальнейшая работа со скриптом. Далее страница 
    загружается полностью.
        
    Новички могут подключить скрипт в head и тогда если скрипт работает с эл. на странице которые еще не
    построились, будет ошибка, а вторая проблема это то что выполнение скрипта блокирует построение 
    страницы(ДОМ структуры).

    Первую проблему мы частично решали при помощи обработчика события DOMContentLoaded, а вторую проблему
    пока решали подключением скрипта в конце документа, НО для больших проектов где очень много верстки
    такой способ не подойдет, потому что пока будет строиться вся верстка скрипт работать не будет, это
    будет очень заметно если у пользователя плохая скорость интернета или картинки на сайте 
    неоптимизированы. Для решения такой проблемы были придуманы два аттрибута defer и async.



    defer - этот аттрибут сообщает браузеру что он должен продолжать обрабатывать страницу и загружать 
    скрипт в фоновом режиме, а затем запустить скрипт когда она загрузится 
    !( загрузка DOM будет выполнена).

    Скрипты с defer никогда не блокируют построение страници. Скрипты с defer выполняются 
    ! последовательно поэтому есть недостаток если впереди маленького скрипта стоит большой, маленький
    будет ждать выполнения(загрузки) большого. Таким образом подключая скрипты мы можем быть уверены что
    сначала загрузится важный скрипт например с библиотекой jQuery, а потом тот который работает с этой
    библиотекой в котором код зависит от нее. Можно даже поместить такие скрипты в head, но в реальных
    проектах, такие инструменты как google test speed будут ругаться и просить перенести скрипты в body, 
    так что такая структура не всегда актуальна. */

        //<script defer src="js/main_1.js"></script>

    /* //! - подключение скрипта помещено в начало body или даже в head 



    async - запускается как только он будет загружен не ждет полного построения DOM модели, и других 
    скриптов. Для async и других скриптов существуют две разные очереди выполнения. Используется для 
    подвязки скриптов которые не зависят от DOM или других скриптов сайта(метрики и счетчики - которые
    должны загрузиться раньше всех на страницу и уловить присутствие пользователя).Из двух скриптов с
    async начнет работать первым тот который быстрее загрузился и обработался. */

        <script async src="js/main_2.js"></script>
    


    /* Динамически загружаемый скрипт ведет себя как *! async(выполняется сразу), пример формирования
    скрипта в другом скрипте. Такой скрипт начнет выполняться как только будет помещен на страницу после
    обработки строчки с присоединением append. При тестировании в консоли браузера видна небольшая 
    задержка при выполнени второго(созданного) скрипта. Если в скрипте создаются два скрипта 
    последовательно то они будут выполнятся в порядке подгрузки на страницу. */

        const script = document.createElement("script"); //создаем елемент
        script.src = "js/test.js";                       //задаем атрибут сорс
        document.body.append(script);    //присоединяем к боди(помещается в конец страницы ) и он 
                                         // сразу выполняется


    /* В редких случаях нам нужно отменить асинхронное поведение динамически загружаемого скрипта, 
    тогда обращаемся к атрибуту script.async и установим ему значение false, перед тем как поместить
    скрипт на страницу. Теперь скрипты будут вести себя не как асинхронные и будут выполняться строго
    друг за другом. */

        function loadScript(src){
            const script = document.createElement("script");
            script.src = src;
            script.async = false;
            document.body.append(script);
        }

        loadScript("js/test.js"); //будут выполнятся последовательно
        loadScript("js/some.js");


}



// 300 ========================================= В РАБОТЕ ============================================

{//  302    ====    Classlist и делегирование событий    ====

    // Рассмотрим classlist на заготовленном примере 302. Видим минипроект из кнопок в ксс файле есть разные стили.
        <div id="first" class="btn-block">
            <button class="blue some"></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
        </div>



    // Мы уже рассматривали добавление стиля через класслист add. Теперь рассмотрим другие возможности. Сначала получим псевдомассив
        // со всеми кнопками на странице. Если мы напишем так btns.classList - то ничего не сработает, потому что у псевдомассива
        // не существует такого свойства. Нами нужно обратиться к конкретному элементу, например первая кнопка с индексом 0
        // btns[0].classList.length - таким образом можно увидеть какие классы есть у эл. - получили число 2. Чаще на практике
        // применяются методы свойства classList.

        const btns = document.querySelectorAll("button"); // Получим псевдомассив со всеми кнопками.

        console.log(btns[0].classList.length); // 2  (класса <button class="blue some"></button>)
        console.log(btns[0].classList.item(0));   // 'blue' - получаем название класса, () - скобки нужны потому что метод
        console.log(btns[0].classList.item(1));     // "some" - второй класс
        
        console.log(btns[0].classList.add("red", "green")); //<button class="blue some red green"></button> добавление классов
        console.log(btns[0].classList.remove("blue")); //удаление класса, можно добалять и удалять несколько сразу
        console.log(btns[0].classList.toggle("blue")); // если класс есть на элем. его удалит, если нету добавит


    // Использование класса в условии. Мы не знаем на каком месте находится класс item(0) или item(1) для этого есть метод
        // contains - который проверяет наличие класса на всем элементе(возвращает true или false). 

        if (btns[0].classList.contains('red')){  //проверяем содержит ли элемент класс red, если да то выполнится код
            console.log("red");
        }


        // Таким образом часто добавляют динамически классы для выезжающего меню. Например при клике на кнопку добавляется класс
            // для менюшки и она показывается, а при повторном клике класс убирается и она скрывается. Тут мы при клике на первую
            // кнопку будем менять цвет второй кнопки.

            btns[0].addEventListener("click", ()=>{
                if(!btns[1].classList.contains("red")){ //проверяем отсутствие у второй кнопки класса red
                    btns[1].classList.add("red");       // добавим класс
                } else{
                    btns[1].classList.remove("red");    //если класс есть то удалим
            }
    
        // Можно использовать toggle, но иногда нужно вручную(через условие) проверить на класс в сложных скриптах
            btns[1].classList.toggle("red");
            });


    // Устаревший метод className выводит классы одной строкой и потом нужно для взаимодействия с этой строкой постоянно ее 
        // изменять что не удобно, а classList содержит псевдомассив с которым удобнее работать.
        console.log(btns[0].className);     // 'blue some'



    // +++ ДЕЛЕГИРОВАНИЕ СОБЫТИЙ - используется для назначения одного события на несколько элементов даже если они созданы без
        // *! нас(динамически). Назначаем обр. события на РОДИТЕЛЯ элементов, а при клике в этой области проверяем на что
        // (какой эл. внутри родителя) был клик и сравниваем с заданными параметрами(удостоверимся то клик был в кнопку).
        // Проверка производится и на существование тега на странице event.target и на его название(свойство) которое всегда пишется 
        // капсом event.target.tagName. Например в верстке есть тег <br>(перенос строки) - но на странице его не видно и по нему
        // невозможно кликнуть, поэтому для него сравнение event.target будет false и условие не сработает.
        
        // сравнивать можно с nodeName и classList - if(event.target && event.target.classList.contains("blue"))   

        const wrapper = document.querySelector(".btn-block"); //родитель кнопок <div id="first" class="btn-block">

        wrapper.addEventListener('click', function(event){
            if(event.target && event.target.tagName == "BUTTON"){//проверяем на существование тега и на равенство строке "BUTTON"
                console.log("Hello!");
            }
        });


        // Еще один способ который очень любят сотрудники гугла. вместо тагнейм или класснейм можем проверять на определенные
        // СОВПАДЕНИЯ. У event.target есть метод matches() - по простому это значит что какой то эл. совпадает с чем-то. Это
        // продвинутое делегирование потому что тут мы указываем селекторы которые нас интересуют. В данном случае событие 
        // сработает только на кнопках с классом red( созданной на лету далее), на остальных не работает, но когда вторая кнопка 
        // окрашивается в красный (к ней применяется класс red), то на ней тоже начинает срабатывать.

        wrapper.addEventListener('click', (event) => {
            if(event.target && event.target.matches("button.red")){ //совпадение тега баттон у которого есть класс ред
                console.log("Hello!");
            }
        });


        // Для проверки делегирования для кнопок созданных на лету создадим еще элемент кнопки. Если эл. подойдет под условие, то
        // делегирование сработает на нем. 
        
        const btn = document.createElement('button'); //создаем элемент
        btn.classList.add('red'); // добавляем ей класс ред что бы видеть ее на странице
        wrapper.append(btn);      //прикрепляем в элемент wrapper


        //*! Если кнопки созданы в скрипте динамически и к ним вместо делегирования применить перебор псевдомассива btns через 
        // forEach и назначение addEventListener с какой то ф-и на каждый эл. псевдомассива, то эта ф-я будет работать только
        // на тех эл. которые были в верстке, а не на динамически созданные.
       
        btns.forEach(btn => {
            btn.addEventListener('click', () => {
                console.log("Hello!");
            });
        });

}

{//  303    ====    Создание Табов (вкладок)    ====

    // Начинаем работать с новым проектом Project_food в папке 303 и напишем в нем один из самых часто встречающихся эл. 
        //на странице - ТАБЫ.

        // Откроем index.html и в конец body  подключим скрипт script.js. 
        // На странице есть меню справа от большой картинки Выберите стиль питания с элементами(ссылками/кнопками): Фитнес
        // Премиум Постное Сбалансированное. ЗАДАЧА - При нажатии на них большая картинка с описанием должны меняться
        // на соответствующее нажатой кнопке. Эта верстка уже есть, но она закоментирована, что бы не было каши на странице
        // (если раскоментировать то они покажутся все сразу и будут пытаться встать на одно и тоже место).
        
        // Этот функционал напишем вместе, а домашнее задание будет - пройтись по коду строчка за строчкой и разобрать что мы делали.

        // В проекте можно решить задачу разными способами и чаще всего выбирают между более понятным и более простым в работе
        // (или по параметрам скорости и нагрузки на программу) поэтому не стоит пугаться если увидим что эта задача решена
        // не так как у нас, это просто другой метод.


    // Начнем с самого главного - назначим глобальный обработчик события DOMContentLoaded.
        // Алгоритм работы нашего кода поделим на три задачи: 1) ф-я которая будет скрывать ненужные в этот момент табы;
        // 2) показать нужный таб; 3) назначить обработчики событий на кнопки меню которые и будут манипулировать этими
        // ф-ями.

        // Кликаем на кнопках меню и видим что класс у них tabheader__item, получим их псевдомассив в tabs. Раскоментируем табы
        // (картинки и описание)и посмотрим что класс у них tabcontent, получим их псевдомассив в tabsContent. Далее получим
        // родителя кнопок меню в tabsParent что бы использовать на нем делегирование, так мы назначим 1 обработчик события 
        // вместо множества и если кнопки будут добавляться в верстку динамически, то на них тоже будет работать обработчик.
        
        // В верстке у первой кнопки видим еще 1 класс tabheader__item_active - этот класс выделяет на странице кнопку на которую 
        // кликнули так что его нужно будет добавлять к кнопке по которой кликнули и удалять из других кнопок.

        // 1) Напишем ф-ю для скрытия табов hideTabContent. Перебираем псевдомассив с табами tabsContent и задаем инлайн стиль
        // для их скрытия item.style.display = "none";. Также в этой ф-и переберем псевдомассив с кнопками tabs и удалим у них 
        // стиль активности tabheader__item_active.

        // 2) ф-я для показа нужного таба showTabContent. В ее аргумент записываем i для того что бы знать к какому эл. нужно
        // обратиться. Покажем нужный таб через инлайн стили tabsContent[i].style.display ="block"; и добавим класс активности
        // tabs[i].classList.add("tabheader__item_active");

        // Ф-и готовы теперь нужно что бы при загрузке страницы скрылись все табы и показался только один, по дефолту первый под
        // индексом 0 в псевдомассиве, для этого нужно ф-и запустить(вызвать) hideTabContent(); showTabContent(0); 
        // Рассмотрим параметры по умолчанию появившиеся в ES6 так можно в самой ф-и указать дефолтное значение параметра,
        // если вдруг ф-ю вызвали без аргумента. Переставим 0 из вызова ф-и в её объявление function showTabContent(i = 0).

        // 3) Навешиваем обработчик события на родителя кнопок что бы работало делегирование. Если мы знаем что часто будем
        // использовать event.target; - мы его присвоим переменной для сокращения записи и легкости чтения. Прописываем условие
        // используем classList.contains("tabheader__item") - что бы избежать вызова ф-и при клике на пустое пространство вокруг
        // кнопок, а это был бы родительский эл. Логика действий - при клике на элемент его таргет сравнивается с элементом
        // псевдомассива кнопок и таким образом мы узнаем индекс эл. в псевдомассиве, что бы запустить ф-ю показа таба с этим
        // индексом предварительно запустив ф-ю скрытия табов, сделаем это через перебор forEach и условие для сравнения. Все
        // работает.

        // В реальных проектах через инфайн стили почти не работают, в основном используют classList для css стилей, так для
        // стилей можно добавить еще и анимацю, что невозможно при работе с инлайн стилями. КСС файл у нас в сжатом виде,
        // можно или добавить в него наши ксс классы или создать новый ксс файл и подключить его дополнительно к основному.
        // Я допишу в обычный ксс файл после margin:0 auto} вставлю .show{display:block} - добавляет поведение дисплей блок при
        // котором блок будет показываться .hide{display:none} - скрывает блок
        //.fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;}to{opacity: 1;}} - прописываем
        // класс fade с названием анимации fade и длительностью 1.5 сек. Создаем анимацию через ключевое слово keyframes с именем
        // fade и она будет увеличивать ПРОЗРАЧНОСТЬ(opacity) от 10%(0.1) до 100%(1).
        
        // Теперь вместо инлайн стилей будем использовать классы.
        // Вместо display = "none" - нужно добавить две строчки, один класс добавить для скрытия всех эл. item.classList.add("hide");
        // и удалить класс показа item.classList.remove("show");. Использовать toggle тут мы не можем потому что начнется каша при
        // переключении.
        // Тоже самое нужно сделать в showTabContent тут мы добавляем класс classList.add("show") и удаляем класс скрытия
        // classList.remove("hide"); Теперь для показа анимации нужно добавить класс fade classList.add("show", "fade");
        // вместе с классом показа, а в ф-и скрытия fade нужно удалить для того что бы при следующем назначении этого класса
        // на этот элемент анимация снова воспроизводилась item.classList.remove("show", "fade");

        

        {// Код для скрипта
        "use strict";
        
        window.addEventListener("DOMContentLoaded", ()=>{
        
        //получаем элементы в переменные
        const tabs = document.querySelectorAll(".tabheader__item"), //<div class="tabheader__item">Премиум</div> кнопки
              tabsContent = document.querySelectorAll(".tabcontent"),// <div class="tabcontent">
                                                                            // <img src="img/tabs/vegy.jpg" alt="vegy">
                                                                            // <div class="tabcontent__descr">
                                                                                    //Меню "Фитнес" - ...
                                                                            // </div>
            // родительский эл. для назначение обр. событий кнопкам динамически
               tabsParent = document.querySelector(".tabheader__items");//<div class="tabheader__item tabheader__item_active">Фитнес</div>
    
        // 1) Скрываем ненужные табы
        function hideTabContent (){
            tabsContent.forEach(item => {    //перебираем элементы и назначаем всем стиль
                //item.style.display = "none";
                item.classList.add("hide");     // Делаем через классы из css теперь две строчки
                item.classList.remove("show", "fade");
            });
            tabs.forEach(item => {
                item.classList.remove("tabheader__item_active");//удаляем подсветку активности кнопок
            });
        }
         
        // 2) Показываем нужный таб
        function showTabContent(i = 0){     // i = 0 - если вызвать функцию без аргумента то 0 будет подставлятся по дефолту
            //tabsContent[i].style.display ="block";
            tabsContent[i].classList.add("show", "fade");   // Делаем через классы из css теперь две строчки
            tabsContent[i].classList.remove("hide");
            tabs[i].classList.add("tabheader__item_active");
        }
    
        // При загрузке вызываем ф-и
        hideTabContent(); //скрываем все табы
        showTabContent(); //показываем 1 таб по дефолту обычно первый под номером 0  showTabContent(0)
    
        // 3) Присваиваем обработчик события для кнопок делегированием от родителя
        tabsParent.addEventListener("click", (event)=>{
            const target = event.target; //переменная для уменьшения писанины если нужно часто обращатся к евент
    
            if(target && target.classList.contains("tabheader__item")){
                tabs.forEach((item, i) => {
                    if(target == item){
                        hideTabContent(); 
                        showTabContent(i);
                    }
                });
            }
        });
        //Добавили в css такой код .show{display:block}.hide{display:none}
        //.fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;}to{opacity: 1;}}
    
        });
        }

}

{//  304    ====    Время выполнения скриптов, setTimeout & setInterval    ====

    // Разберем тему - управление временем выполнения скриптов. Бывает что нужно чтобы ф-я выполнилась не сразу, а через какой то
        // промежуток времени или ее выполнение повторялось через какое то время. Научимся это делать и напишем благодаря этому
        // простую JS анимацию.

    // Работать будем с файлами в папке 304 индекс + ксс

    // Все мы сталкивались с навязчивыми модельными окнами которые появляются на сайте через какое то время. Такой ф-ционал очень
        // часто будет встречаться в нашей работе. Связано это может быть не только с модальными окнами. Поэтому нам нужно уметь
        // работать с таким асинхронным кодом.

    
    // +++ setTimeout - чтобы запустить ф-ю через определенный промежуток времени.
        // Создаем переменную (она не обязательна) и ей присвеиваем setTimeout(); 1 аргумент - объявление ф-и function или
        // ее название, она не вызывается прямо здесь и сейчас; 2 арг. - время через которое начнется выполнение ф-ии в мс.
        // Напишем пример с анонимной ф-й(без названия, она просто объявляется). 1000 мс = 1 секунда
        
        const timerId = setTimeout(function(){
            console.log("Hello");
        }, 1000);
        

        // Также в эту конструкцию можно передавать аргументы ф-и. "Hello2" - 3 арг. который по синтаксису перейдет в арг. ф-ии
        // text. Такой синтаксис используется не часто. Дополнительных аргументов может быть бесконечное количество.

        const timerId2 = setTimeout(function(text){
            console.log(text);
        }, 2000, "Hello2");


        // Помимо аргументов можем передавать готовую ф-ю. Только название без круглых скобок, передаем. а не вызываем.
        const timerId3 = setTimeout(logger, 3000);
        
        function logger(){
            console.log("text");
        }

    // *! Ф-и setTimeout и setInterval будут работать и без присвоения их переменной, например setTimeout(logger, 3000); сработает
        // точно также. Но когда мы выполняем присваивание в переменную ложиться числовое значение: console.log(timerId); // 1
        // а для console.log(timerId2); // 2 - таймеры нумеруются. И так как мы теперь к ним по именам переменных можем обратиться
        // то сможем их остановить при необходимости.
        //ПРИМЕР - представим ситуацию когда заходим на гипотетический сайт, где через 30 сек должно показаться модальное окно, 
        // но если мы кликнули на кнопку - купить товар или заказать услугу, то этот таймер должен остановиться(сброситься), потому
        // что мы уже сделали то что от нас хотел сайт(разработчик).

        // Выполняется такой сброс(остановки) командой clearInterval() - в которую передаем имя переменной с нужным таймером.
        const timerId3 = setTimeout(logger, 3000);
        
        clearInterval(timerId3);

        function logger(){
            console.log("text");
        }



        // Напишем более реальный пример когда остановка таймера будет происходить после клика по кнопке. 
        // Получаем эл. кнопки по классу btn = document.querySelector(".btn").
        // Навешиваем обработчик события клика мыши btn.addEventListener("click", и внутрь помещаем
        // *! setInterval - эта ф-я заставляет ф-ю вызываться через какой то промежуток времени, синтаксис
        // у нее такой же, аргументы такие же и отменяется также как setTimeout. 
        // Но для остановки таймера нужно что бы переменная с таймером была глобальная, поэтому объявим ее до обработчика события
        // через let потому что будем ее менять и без присвоения значения сразу, его присвоим в ф-и.

        // Теперь при клике на кнопку каждые (logger, 2000)  2 секунды будем видеть текст в консоли.
        // Что б его остановить пропишем clearInterval(timerId4); но он не сработает потому что ф-я с интервалом запустится только 
        // после клика на кнопку и до этого момента timerId4 будет равен undefined, но браузер прочитает код и после обработчика 
        // события сразу попробует вызвать clearInterval(timerId4); а с undefined он не сработает. Поэтому нужно модернизировать 
        // наш код. В function logger() будем отслеживать сколько раз уже повторился setInterval и будем это значение присваивать 
        // глобальной переменной let i = 0; с начальным значением 0. Для увеличения i поставим i++; в logger и сделаем условие
        // если ф-я сработала 3 раза if (i === 3), то запустить clearInterval(timerId4); функция отработает 4 раза.

        const btn = document.querySelector(".btn"); //<button class="btn">Animation</button>
        let timerId4;
        let i = 0;
        
        btn.addEventListener("click", () => {
            //clearInterval()
            timerId4 = setInterval(logger, 2000); //Присваиваем значение сетинтервала таймеру через 2 секунды
        });

        //clearInterval(timerId4); не сработает потому что значение ему присвоится после клика. А текущее undefined

        function logger(){
                if (i === 3){
                    clearInterval(timerId4);
                }
                console.log("text");    // text text text text - выведет 4 раза и остановится
                i++;
            }



    // На собеседовании может быть вопрос - чем рекурсивный setTimeout лучше чем рекурсивный setInterval. Рекурсия - когда ф-я 
        // внутри вызывает сама себя. Она используется довольно часто, мы ее применяли в предыдущем проекте. setTimeout может 
        // внутри себя вызвать setTimeout еще раз когда закончится внешний, запустится внутренний и тд.

        // А если рекурсивный будет setInterval то он не будет ждать пока ф-я выполниться что бы запустить следующий setInterval
        // Тоесть когда таймер setInterval работает он не учитывает то время которое будет отрабатывать ф-я внутри него.
      
        // Например при времени повторения ф-и logger в 0.5 секунды, если logger будет выполнять сложные вычисления которые
        // потребуют времени например в 3 секунды, то setInterval не буедет ждать потом 0.5 секунды, потому что он считал это 
        // время во время выполнения ф-и logger 3х секунд, и он тут же запустит снова ф-ю logger считая что 500 прошли во время 
        // выполнения функции.
                
        // решение такой проблемы - рекурсивный setTimeout - работает как setInterval но всегда ждет отведенное ему время.
        // Ф-и присваиваем имя log что бы можно было к ней обращаться и после выполнения console.log("text"); мы замещаем 
        // переменную id таким же setTimeout с ф-й log в которой после срабатывания кода снова будет происходить замещение
        // таймера id. Поэтому переменную объявляют через let чтобы можно было ее перезаписать.
            let id = setTimeout(function log(){
                console.log("text");
                id = setTimeout(log, 500);
            }, 500);



    // +++ Перейдем к практике.
        // Видим синий квадрат в левом верхнем углу большого белого квадрата с красной границей. ЗАЧАДА сделать так чтобы
        // синий квадрат плавно меремещался в правый нижний угол по нажатии на кнопку. Сделаем эту анимачию через setInterval
        // это устаревший метод, сейчас есть новые методики но мы увидим применение setInterval.

        // Получим кнопку. Создадим общую ф-ю для запуска всей анимации при клике на кнопку myAnimation. В ней получим эл. box
        // по классу, это наш синий квадрат. Создадим переменную для хранения позиции квадрата и присвоим ей начальное значение 0.
        // Для движения квадрата создадим ф-ю frame которая будет запускаться через определенное время в id = setInterval(frame, 10);
        // В frame прописывем условие, в нем мы определяем что анимация закончилась при значении (pos == 300) и останавливаем
        // интервал если позиция равна 300 - clearInterval(); - в него передаем переменную id которая отвечает за запуск интервала
        // в ф-ии myAnimation clearInterval(id);
        // В блоке else (то есть когда анимация еще не закончена или начинается) будем выполнять pos++; - увеличение позиции на 1.
        // И для движения квадрата нужно ему через инлайн стили присваивать новую позицию. Так как квадрат у нас будет двигаться
        // по диагонали значит и отступ от верхнего и от левого края будет увеличиваться одинаково, поэтому присваиваем позицию
        // этим двум свойствам elem.style.top = pos + "px"; elem.style.left = pos + "px"; Так как в ксс прописана позиция квадрата
        // position: absolute; относительно родителя (белого квадрата position: relative;) то он и будет двигаться внутри белого
        // квадрата. (pos == 300) - высчитывается из размеров квадрата и родительского блока(белого квадрата), у синего размеры
        // width: 100px; height: 100px; размер 100 на 100, а размер родителя width: 400px; height: 400px; 400 на 400, поэтому 
        // сместить нужно на разницу между 400 - 100 пкс = 300 пкс. 
        
        // Теперь эту ф-ю будет вызывать id = setInterval(frame, 10); - можно поставить и меньше 10 мс, но что бы нормально
        // отрабатывал setInterval без багов, сама ф-я setInterval будет подставлять 4 мс - этот стандарт поддерживается всеми
        // браузерами.
        

        const btn = document.querySelector(".btn"); //получаем кнопку
        
        function myAnimation(){
            const elem = document.querySelector(".box"); //получаем элемент - синий квадрат <div class="box"></div>
            let pos = 0; //переменная позиции(устанавливаем начальную позицию)
        
            const id = setInterval(frame, 10);

            function frame() { // ф-я будет запускаться через определенный промежуток времени.
                if (pos == 300){ // .box { position: absolute; width: 100px; height: 100px; размер 100 на 100, размер обертки
                    //wrapper { position: relative; width: 400px; height: 400px; 400 на 400 чистой площади получается 300px
                    clearInterval(id);
                } else{
                    pos++;
                    elem.style.top = pos + "px";
                    elem.style.left = pos + "px";
                }
            }
        
        }
        
        btn.addEventListener("click", myAnimation);

    // Если много раз клацать на кнопку то квадратик будет дергаться, это потому что мы написали простейшую анимацию, более 
        // сложные анимации напишем дальше в курсе. А с появлением ксс3 в нем появились анимации которые удобнее прописать 
        // в ксс и чаще всего их и проиписывают в ксс, подвязываются к классам, а мы при помощи JS скриптов меняем эти классы
        // для нужных элементов как делали для табов с классом fade.

    

    {// Код для скрипта
        "use strict";

        // const timerId = setTimeout(function(){
        //     console.log("Hello");
        // }, 1000);
        
        // const timerId2 = setTimeout(function(text){
        //     console.log(text);
        // }, 2000, "Hello2");
        
        // const timerId3 = setTimeout(logger, 3000);
        // function logger(){
        //     console.log("text");
        // }
        

        // const btn = document.querySelector(".btn"); //<button class="btn">Animation</button>
        // let timerId4;
        // let i = 0;
        
        // btn.addEventListener("click", () => {
        //     //clearInterval()
        //     timerId4 = setInterval(logger, 500); //Присваиваем значение сетинтервала таймеру через 0,5 секунды
        // });
        // //clearInterval(timerId4) не сработает потому что значение ему присвоится после клика. А текущее undefined
        // //изменяем logger
        // function logger(){
        //         if (i === 3){
        //             clearInterval(timerId4);
        //         }
        //         console.log("text");
        //         i++;
        //     }

        
        const btn = document.querySelector(".btn"); //<button class="btn">Animation</button>
        
        function myAnimation(){
            const elem = document.querySelector(".box"); //получаем элемент - квадрат <div class="box"></div>
            let pos = 0; //переменная позиции
        
            const id = setInterval(frame, 10);
            function frame() {
                if (pos == 300){ // .box { position: absolute; width: 100px; height: 100px; размер 100 на 100, размер обертки
                    //wrapper { position: relative; width: 400px; height: 400px; 400 на 400 чистой площади получается 300px
                    clearInterval(id);
                } else{
                    pos++;
                    elem.style.top = pos + "px";
                    elem.style.left = pos + "px";
                }
            }
        
        }
        
        btn.addEventListener("click", myAnimation);
    }

}

{//  305    ====    Date    ====

    // Работа с объектом Даты обязательный навык потому что он может часто пригодиться. Например для измерения времени работы
        // ф-ии, если мы хотим засечь как быстро она работает и сравнить другой ф-ей. Таже можно использовать для таймера или
        // вывода текущей даты/часов на странице. Еще можно использовать для хранения времени создания какого то документа(это
        // уже больше Node.js, потому что наш нативный JS не умеет работать с файлами). В следующем уроке создадим на странице
        // таймер который будет работать на основе Date.


    // Создадим переменную и присвоим ей объект даты. Для этого воспользуемся конструктором new Date(); - при пустых скобках ()
        // будет показана текущая дата и время которая берется из системы. Показывается до милисекунд(у преподавателя показало
        // 2020-05-01Т11:09.26.7452) - он запускал в VSCode(в консоли или другого инструмента Дата может вернуться в формате
        // UTC) Сначала идет год-месяц-число, Т -разделитель и потом временные рамки.
        // Дата хранится в милисекундах и отсчитывается от 1970 года(тайм стемп). Это значит что дата может быть переведена в 
        // милисекунды, а милисекунды в дату.
        
        const now = new Date();
        console.log(now); // Wed Jun 29 2022 13:44:18 GMT+0300 (Восточная Европа, летнее время)



    // +++ При СОЗДАНИИ Даты мы можем передавать в нее аргументы. Например можно передать дату в виде СТРОКИ, это часто используется
        // если на странице есть input с типом даты type="date" он нам отдает дату которую мы можем передать в конструктор.
        // Передадим дату, видим что показывает нужную дату с нулем часов, потому что часы мы не передали.
        
        const now = new Date("2020.1.8");
        Date.parse("2020.1.8"); //работает идентично const now = new Date("2020.1.8");   *! но в милисекундах.
        const now = new Date("Wed Jun 29 2022");
        console.log(now); // Wed Jun 29 2022 00:00:00 GMT+0300 (Восточная Европа, летнее время)
        

        // Если передать таким образом(числа без нулей 01 -> 1), то получим 20 часов 1 число и 6 месяц, потому что месяц в Дате
        // считается с 0.
        const now = new Date(2020, 1, 8, 18); //18 часов, месяц и день указываем без 0.
        const now = new Date(2020, 5, 1, 20); // Mon Jun 01 2020 20:00:00 GMT+0300 (Восточная Европа, летнее время)


        //Часы могут показывать по гринвичу, а месяцы считаются с 0, 0-январь
        const now = new Date(0);//Дата (Тайм стемп) хранится в милисекундах. отсчет с начала 1970 года


        // Получить дату до 1970 года можно введя отрицательное значение
        const now = new Date(-999999999990) // Mon Apr 25 1938 01:13:20 GMT+0300 (Восточная Европа, летнее время)



    // +++ МЕТОДЫ ДАТЫ
        // Разберем основные(частоиспользуемые) методы
        const now = new Date();

        
        // *** ПОЛУЧЕНИЕ компонентов Даты(интересующего компонента)

        // Получение года. Всегда приходит число из 4х знаков. При передаче также это стоит помнить.
        console.log(now.getFullYear()); // 2022 

        console.log(now.getMonth());    // месяц считаются с 0, 0-январь
        console.log(now.getDate());     //число месяца
        console.log(now.getHours());    //часы
        console.log(now.getMinutes());  // минуты
        console.log(now.getDay());      // номер дня в неделе, воскресение - 0, понедельник - 1
       
        //Все эти значения возвращаются по местному часовому поясу, но если нужен другой часовой пояс по UTC - +0 часов, у всех
        // методов выше есть аналоги с добавлением слова UTC
        console.log(now.getHours());    // 14 часов (+3) - по местному
        console.log(now.getUTCHours()); // 11 часов (+0) - по Гринвичу


        // Получение разницы в минутах между UTC и местным  час.поясом в минутах
        console.log(now.getTimezoneOffset());   // -180


        // Возвращает количество милисекунд прошедших с начала 1970 года до сейчас. Его обратно можно превратить в дату 
        // поместив  в - const now = new Date(1656502672991); Этот метод часто используется.
        console.log(now.getTime());     // 1656502672991            



    // *** УСТАНОВКА  Даты
        // Тут используются все команды для получения даты только с приставкой set вместо get, кроме команды getTimezoneOffset.

        // Установим часы равные 18-00. После вывода в консоль показывается 18 вместо текущего времени.
        const now = new Date();  
        console.log(now);                   // Wed Jun 29 2022 14:43:08 GMT+0300 (Восточная Европа, летнее время)
        console.log(now.setHours(18));      // 1656517388749
        console.log(now);                   // Wed Jun 29 2022 18:43:08 GMT+0300 (Восточная Европа, летнее время)

        // Можно сразу передавать и другие компоненты, например передадим часы и минуты - но такой способ неочевиден, потому что
        // программист увидев setHours предположит что передаются только часы, поэтому так делать не всегда является хорошей
        // практикой.
        console.log(now.setHours(18, 40));  // Wed Jun 29 2022 18:40:22 GMT+0300 (Восточная Европа, летнее время)

        // При работе с датой у нее есть автоисправление, например если передать 40 часов из 24х суточных, то мы просто получим
        // дату через 40 часов, то есть 40 прибавится к текущим часам и получим следующий день и оставшееся количество часов как
        // если бы мы прибавляли к 24м.
        console.log(now.setHours(40));      // Thu Jun 30 2022 16:52:46 GMT+0300 (Восточная Европа, летнее время)



    // +++ ИЗМЕРЕНИЕ ПРОМЕЖУТКОВ ВРЕМЕНИ с помощью Даты.

        // Для этого нам не нужно отнимать Thu Jun 30 2022 16:52:46 GMT+0300 такие сложные синтаксисы друг от друга, да и мы 
        // все равно бы получили ошибку. Для этого у еас есть милисекунды внутри. Эти таймстемпы можем использовать напрямую, а
        // можем использовать динамическое преобразование поставив + перед объектом даты.

        // Пример - создадим переменную через let потому что она будет изменяться, и сделаем цикл что бы он хорошо нагрузил нашу
        // систему. Теперь создаем переменную end для того что бы засечь конец работы цикла. Так как end создаст дату когда
        // до нее дойдет очередь, тоесть после выполнения цикла, то и даты end и start будут разные, и отняв их друг от друга
        // можно увидеть сколько милисекунд выполнялся цикл. Такие операции еще называются бенчмарки, когда мы проверям
        // производительность скрипта(операции, ф-и, цикла). Они могут выглядеть сложнее но база должна выглядеть так начальное
        // время, время окончания и их разница.
        let start = new Date();
        
        for (let i = 0; i < 100000; i++){
            let some = i ** 3; // i возводим в степень 3
        }
        
        let end = new Date();
        alert(`Цикл выполнился за ${end - start} миллисекунд`);
        


    {// Код для скрипта
        "use strict";

        //const now = new Date();
        //const now = new Date("2020.1.8");
        //new Date.parse("2020.1.8"); //работает идентично const now = new Date("2020.1.8");
        //const now = new Date(2020, 1, 8, 18); //18 часов, месяц и день указываем без 0. 
        //Часы могут показывать по гринвичу, а месяцы считаются с 0, 0-январь
        //const now = new Date(0);//Дата (Тайм стемп) хранится в милисекундах. отсчет с начала 1970 года
        
        const now = new Date();
        // console.log(now.getFullYear()); //2022 год
        // console.log(now.getMonth()); // месяц считаются с 0, 0-январь
        // console.log(now.getDate()); //число
        // console.log(now.getHours());//часы
        // console.log(now.getMinutes());
        // console.log(now.getDay()); // номер дня в неделе, воскресение - 0, понедельник - 1
        // //Все значения по местному часовому поясу
        // console.log(now.getUTCHours()); // часовой пояс +0
        
        // console.log(now.getTimezoneOffset()); //разница в минутах между основным час.пояс. и местным
        // console.log(now.getTime()); //количество милисекунд с начала 1970 года
        
        //Для установки даты используем теже методы но с set
        //console.log(now.setHours(18)); // устанавливаем это время для переменной
        //console.log(now.setHours(40));//автоисправление
        //console.log(now);
        
        //Для измерения промежутков времени используем бенчмарк
        let start = new Date();
        
        for (let i = 0; i < 100000; i++){
            let some = i ** 3; // i возводим в степень 3
        }
        
        let end = new Date();
        alert(`Цикл выполнился за ${end - start} миллисекунд`);
    }   

}

{//  306    ====    Timer обратного отсчета    ====

    // Будем реализовывать таймер обратного отсчет внизу страницы в проекте Project_food в папке 303. В блоке - "Осталось до конца
        // акции" - есть заготовка таймера с отсчетом дни-часы-минуты-секунды.

        // В верстке есть блок таймер в котором есть миниблоки с дни-часы-минуты-секунды а в них есть span с уникальными id,
        // в них мы и будем подставлять значения секунд, минут, часов, дней.
        // <div class="timer">
        //    <div class="timer__block">
        //       <span id="days">12</span>


    // Алгоритм действий. 1) Нужна ф-я для установки таймера, получения элементов; 2) ф-я определяющая разницу между временем
        // которая установлена у пользователя и временем дедлайна(окончания таймера); 3) ф-я которая будет обновлять таймер
        // (данные на странице) для показа пользователю.

    // Таймер частое решение для сайтов. Есть честные таймеры которые отсчитавают реальное время. А есть таймеры на продажу,
        // они запоминают нас как пользователя при заходе на страницу и отсчитывают время ориентируясь только на нас. Наш 
        // таймер будет подходить под оба варианта, разница будет в начальной инициализации таймера.



    // Создадим переменную с датой отсчета const deadLine до какого времени будем считать.

    // Создаем ф-ю 2) (определяющая разницу между временем) getTimeRemaining принимать аргументом будет endtime - из переменной 
        //deadLine. создаем техническую переменную t поэтому возьмем простое имя, потому что будет существовать только в этой ф-и.
        // deadLine задали строкой "2022-07-20" - для того что бы рассмотреть как работать с таким типом данных, потому что он
        // может приходить из inputa с типом даты на странице(административной панели). От такой строки мы не можем отнять 
        // милисекунды, потому что будет ошибка. Для математических действий эту строку сначала нужно тоже превратить в милисек.
        // Date.parse(endtime) - методом парсинга, создаем текущую дату в млсек.  Date.parse(new Date()) и отнимаем от конечной.
        // Теперь в t будет разница в млсек. и ее нам нужно превратить в количество дни-часы-минуты-секунды. Для этого создаем
        // переменные под каждую категорию, 
        
        // Считаем дни days - нужно просто разделить t на количество млсек. в одном дне, и округлить до меньшего целого,
        // чтобы не получить дробные значения.  t делим на ( 1(1000) сек*60 в минуте*60 в часе*24 часов в дне).
        
        // Часы hours тоже округляем, получаем количество часов таким же делением t на милисекунды в одном часе и получим все 
        // часы, но все часы по 24 часа в день перешли в дни и нам нужно получить остаток часов который останется от дней,
        // его мы можем получить чере остаок от деления на 24 часа (% 24).
        // Этот хвостик часов будет не больше чем 24 часа из-за этой операции (автоматическая конвертация неполного дня).
        
        // Таким же спомобом получам и минуты minutes, получаем количество минут до заданой даты, теперь рассмотрим еще одну
        // запись вместо умножения всех элементов, а потом деления t на этот результат (t / (1000*60*60) можно было записывать
        // (t / 1000 / 60 / 60), эта запись аналогична, мы t делим сразу на сек, потом на минуты, потом на часы. Запишем именно
        // для минут ((t / 1000 / 60) % 60) - милисек делим на 1000 получаем секунды, и делим на 60 сек в минуте - получаем
        // минуты(так избавляемся от одних скобок, но если кто то будет читать наш код, то сразу логику будет проследить труднее),
        // теперь нужно брать остаок от деления на 60 минут в часе, получаем остаток минут которые не вошли в целые часы.

        // Секунды рассчитваем также, просто делим t на 1000 млсек и получаем секунды + берем остаток от деления на 60 сек в мин.

        // Мы получили переменные со значениями которые будут рассчитаны как оставшееся время таймера. Но они локальные и нам их
        // нужно вернуть из ф-и чтобы мы могли их поместить на страницу. Чтобы компактно вернуть эти переменные из ф-ии вернем их
        // объектом. В нем возвращаем и переменную t потому что она нам будет нужна чтобы следить когда остановить таймер, если
        // заданая дата и время прошло то разница дат в переменной t будет отрицательной(минусовой).


    // Создаем ф-ю setClock(selector, endtime) для 3) для установки нашего таймера на страницу(показа пользователю). В ней нам 
        // понадобится получить эл. на странице куда мы будем передавать значения таймера(selector) и наша дата окончания 
        // таймера (endtime). Создадим переменную для получения в нее главного (родительского) эл. со страницы, что бы потом
        // от него взять следующие вложенные(дочерние) эл. и меньше при этом писать timer = document.querySelector(selector)
        // передаем аргумент selector вместо конкретного класса ".timer" что бы потом иметь возможность прикрутить этот таймер
        // к другому элементу или использовать в другом проекте.
        // Теперь от этого родительского эл. получаем эл. для каждого значения по айди days = timer.querySelector("#days")
        // который присвоены нужным элементам.

        // Теперь прямо в этой же ф-ии создаем ф-ю для обновления значений каждую секунду updateClock. Создадим переменную
        // t для расчета времени прямо в эту секунду воспользуемся ф-й getTimeRemaining   const t = getTimeRemaining(endtime); 
        // в эту переменную придет объект с расчитанными данными на текущую секунду. Теперь поместим эти данные на страницу
        // через innerHTML(можно и через textContent) будем конкретному элементу полученному ранее присваивать значение из
        // одноименного свойства полученного в t объекта - days.innerHTML = t.days;. Теперь когда ф-я запустится она рассчитает
        // значения на текущую секунду и поместит их на страницу. Теперь для ежесекундного просчета в ф-и setClock сделаем
        // переменную timeInterval и в нее назначим таймер для вызова ф-и просчета каждую секунду updateClock
        // timeInterval = setInterval(updateClock, 1000). А в updateClock добавим условие для остановки таймера если
        // дата уже прошла if(t.total <=0){.


    // Проверим таймер запустив его и передав как селектор получение эл. по классу таймер - setClock(".timer", deadLine);
        // Вылезло 2 бага  1) - если часов и минут меньше 10 то частое требование что нужно подставлять 0 (09), 
        // 2) - при обновлении страницы таймер запускается только через секунду и мы видим таймер из верстки. Будем решать
        // эти задачи.


    // Решим второй баг. Почеиу так происходит - ф-я setClock запускается, создает переменные с данными и запускает setInterval
        // а он первый раз отработает только через секунду, поэтому видим значения из верстки в эту секунду простоя. Поэтому
        // что бы не ждать эту секунду мы запустим ф-ю updateClock(); первый раз вручную.

    // Задача с подставлением нуля сложнее. Посмотрим на строчки где мы устанавливаем цифры на страницу days.innerHTML = t.days;
        // на этом этапы мы можем проверить это число, проверить на значение(или увидеть сколько в нем символов) и если оно
        // будет меньше 10, то будем добавлять 0. Для этого напишем ф-ю помошник которая будет делать такое сравнение getZero.
        // Она будет принимать в себя число getZero(num) и сравнивать его через условие if (num >=0 && num <10), в нем мы 
        // проверяем что число плюсовое num >=0(мало ли какое число нам пришло) и при этом если оно меньше 10 будем подствалять
        // 0 через интерполяцию return `0${num}` -обратные бектики и возвращаем уже получается строку, но в данном случае нам это
        // не важно, потому что мы ее сразу показываем на странице, и она будет отображаться также как и число. А если число больше
        // 10 тогда просто его же и возвращаем return num;. Теперь что бы все это у нас работало при присвоении значения переменной
        // с элементом мы сделаем эту проверку подставя нашу ф-ю  -  days.innerHTML = getZero(t.days);



    {// Код скрипта
    "use strict";
    const deadLine = "2022-07-20"; //Строкой задаем время окончания, такие строки получают еще из инпута на сайтах
    
    
    function getTimeRemaining(endtime){
        const t = Date.parse(endtime) - Date.parse(new Date()), //Превращает строку в количество милисекунд для математических расчетов
        //Отнимаем текущую дату и получим число в милисекундах
              days = Math.floor(t / (1000*60*60*24)),//Переводим в дни, милисек делим на 1(1000) сек*60 в минуте*60 в часе*24 часов в дне
              //и Math.floor округляет это число до меньшего целого
              hours = Math.floor((t / (1000*60*60) % 24)),//Переводим в часы, и получаем остаток от деления на 24 часа, что бы не было
              //например 150 часов
              minutes = Math.floor((t / 1000 / 60) % 60),
              seconds = Math.floor((t / 1000) % 60);
              //Для возврата этих локальных переменных из фунции используем ретурн и выводим объектом
              return{
                "total": t,
                "days": days,
                "hours": hours,
                "minutes": minutes,
                "seconds": seconds
              };
    }
    
    //Функция помощник для подставления 0 если число часов/минут меньше 10
    function getZero(num) {
        if (num >= 0 && num < 10){
            return `0${num}`;
        }else{
            return num;
        }
    }
    
    //функция Устанавливает время на страницу
    function setClock(selector, endtime){
        //получаем элементы со страницы
        const timer = document.querySelector(selector),
              days = timer.querySelector("#days"), //<span id="days">12</span>
              hours = timer.querySelector("#hours"),
              minutes = timer.querySelector("#minutes"),
              seconds = timer.querySelector("#seconds"),
              timeInterval = setInterval(updateClock, 1000); //запускаем функцию каждую секунду
        
        updateClock(); //Запускаем вручную что бы пофиксить второй баг
        
        function updateClock () {  //функция обновления таймера
            const t = getTimeRemaining(endtime); //в переменную получаем объект из функции с расчетами на эту секунду  
    
            days.innerHTML = getZero(t.days);
            hours.innerHTML = getZero(t.hours);
            minutes.innerHTML = getZero(t.minutes);
            seconds.innerHTML = getZero(t.seconds);
    
            //Останавливаем таймер если время вышло
            if(t.total <= 0){
                clearInterval(timeInterval);
            }
        }
    }
    
    setClock(".timer", deadLine); //Запускаем таймер в селектор подставляем класс элемента в ендтайм дату которую задаем 
                                    // или откуда то получаем (панель управления, сервер)
    
                /* <div class="timer">
                        <div class="timer__block">
                            <span id="days">12</span>
                            дней
                        </div>
                        <div class="timer__block">
                            <span id="hours">20</span>
                            часов
                        </div>
                        <div class="timer__block">
                            <span id="minutes">56</span>
                            минут
                        </div>
                        <div class="timer__block">
                            <span id="seconds">20</span> */
    
    //Два бага нужно исправить 1) - если часов и минут меньше 10 то нужно подставлять 0 (09), 2) - при обновлении страницы таймер
    //запускается только через секунду и мы видим таймер из верстки
    }   

}

{//  307    ====    Параметры документа, окна (document/window/screen)    ====

    // Поговорим о браузере. Какие глобальные сущности в нем есть и как с ними работать.
   
    // В задании работаем с шаблоном в папке 307. 
    


    // +++ Существует несколько основных понятий в работе JS относительно человека.
        
    // *** DOCUMENT. С понятием document мы уже знакомы, мы уже получали из него эл. и мы поняли что по факту это объект который 
        // содержит всю ХТМЛ структуру(только в более сложном чем верстка варианте).


    // *** WINDOW. По факту - наше окно(браузера) в котором показывается документ. Если мы будем увеличивать консоль разработчика 
        // то у нас изменяется именно window (высота окошка через которое видим контент), а document не затрагивается. Тоже 
        // самое будет если изменять ширину браузера, виндоу меняется, а элемент по центру с текстом (document) не изменяется.


    // *** SCREEN. Используется на практике редко. Весь наш видимый МОНИТОР с системными панельками и остальным. Разный размер
        // монитора - разный скрин.


    // В консоли браузера можно посмотреть что содержит тот или иной элемент. Откроем например document, раскроем его и увидим
        // все теги которые есть в большой ХТМЛ коллекции All(пседомассив со всеми эл). В скрине и виндоу будут другие свойства.
        // Например window мы использовали когда навешивали на него обраб. соб. DOMContentLoaded.
        console.dir(document);

        

    // Перейдем к более конкретным эл. у которых есть свои значения которые нам нужно изучить. Посмотрим на картинку прикрепленную
        // к уроку и видим 8 свойств у кведрата с текстом(таким же как у нас в шиблоне), на практике не все из них часто
        // применяются. Рассмотрим наиболее частоприменяемые. Все они измеряются в пикселях, но в коде JS они пишутся без
        // единиц измерения.


    // *** clientWidth(ширина) и clientHeight(высота) эл + padding - (без border, margin, scroll(полоса прокрутки)). Потренируемся
        // на практике. Получим эл в переменную box. Получим ширину и высоту эл без марджинов width и height, в консоль
        // получили  405, 355. Смотрим в ксс файл там ширина 400 + 2 паддинга по 10 пкс. = 420 пкс. но так как есть еще
        // боковой скрол то он занимает 15 пкс, итого 420 - 15 = 405 пкс. С высотой также 350 + 20 - 15 = 355 пкс.

        const box = document.querySelector(".box");
        
        const width = box.clientWidth;      //в css width: 400px + 2 шт padding: 10px с боков - 15px скролл = 405
        const height = box.clientHeight;    // height: 350px;
    
        console.log(width, height);         //405, 355 
    
        //Если в css используется box-sizing: border-box; включает padding в середину box в ширину и высоту эл. Теперь
        // общая ширина будет не 420, а 400 и отняв 15 пкс. полосы прокрутки получим = 385 пкс. В реальных проектах обычно
        // это свойство используется.
        console.log(width, height);         //385, 335 
    
        // Главный вопрос зачем нам получать эту ширину и высоту. В ксс могут использоваться разные параметры(%, vh, vw)
        // тоесть относительные величины которые ориентируются на монитор пользователя, в таком случае мы не можем получить
        // определенное число пикселей прямо из стилей и нам нужно получать их из уже построенного элемента. Таким образом
        // мы можем например увеличить высоту эл в два раза для добавления нового контента, все будет зависеть от нашей задачи.


    // *** offsetWidth и offsetHeight эл.  + padding + border + margin + scroll. Получаем те свойства которые и были установлены в
        // ксс файле. Но если посмотреть на высоту то скролом можно прокрутить контент и реальная высота контента будет больше,
        // а это получается видимая в данный момент высота.
        
        const owidth = box.offsetWidth; //свойство из css width: 400px 
        let oheight = box.offsetHeight;
        console.log(owidth, oheight); //400, 350
    

    // *** scrollWidth и scrollHeight. Получаем всю ширину или высоту объекта(даже не видимую в данный момент), на которую можно 
        //прокрутить скролом. Обычно используют высоту, потому что редко какой сайт скролится в ширину(горизонтально).
        
        const swidth = box.scrollWidth; // размер - скролл
        let sheight = box.scrollHeight; // размер всего текста(который можно скролить в этом окне)
        console.log(swidth, sheight); //385, 1352 

        // Теперь мы можем реализовать такую задачу - при клике на кнопку под эл. он полностью раскрывается на всю высоту контента
        // (показывает всю скрытую часть текста). Для этого получим эл. кнопки и повесим на нее обр. соб. при клике будем 
        // модифицировать box. Обратимся к его инлайн стилю и в него запишем число полученное из эл. + "px" что бы оно сработало.
        
        // *** Часто при этом используются свойства scrollTop или scrollLeft - эти значения помогут нам узнать сколько есть
        // пролистанного контента который уже не показывается(невидим), благодаря этим свойствам можно делать различный
        // интерактив при прокрутке страницы, например показывать прогресс, сколько пользователь пролистал нашей страницы.
        // *! все предыдущие свойства мы могли только получать из эл. а scrollTop или scrollLeft мы можем задать.
        
        let btn = document.querySelector("button");
        btn.addEventListener("click", () => {
            box.style.height = box.scrollHeight + "px"; //показываем весь текст
            box.style.width = 800 + "px";
            console.log(box.scrollTop); //показывает сколько проскроллил пользователь текста( отстчет над скролом) в пикселях
        });                             // по нажатию на кнопку.
    

    // +++ КООРДИНАТЫ
    // Часто на практике нам нужно получать координаты эл. на странице, потому что в JS они рассчитаваются не так как в ксс, а от 
        // левого верхнего угла экрана. Метод получающий объект эл. с координатами, причем некоторые браузеры могут добавлять
        // какие-то параметры, например  x: 440 y: 50.

        console.log(box.getBoundingClientRect()); // bottom: 400 height: 350 left: 440 right: 840 top: 50 width: 400 x: 440 y: 50
        
        // При этом в JS расчет идет от левого верхнего угла а в css от границы, например: css right отсчитывался бы от правой 
        // границы окна до правой границы элем., а в JS right отсчитывается от левой границы окна до правой границы элемента
        // bottom css - от низа окна до элем, а в JS от верхней окна до нижней элемента bottom: 400 = высота 350 + margin-top: 50px;
        
        // Так как мы получаем объект, то можно обратиться к конкретному его свойству
        console.log(box.getBoundingClientRect().top); //значение top - 50
    

    // +++ СТИЛИ
    // Иногда нужно получить стили которые применены к этому эл. Например для работы нашего скрипта нам нужно знать показан эл.
        // в данный момент на странице или нет, какой у него указан display в ксс и уже на основании этого при помощи условия
        // сформировать нашу структуру. 
        // Метод опеределяет какие стили css были применены(расчитаны/computed) на элем. изначально до применения скрипта.
        // Например  display. *! ИХ можно только получить это значени но не изменить его в css, изменяем стили только инлайн
        // которые в верстке, перебивая css. getComputedStyle - стили которые уже применены к элементу, в них разные параметры
        // например ширины или высоты могут не совпадать с теми что заданы в ксс файле ( потому что в ксс могли быть заданы в 
        // % или vh, или margin: auto; , а тут они будут с конкретным значением в пикселях). 
        // Их можно посмотреть в панели разраб. вкладка Elements выбрать элемента и смотреть справа  вкладку Computed.
        
        const style = window.getComputedStyle(box); // получаем объект из элемента 

        // Можно также обратиться к конкретном свойству
        console.log(style.display); // block
        
        // *! При помощи этого метода мы можем получить стили псевдоэл. В JS мы не можем работать с псевдоэл. потому что мы никак
        // не можем их получить со страницы(это прописано в стандарте, на момент записи урока у нас нет возможности просто так
        // работать с псевдоэл.), но стили псевдоэл. мы получить можем. Для этого нужно указать псевдоэл. вторым аргументом.
        // Например если бы у box был псведоэл, мы бы его указали вторым аргументом и получили бы его стили.
        const style = window.getComputedStyle(box, псевдоэл.);


        // Некоторые путают Computed стили с инлайн стилями. Computed - идут из ксс и будут на странице изначально, а то что мы
        // задаем через .style. это уже инлайн стили, они появляются внутри верстки и прописываются прямо в тег. По правилам
        // версти инлайн стили имеют самый большой приоритет по сравнению с другими стилями, поэтому когда мы задаем инлайн стиль
        // мы всегда перебиваем стиль который есть в ксс. Инлайн мы помеж получить, изменить, удалить, а Computed только получить
        // и проверить в каком-то условии.



    // МЕТРИКИ DOCUMENT и WINDOW
    // У document нету свойства scrollTop, поэтому мы не можем обратиться document.scrollTop для понимания сколько страницы было 
        // пролистано. Для обращения к свойству scrollTop в document нужно обращатся к его елементу.

        console.log(document.documentElement.scrollTop);
        console.log(document.documentElement.clientWidth);
        
        // scrollTop/csrollLeft можно изменять ВРУЧНУЮ в консоли а другие нельзя, таким образом можно сделать стрелочку для 
        // быстрого перехода. !* Указывается в пикселях.
        document.documentElement.scrollTop = 0; // закинет на начало страницы


        //  Методы window которые занимаются модифицированием положения страницы.
        // Аргументы (х, у). Х - по горизонтали, У - положение по вертикали.

        window.scrollBy(0, 400) // скролит на 400 относительно текущей позиции 

        window.scrollTo(0, 400) // скролит на 400 относительно всей страницы.

}

{//  308    ====    Создание модального окна    ====

    // Практикуемся на проекте Project_food в папке 303
    
    // Создадим модальное окно и назначим его вызов на несколько триггеров(эл. которые вызывают последующее действие). Триггерами
        // на сайте будут две кнопки белая и черная "Связаться с нами". Модальное окно находиться в верстке но скрыто потому что 
        // у него ксс свойство display: none. У триггером могут быть разные классы и даже теги поэтому для того что бы пометить 
        // что они вызывают одно и тоже действие им назначают одинаковый дейта(дата) аттрибут(прописываем в верстке data-modal)  
        // для обеих кнопок (название после data- можно придумать любое). Теперь с помощью этого селектора будем получать только
        // те эл. которые ответственны за вызов этого модального окна. Такое же действие проведем и для эл. который будет закрывать
        // модальное окно. Пропишем data-close в верстку эл. - крестик у модального окна(находим по верстке в браузере сделав
        // перед этим модальное окно видимым(убрав display: none в стилях справа)).



    // Определим переменные и получим в них нужные эл. Модальное окно для изменения его видимости инлайн стилем, кнопки тригеры
        // псевдомассив и кнопка закрытия. *! Используем квадратные скобки что бы обратится к аттрибуту.
        const modal = document.querySelector(".modal"),
              modalTrigger = document.querySelectorAll("[data-modal]"), 
              modalCloseBtn = document.querySelector("[data-close]");



    // Алгоритм работы скрипта. Нам понадобится только две ф-ии. 1) будет открывать модальное окно; 2) будет его закрывать.
        // Обработчики событий нужно подвязать сразу на несколько триггеров что бы срабатывала ф-я при нажатии на любой из них.



    // Пока что запишем в формате обработчиков событий, не зная будем в будущем переиспользовать эти ф-и или нет. Для тестирования
        // работоспособности ф-и  возьмем один эл.(первую кнопку) открытия модального окна.
        modalTrigger = document.querySelector("[data-modal]");

        // При клике на кнопку будем изменять инлайн стили которые ранее прописали в ксс файле ( .show{display:block}
        // .hide{display:none}.fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;} 
        // to{opacity: 1;}} ). Будем добавлять класс show и удалять класс hide (тут можно использовать вариант с toggle, потому
        // что класс hide будет изначально установлен и мы это будем знать), но так как в верстке мы такого свойства 
        // прописаного в инлайн стиль не видим то будем отталкиваться от этой схемы.
        
        modalTrigger.addEventListener("click", () => {
            modal.classList.add("show");
            modal.classList.remove("hide");
        });

        // Теперь сделаем ф-ю на закрытие 
        modalCloseBtn.addEventListener("click", () => {
            modal.classList.add("hide");
            modal.classList.remove("show");
        });

        // Проверяем - все работает. 
        


    //Но многое еще нужно доработать. Например когда модальное окно открыто, мы все равно можем скролить сайт, многие заказчики
        //  не хотят такое поведение, им нужно что бы страница была зафиксирована пока пользователь  видит модальное окно,
        // особенно если в модальном окне тоже будет скролл(полоса прокрутки). Помним что за скролл отвечает ксс свойство 
        // overflow, его мы и будем использовать. Обращаемся к нем и устанавливаем в hidden тогда скролл скрывается и сайт не
        // прокручивается. А когда закрываем МО(мод. окно) - нужно восстановить скролл, допишем в закрывающую ф-ю 
        // document.body.style.overflow = "" - с пустыми кавычками, браузер сам решит что нужно подставить.
        modalTrigger.addEventListener("click", ()=>{
            modal.classList.add("show");
            modal.classList.remove("hide");
            document.body.style.overflow = "hidden";
        });
        
        modalCloseBtn.addEventListener("click", ()=>{
            modal.classList.add("hide");
            modal.classList.remove("show");
            document.body.style.overflow = ""; //оставляем пустые скобки и браузер сам возвращает дефолт для прокрутки страницы
        });
    


    // Используем toggle. При этом нужно контролировать что бы по умолчанию класс hide применялся к эл., а в ксс было установлено
        // свойство display: none;
        modalTrigger.addEventListener("click", ()=>{
            modal.classList.toggle("show");     //если класса нет - добавит, если есть уберет
            document.body.style.overflow = "hidden";
        });
    
        modalCloseBtn.addEventListener("click", ()=>{
            modal.classList.toggle("show");
            document.body.style.overflow = ""; 
        });
    
    

    // Теперь навесим обр. соб. на все кнопки. Для этого вернем querySelectorAll в modalTrigger. И для обращения к этим эл. в
        // псевдомассиве нужно его перебрать, потому что прямо на псведом. навесить обр. соб. нельзя - будет ошибка.
        modalTrigger = document.querySelectorAll("[data-modal]"), 

        modalTrigger.forEach(btn => {
            btn.addEventListener("click", ()=>{
                modal.classList.add("show");
                modal.classList.remove("hide");
                document.body.style.overflow = "hidden";
            });
        });



    // Некоторые заказчики требуют чтобы можно было закрывать МО по клику на подложку (часть экрана вне МО) или клавише Esc.
        // Для этого найдем подложку(темную часть). Вызовем МО и посмотрим через элементы, видно что есть эл. modal__dialog
        // который служит оберткой для КОНТЕНТА МО (оранжевая подсветка) клик по нему сработает, только если кникнуть на 
        // белую форму МО в нем - "modal__content" - это само белое поле МО. И есть эл. который относится к МО div с классом
        // "modal" (бирюзовая подсветка) - это оберка ВСЕГО модального окна. Таким образом мы можем отследить куда 
        // кликнул пользователь используя event.target. То есть если клик был на бирюзовом элементе "modal  show" то считается
        // то кликнули на подложку и можно закрыть окно.

        modal.addEventListener("click", (e) => {
            if(e.target === modal){    //проверяем на строгое равенство объекта по которому кликнули объекту modal
                modal.classList.add("hide");
                modal.classList.remove("show");
                document.body.style.overflow = ""; 
            }
        });

        // Редко можно встретить такой некачественно написанный код, когда event(e) - не пишут в скобках ф-ии, а в теле ф-ии
        // далее прописывают event.target. Это будет работать (event объявлен, но приэтом мы его не передавали в ф-ю) в нашем 
        // проекте, но НЕ везде будет работать, потому что мы отходим от стандарта, и строго привязываемся к названию event, 
        // нарушаем логику кода. Нужно четко говорить что (e) мы используем
            // modal.addEventListener("click", () => {
            //     if(event.target === modal){



    // Рассмотрим важное правило программирования Don't Repeat yourself (DRY) - мы не должны повторять код, если он повторяется 
        // хотя бы два раза нужно его вынести в отдельную функцию. Прописываем ф-ю и потом передаем ее туда где она должна
        // использовать.
        function closeModal(){
            modal.classList.add("hide");
            modal.classList.remove("show");
            document.body.style.overflow = ""; 
        }
        
        modalCloseBtn.addEventListener("click", closeModal); // тут просто передаем функцию без вызова( без скобок () )
        
        modal.addEventListener("click", (e)=>{
            if(e.target === modal){    //проверяем строгое равенство объекта по которому кликнули объекту modal
                closeModal();          // тут вызываем функцию
            }
        });
        
        
        
    //Реализуем закрытие по кнопке Esc клавиатуры. Коды кнопок можно найти - keycode.info или learn.javascript.ru/keyboard-events
        // Событие для отлавливания нажатия клавиш на клавиатуре - keydown(срабатывает сразу при нажатии кнопки). Навешивать его
        // будем на весь документ, а не на определенный эл.  document.addEventListener("keydown", . Тут снова будет использовать
        // свойство объекта события код(e.code) - это код клавиши. В условие добавим проверку на открытое МО чтобы не вызывать
        // ф-ю при закрытом МО  -  && modal.classList.contains("show"))
        
        document.addEventListener("keydown", (e)=>{
            if(e.code === "Escape" && modal.classList.contains("show")){//если код события строго равен Escape(обозначение кнопки Esc)
                closeModal();           // вызываем функцию
            }
        });
    
    // В следующем уроке мы модернизируем это МО.


    {// Код скрипта
    "use strict";
    // По нажатии двух разных кнопок будет выскакивать пока еще скрытое модальное окно <div class="modal">
        // Кнопки с разными аттрибутами и поэтому мы их объеденим одним дата аттрибутом data-modal, допишем в верстку этот селектор
        // <button data-modal class="btn btn_dark">Связаться с нами</button>. Для закрытия окна после вызова(показа) прописываем 
        // в закрывающем элементе data-close  <div data-close class="modal__close">&times;</div>  - это крестик
        const modal = document.querySelector(".modal"),
              modalTrigger = document.querySelectorAll("[data-modal]"), // *! квадратные скобки что бы обратится к аттрибуту
              modalCloseBtn = document.querySelector("[data-close]");

    // Проверяем функционал выбирая только первую кнопку modalTrigger = document.querySelector("[data-modal]"),
    // добавляем и убираем стили которые раньше прописали в css .show{display:block}.hide{display:none}
    // .fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;}to{opacity: 1;}}     
    
    // modalTrigger.addEventListener("click", ()=>{
    //     modal.classList.add("show");
    //     modal.classList.remove("hide");
    //     document.body.style.overflow = "hidden";
    // });
    
    // modalCloseBtn.addEventListener("click", ()=>{
    //     modal.classList.add("hide");
    //     modal.classList.remove("show");
    //     document.body.style.overflow = ""; //оставляем пустые скобки и браузер сам возвращает дефолт для прокрутки страницы
    // });
    
    //Страницу можно пролистывать не закрывая окно, многим заказчикам это не нужно. Нужно зафиксировать страницу скрывая скролл
    // document.body.style.overflow = "hidden";
    


    //Делаем через toggle контролируя свойство display через стиль show
    // modalTrigger.addEventListener("click", ()=>{
    //     modal.classList.toggle("show"); //если класса нет - добавит, если есть уберет
    //     document.body.style.overflow = "hidden";
    // });
    
    // modalCloseBtn.addEventListener("click", ()=>{
    //     modal.classList.toggle("show");
    //     document.body.style.overflow = ""; //оставляем пустые скобки и браузер сам возвращает дефолт для прокрутки страницы
    // });
    


    //Создаем функцию для перебора кнопок при querySelectorAll
    modalTrigger.forEach(btn =>{
        btn.addEventListener("click", ()=>{
            modal.classList.add("show");
            modal.classList.remove("hide");
            document.body.style.overflow = "hidden";
        });
    });
    
    // modalCloseBtn.addEventListener("click", ()=>{
    //     modal.classList.add("hide");
    //     modal.classList.remove("show");
    //     document.body.style.overflow = ""; 
    // });
    


    //реализуем закрытие окна по клику на подложку(темную часть) и по кнопке Esc клавиатуры
    //<div class="modal"> - подложка (обертка) (темная)
    //   <div class="modal__dialog"> - область окна (светлая) - вложена в подложку(обертку)
    //єл. подложки в переменной modal
    // modal.addEventListener("click", (e)=>{
    //     if(e.target === modal){    //проверяем строгое равенство объекта по которому кликнули объекту modal
    //         modal.classList.add("hide");
    //         modal.classList.remove("show");
    //         document.body.style.overflow = ""; 
    //     }
    // });
    
    //Можно встретить такой код, но это НЕ везде будет работать, строго привязываемся к названию event, нарушаем логику кода
    //нужно четко говорить что (e) мы используем
    // modal.addEventListener("click", ()=>{
    //     if(event.target === modal){
    
    //Правило Don't Repeat yourself (DRY) если код повторяется нужно его вынести в одну функцию
    function closeModal(){
        modal.classList.add("hide");
        modal.classList.remove("show");
        document.body.style.overflow = ""; 
    }
    
    modalCloseBtn.addEventListener("click", closeModal); // тут просто передаем функцию
    
    modal.addEventListener("click", (e)=>{
        if(e.target === modal){    //проверяем строгое равенство объекта по которому кликнули объекту modal
            closeModal();          // тут вызываем функцию
        }
    });
    
    //Реализуем закрытие по кнопке Esc клавиатуры (Коды кнопок  keycode.info или learn.javascript.ru/keyboard-events)
    document.addEventListener("keydown", (e)=>{
        if(e.code === "Escape" && modal.classList.contains("show")){//если код события строго равен Escape(обозначение кнопки Esc)
            closeModal();           // вызываем функцию
        }
    });
    //что бы closeModal(); по Esc срабатывал только когда открыто окно modal.classList.contains("show")
    }

}



{//  309    ====    Модификация модального окна    ====

    // Модифицируем модальное окно(МО) на проекте Project_food в папке 303.
    
    // Задача - показывать модальное окно когда пользователь долистал страницу до конца или прошло определенное время.


    // Сначала выполним задачу со временем через setTimeout. Создадим переменную modalTimerId и в нее поместим setTimeout();
        // в setTimeout нужно поместить ф-ю открытия МО. Но она у нас не создана, а работает через перебор forEach для разных
        // кнопок. Значит нам нужно эту ф-ю сделать(вынести код в отдельную ф-ю). А перебор упрощаем передав туда только имя
        // ф-и вместо кода. Теперь в setTimeout передаем имя этой ф-и и установим 3 сек для того что бы видеть что она работает.
        // Дорабатываем openModal что бы если пользователь сам открыл окно, таймер отменялся дописав в openModal - clearInterval
        const modalTimerId = setTimeout(openModal, 3_000);

        function openModal() {
            modal.classList.add("show");
            modal.classList.remove("hide");
            document.body.style.overflow = "hidden";
            //Дорабатываем openModal что бы если пользователь сам открыл окно, таймер отменялся
            clearInterval(modalTimerId); //Timeout отменяет также как и интервал
        }

        modalTrigger.forEach(btn =>{
            btn.addEventListener("click", openModal);
        });



    // Задачу с показом МО при долистывании страницы до конца будем выполнять через рассмотренные в 307 уроке метрики. Для
        // отслеживания скроллинга пользователя используется событие scroll которое вешается на глобальный объект window.
        // Как всегда для начала создадим скрипт в простом(работоспособном) варианте, а потом будем его улучшать. Тут есть
        // несколько вариантов решения задачи, но мы воспользуемся свойством pageYOffset - отслеживает сколько пкс. по оси у
        // вертикаль у нас уже отлистал пользователь. Возьмем эту часть проскролленого(невидимого сейчас) контента + видимый
        // контент(тот что сейчас на мониторе) clientHeight и будем сравнивать с ООБЩЕЙ(всей) высотой контента scrollHeight
        // который есть, если сумма будет больше или равна (scrollHeight - 1) тогда показываем МО. (scrollHeight - 1) - взято
        // так потому что при обычном числе пкс scrollHeight сумма точно не будет больше, а при обычном равенстве == скрипт
        // может не сработать из-за особенностей некоторых браузеров и мониторов.
        
        window.addEventListener("scroll", () => {
            if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
                openModal();
            }   //pageYOffset - проскролленая часть + clientHeight - видимая часть на мониторе будут больше или равны
                // или больше scrollHeight все области скролла, минус 1 пиксель из-за особенности некоторых браузеров и мониторов
        },{once: true});


        // Теперь у нас каждый раз показывается МО при долистывании страницы и это навязчивое поведение. Что бы его исключить и
        // показать МО только раз - доработаем скрипт. Первое что приходит на ум это настройки обработчика событий, где можно
        // указать что его нужно выполнить 1 раз, записываются они после ф-и  ,{once: true}); Но после такой записи видим что 
        // МО вообще перестало показываться при доскроливании до конца страницы, так происходит потому что мы повесили событие
        // scroll на window, это значит что событие происходит каждый раз когда мы хоть немного трогаем скролл на мышке, и
        // как только мы один раз листнем страницу, обработчик события отработал(сравнил сумму и высоту контента, они оказались
        // не равны и он окно не показал) и больше не будет запускаться, поэтому такой способ тут на подходит.
        // Теперь вспоминаем что мы можем удалить обр. соб.(*! только если ему передается ф-я по имени) как только он покажет МО. 
        // Для этого создадим ф-ю showModalByScroll и внутрь поместим весь код из обр. соб. и добавим условие что после показа МО 
        //  этот обр. соб. будет удален. А ф-ю передадим по имени в обр. соб. скролл. Для удаления обр. соб. нужно в скобках
        // прописать тот же текст что и при назначении, то есть событие и имя ф-и - 
        //  window.removeEventListener("scroll", showModalByScroll);
        
        function showModalByScroll() {
            if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
                openModal();
                window.removeEventListener("scroll", showModalByScroll);
            } 
        }

        window.addEventListener("scroll", showModalByScroll);



    {// Мое решение 309
            
    function openByTime() {
        modal.classList.add("show");
        modal.classList.remove("hide");
        document.body.style.overflow = "hidden";
    };

    const openTimer = setTimeout(openByTime, 5000);
    
    const timerEndPage = setInterval((once) => {
        if(document.documentElement.scrollTop >= 3550) {
            openByTime();
            clearInterval(timerEndPage);
        } else {
            console.log("Not the end")
        }
    }, 1000);

    }



    {"use strict";
    //<<<<<<<009 Модальное окно должно появится через определенное время или когда пользователь долистал страницу до конца >>>>>
    // const modalTimerId = setTimeout();
    
    //Создаем функцию для открытия окна преобразуя modalTrigger.forEach(btn =>{
    function openModal() {
        modal.classList.add("show");
        modal.classList.remove("hide");
        document.body.style.overflow = "hidden";
        //Дорабатываем openModal что бы если пользователь сам открыл окно, таймер отменялся
        clearInterval(modalTimerId); //Timeout отменяет также как и интервал
    }
    
    modalTrigger.forEach(btn =>{
        btn.addEventListener("click", openModal);
    });
    
    const modalTimerId = setTimeout(openModal, 5000);
    
    function showModalByScroll() {
        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
            openModal();
            window.removeEventListener("scroll", showModalByScroll);
        } 
    }
    
    //Делаем что бы окно показывалось при долистывании страницы до конца
        // window.addEventListener("scroll", ()=>{
        //     if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
        //         openModal();
        //     }   //pageYOffset - проскролленая часть + clientHeight - видимая часть на мониторе будут больше или равны
        //         // или больше scrollHeight все области скролла, минус 1 пиксель из-за особенности некоторых браузеров и мониторов
        // }//,{once: true});
    
    // Что бы не запускалось много раз окно при доскроле до конца страницы можно использовать настройки обработчика событий
        // после функции можно добавить {once: true}, но оно в данном случае не сработает потому что обработчик повешен на скролл
        // тоесть оно срабатывает при скроле, но условия не выполняются и окно не появляется, а внизу страницы не запускается
        //п отому что уже как бы сработало

    // ВТОРОЙ способ будем удалять обработчик события с виндовс после 1 разового выполнения removeEventListener для этого
        // создаем функцию showModalByScroll и там прописываем ремув, и модифицируем window.addEventListener
        window.addEventListener("scroll", showModalByScroll);
        }
    
}



{//  310    ====    Функции конструкторы    ====

    // Ф-я по своей сути является объектом и в нее можно записать свойства и методы.



    // +++ ДЛИННЫЙ синтаксис
    // Существует ДЛИННЫЙ синтаксис для создания типов данных начинается с ключевого слово new
        
        const num = new Number(3); // Number {3}  
        // Если раскрыть получим Number  __proto__: Number [[PrimitiveValue]]: 3 , намбер с велью 3
   

    // Тоже можно сделать и с функцией
        const func = new Function(3);   //ƒ anonymous() {3}
        //Если такая функция будет содержать методы и свойства то она создаст нам новый объект.
    


    // +++ НОВЫЙ синтаксис 
    // Для каждого отдельного пользова. будем указывать свое уникальное имя и номер(которые берем из аргументов ф-и). При этом
        // это свойство будет общим this.human = true;. Когда присваиваем ф-ю в переменную через ключ. слово new наша функция 
        // становится КОНСТРУКТОРОМ и с помощью нее можно создавать новые (ОБЪЕКТЫ) пользователей с теми свойствами которые мы
        // ей передали. В таких ф-ях нм не нужен return мы из ф-ии ничего не возвращаем.

        function User(name, id) {
            this.name = name;
            this.id = id;
            this.human = true;
            this.hello = function() {
                console.log(`Hello ${this.name}`);
            };
        }

        const ivan = new User ("Ivan", 28); // User {name: 'Ivan', id: 28, human: true, hello: ƒ}
        const alex = new User ("Alex", 20); // User {name: "Alex", id: 20, human: true, hello: ƒ}
        alex.hello();  // Hello Alex
        ivan.hello();  // Hello Ivan



    // C помощью prototype можно добавлять свойства и методы в конструктор и они наследуются потомками. Этот прием используется
        // когда нету доступа к прототипу конструктору) или его нельзя менять но нужно немного модифицировать. Указываем не
        // прототип как это было в setPrototypeOf когда одно наследуется от другого, а просто добавляем свойства или методы в 
        // УЖЕ существеющий обюект.
        
        User.prototype.exit = function(){
            console.log(`Пользователь ${this.name} ушел`);
        };
        
        // Этот метод появится у всех потомков которые будут созданы ПОСЛЕ объявления(создания) метода
        alex.exit();    // Пользователь Alex ушел
    

    
    // Такие конструкторы нам нужны для создания новых однотипных объектов (новые пользователи сайта, товары в магазинах, ролики
        // на ютубе) - везде где есть шаблонизация. Даже компоненты сайтом можно создавать таким образом, например есть слайдеры
        // на сайте, в одном 5 слайдов в другом 10, один использует автопереключение, второй нет - соответственно эти разные
        // параметры можно задавать как аргументы для такого конструктора и потом конструировать разные слайдеры с одинаковыми
        // главными свойствами и методами.



    //Это был ЕС5, в ЕС6 появились классы - синтаксический сахар(красивая обертка) их удобнее использовать
    class User {
        constructor(name, id){
            this.name = name;
            this.id = id;
            this.human = true;
        }
        hello() {
            console.log(`Hello ${this.name}`)
        }
        exit() {
            console.log(`Пользователь ${this.name} ушел`)
        }
    }
    
}



{//  311    ====    Контекст вызова функции this     ====

    // КОНТЕКСТ - то что окружает функцию и в каких условиях она вызывается. Пример из реальной жизни, представи человека без
        // определенного места жительства - он может ф-ть в пределах всего мира(у него нету привязки к определенному месту), но
        // если поместить его в спец. учереждение где он может жить и чем-то заниматься, то он уже получит контекст вызова, теперь
        // у него есть свое место для функционирования. Ф-и в JS ведут себя также.
    


    // Функция может вызыватся 4 мя способами и в каждом контекст вызова отличается
    

    // *** 1) Простой(обычный) вызов ф-и
        
        function showThis() {
            console.log(this);
        }
        showThis(); 
        // *! без "use strict" this(будет ссылаться на window ) = window (глобальный обект), с "use strict" будет undefined
    
        // ЗАДАЧА - что выведет функция и как исправить если оне не работает. 
        // При "use strict" будет ошибка потому что контекст в каждой ф-и будет undefined, и следовательно  return this.a + this.b;
        // не сработает потому что будет пытаться прочитать undefined(тоесть даже если используется ф-я внутри ф-и, контекст
        // вложенной ф-ии будет undefined, не важно где она запускается).
        // Без "use strict" - контекстом будет глобальный объект и его использование с мат. операцией даст NaN.
        // Исправляется код удалением this из a и b, тогда sum не найдя их в себе ищет в функции выще благодаря замыканию функций.

        function showThis2(a, b) {
            console.log(this);
            function sum(){
                console.log(this);
                return this.a + this.b;
            }
            console.log(sum());
        }
        showThis2(4, 5);
        
    

    // *** 2) Метод объекта - это тоже ф-я. *! Контекст у методов объекта - сам ОБЪЕКТ.
        
        const obj = {
            a: 20,
            b: 15,
            sum: function() {
                console.log(this);
            }
        };
        obj.sum();  // {a: 20, b: 15, sum: ƒ}

        //ЗАДАЧА
        const obj = {
            a: 20,
            b: 15,
            sum: function() {
                function shout() {
                    console.log(this);
                }
                shout();
            }
        };
        obj.sum();
        // При таком методе будет возвращено с "use strict" будет undefined без - window, потому что это уже не метод объекта, 
        // а обычноя функция внутри метода, сработает как вызов обычной ф-и

    

    // *** 3  Функции конструкторы. Когда будет вызвана ф-я она создаст новый объект и контекст вызова в для свойств и методов
        // для них будет только что созданный объект. При записи вместо this подставляется новый созданный объект this.name будет
        // тоже самое что User.name, а при использовании метода hello контекст уже будет браться из записанного свойства name.
        // *! this в конструкторах и классах - это новый экземпляр объекта, в данном случае ссылается на ivan.

        function User(name, id) {
            this.name = name;
            this.id = id;
            this.human = true;
        
            this.hello = function() {
                console.log(`Hello ${this.name}`);
            };
        }
        
        let ivan = new User("Ivan", 23);
        ivan.hello();
    
    

    // *** 4  Ручное присвоение this любой функции: call, apply, bind
        
        // call, apply - привязывают контекст вызова ф-ции к объекту.
        function sayName() {
            console.log(this);
            console.log(this.name);
        }
        
        const user = {
            name: "John"
        };
        
        sayName.call(user);     // получаем объект - контекст вызова и второй строчкой John
        sayName.apply(user);    // работает также как call, разница в синтаксисе при передаче аргументов
        

        // Разница call, apply в синтаксисе при передаче аргументов
        function sayName(surname) {
            console.log(this);
            console.log(this.name + surname);
        }
        
        const user = {
            name: "John"
        };
        
        sayName.call(user, "Smith");    // 1) строка{name: "John"} 2) строка - JohnSmith  передаем аргумент - строкой
        sayName.apply(user, ["Smith"]); // 1) строка{name: "John"} 2) строка - JohnSmith  передаем аргумент - передаем массивом
        


        // Третий метод bind - создает НОВУЮ функцию и под нее подвязывает контекст. При этом bind(2) - переходит в this и 
        // становится постоянным контекстом, а num будет передаваться в функцию double
        
        function count(num) {
            return this*num;
        }
        
        const double = count.bind(2); // создаем переменную и назначаем ей функцию НОВУЮ count через метод bind

        console.log(double(3));     // 6
        console.log(double(13));    // 26
    


    // +++ ПРАКТИКА
        // В ХТМЛ есть <button></button> которая ничего не содержит. Получим эл. кнопки в btn. На нее навесим обр. события
        // прописав коллбек ф-ю в классическом виде function, и при клике посмотрим какой контекст будет у ф-ии применимо к
        // элементу. В консоль получаем сам элемент <button></button> то есть тоже самое что event.target при записи классической
        // ф-ии.

        const btn = document.querySelector("button");
        
        btn.addEventListener("click", function() { //смотрим чему равен this применимо к нашему элементу при клике
            console.log(this);  // в консоль получаем сам объект <button></button> то есть тоже самое что event.target
            this.style.backgroundColor = "red"; //работает, но чаще пользуются event.target
        });
        

        // Но если функция будет СТРЕЛОЧНОЙ (у нее нету своего контекста вызова, она берет его от родителя).
        // Рассмотрим пример который был выше, если бы ф-я const say = () => была в обычной записи const say = function(),
        // тогда бы мы получили undefined, а так стрелочная ф-я будет брать контектс от родителя метода sayNumber который
        // всегда ссылается на объект, и в консоль мы получим сам объект.
        
        const obj = {
            num: 5,
            sayNumber: function() {
                const say = () => {
                    console.log(this);
                };
                say();
            }
        };
        obj.sayNumber();
        
        // Стрелочные ф. обычно используются для модификации элементов прямо тут на месте и имеет свой синтаксис
        // запись с классической функцией
            const double = function() {
                return a * 2;
            }
        
        // Запись стрелочной ф. можно сократить если тело функции помещается в одну строку, убираем фигурные скобки и return
        // которое подставляется автоматически.
            const double = (a) => a * 2; 
        // а если аргумент один то скобки у него тоже можно сократить  const double = a => a * 2;


        // Поэтому при такой записи стрелочная пытается всзять контекст у undefined или window в зависимости от "use strict";
        btn.addEventListener("click", () => { 
            console.log(this);  // в консоль получаем саму ОШИБКУ потому что теряется контекст
        }); 
        
        // тогда нужно прописывать обращение не через this, а через event.target для работоспособности
        btn.addEventListener("click", (e)=> { 
             e.target.style.backgroundColor = "red";
        });
        
        // *! То есть если используем  в обр. события function - можно использовать this, но если стрелочная ф-я () =>, то контекст
        // теряется и нужно использовать event.target.

}



{//  312    ====    Classes (ES6)     ====

    // ES6 стандарт выпущен в 2015 году для облегчения работы с JS и фикса некоторых ошибок. Поддерживается почти всем новыми
        // версиями браузеров. Для старых версий можно использовать трансплитер(он превращает код из современного стандарта в
        // старый) самый популярный из них babeljs, будем рассматривать далее по курсу.


    //Классы - красиваяобертка ф-й конструкторов (синтаксический сахар). *! Название класса ВСЕГДА с БОЛЬШОЙ буквы.  Такие 
        // конструкторы нам нужны для создания новых однотипных объектов (новые пользователи сайта, товары в магазинах, 
        // ролики на ютубе) - везде где есть ШАБЛОНИЗАЦИЯ.
    


    // +++ Принципы ООП 

    // *** 1) АБСТРАКЦИЯ - когда отделяем концепцию от ее экземпляра. Rectangle - концепция(шаблон), square и long - экземпляры
        
        class Rectangle {
            constructor(height, width) {
                this.height = height;
                this.width = width;
            }
        
            calcArea(){
                return this.height * this.width;
            }
        } 
    
        const square = new Rectangle(10, 10);
        const long = new Rectangle(20, 100);
        
        console.log(square.calcArea()); // 100
        console.log(long.calcArea());   // 2000
    
    
    // *** 2)  НАСЛЕДОВАНИЕ - способность объекта или класса базироваться на другом объекте или классе (extends - наследуется),
        // это главный механизм для повторного использования кода. Такое наследственное отношение классов будет четко определять
        // их иерархию.
        // Пример - допустим у нас есть большой класс который называется Тайтл(различные статьи на сайте), при разрастании сайта
        // нам нужно делать статьи под разными рубриками(например статьи по готовке и статьи по технологиям) и каждая из этих
        // статей будет кастомизироваться, но при этом они будут прототипами на основе которых будут создаваться статьи(по этой
        // тематике). Так у нас получается иерархия  главный класс Тайтл (содержит все свойства и методы которые будут у всех
        // статей) - разветвление на классы по Тематиками ( у них будут дополнительные особенности) - отдельные экземпляры
        // объектов(статей).


        // Создадим класс ColoredRectangleWithText - прямоугольники с цветом и текстом. И тут  мы видим что у этого класса  
        // некоторые свойства и методы будут такие же как и у Rectangle. То есть нам не нужно их заново прописывать, а можно
        // сделать наследуемость(в реальных проектах свойств и методов будет очень много и такой способ сэкономит много времени).
        // Новый класс будет наследоваться по ключ. слову extends от Rectangle и возьмет все его свойства и методы. Снова 
        // вызываем constructor и в него закладываем те аргументы которые нам нужны. Методом super наследуем(копируем) свойства
        // из родительского класса, он ызывает суперконструктор родителя, super() - должен быть в конструкторе ВСЕГДА на ПЕРВОМ
        // месте. В нем указываем те свойства которые нужно унаследовать(скопировать), не всегда нужны все свойства родителя.
        // Метод calcArea() скопировался при наследовании нового класса через extends.

        class ColoredRectangleWithText extends Rectangle {
            constructor(height, width, text, bgColor) {
                super(height, width); //метод вызывает суперконструктор родителя, тот код который был у родителя в конструкторе  
                        // и методы super() - должен быть в конструкторе ВСЕГДА на ПЕРВОМ месте
                this.text = text;
                this.bgColor = bgColor;
            }
        
            showMyProps() {
                console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
            }
        }
        
        const div = new ColoredRectangleWithText(25, 10, "Hello", "red");

        div.showMyProps();              // Текст: Hello, цвет: red
        console.log(div.calcArea());    // 250

}



{//  313    ====    Use Classes in real work (шаблонизация, создание єлементов на странице через классы)

    // Используем классы на проекте Project_food в папке 303.
    
    // Задача - шаблонизировать карточки с меню, передавая только нужные аргументы создавать карточки динамически. В будущем 
        // аргументы юудут приходить от сервера. Карточки статически прописаны в верстке в индекс.хтмл.



    // Создаем класс для карточек, что бы от него отпочковывать карточки. Смотрим в верстке какие аргументы нам нужны будут для 
        // создания карточки(путь картинки, альтернативный текст, заголовок, описание, цена). Добавим метод для конвертирования
        // цены из доллара в гривны, в будущем цена в долларах нам будет приходить с сервера. Но пока с сервером не работаем
        // создадим свойство для хранения статического курса валюты transfer. В методе changeToUAH пишем формулу по которой
        // будет перевод в гривны, данные прайс и трансфер взаимодействуют и записаваются снова в свойство price. Поместим
        // вызов метода для обсчета курса в конструктор что бы свойство price уже было обсчитано для дальнейшей работы.
        
        // Создаем метод для формирования верстки render(). В нем создаем эл, изменяем его иннерхтмл версткой скопированной
        // из индекс.хтмл, но дополним его удалив все эл которые будут меняться и поставив на их место ссылки на свойства класса.
        // Так как мы создали div и потом в него поместили всю верстку которая должна быть у нас 1 эл. див стал лишний, мы с ним
        // разберемся в следующих уроках, потому что на внешний вид сайта это не повлияет. Теперь нужно поместить созданный эл.
        // на страницу, для этого нужно получить родителя в который нужно помещать созданный эл., поместим родителя как аргумент
        // для класса parentSelector, что бы можно было использовать и для других секций в будущем. На сейчас поместим
        // свойство с родительским эл. в конструктор(можно и в метод render, разницы сейчас не будет) 
        // this.parent = document.querySelector(parentSelector);, а в render дописываем this.parent.append(element);
        // Класс готов, теперь будем его использовать.

        class MenuCard{
            constructor(src, alt, title, descr, price, parentSelector){ //alt - будет показываться если картинки нету
                this.src = src;
                this.alt = alt;
                this.title = title;
                this.descr = descr;
                this.price = price;
                this.parent = document.querySelector(parentSelector);
                this.transfer = 28; // пока записываем статический курс валют
                this.changeToUAH(); // вызываем метод для конвертирования, он выполниться перед методом создания верстки render
            }
            
            changeToUAH() { // Метод для конвертирования цены из долларов в гривну когда эта информация будет приходить с сервера
                this.price = this.price * this.transfer;
            }

            render() { //метод для формирования верстки. 
                const element = document.createElement("div"); //создаем элемент div
                //Вставлем верстку из хтмл в innerHTML созданного div
                element.innerHTML = `
                    <div class="menu__item">
                        <img src=${this.src} alt=${this.alt}>
                        <h3 class="menu__item-subtitle">${this.title}</h3>
                        <div class="menu__item-descr">${this.descr}</div>
                        <div class="menu__item-divider"></div>
                        <div class="menu__item-price">
                            <div class="menu__item-cost">Цена:</div>
                            <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                        </div>
                    </div>
                `;
                //Для размещения этой структуры нужно знать родителя, добавляем в принимаемые аргументы parentSelector, 
                //он может быть разный в зависимости от создаваемой карты MenuCard, сразу получаем его элемент
                this.parent.append(element);
            }
        }


        // Потренируемся(потестируем), создадим новый объект и у него вызовем метод render. Можно использовать такой синтаксис
        // const div = new MenuCard();  div.render();. Можно сократить синтаксис не используя перменную, потому что объект
        // может существовать и без присвоения его к переменной, использовать вызов объекта на месте, но тогда в будущем 
        // не сможем к нему обратиться потому что ссылки на него не будет  new MenuCard().render(); - прописываем с
        // необходимыми аргументами для каждой карточки, итого 3 раза. Видим что добавились карточки на страницу, теперь можно
        // карточки из верстку удалить.

        //Можно использовать вызов объекта на месте, без присвоения его к переменной, но тогда в будущем не сможем к нему обратиться
        new MenuCard(
            "img/tabs/vegy.jpg",
            "vegy",
            'Меню "Фитнес"”',
            'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и 
        //   здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
            9,
            ".menu .container"
        ).render();

        //заменяем карточки которые были в верстке и удаляем их оттуда
        new MenuCard(
            "img/tabs/elite.jpg",
            "elite",
            'меню “Премиум”',
            'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. 
        //   Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',
            9,
            ".menu .container"
        ).render();
        
        new MenuCard(
            "img/tabs/post.jpg",
            "post",
            'Меню "Постное"',
            'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного 
        //   происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',
            9,
            ".menu .container"
        ).render();



    {"use strict";
    class MenuCard{
        constructor(src, alt, title, descr, price, parentSelector){ //alt - будет показываться если картинки нету
            this.src = src;
            this.alt = alt;
            this.title = title;
            this.descr = descr;
            this.price = price;
            this.parent = document.querySelector(parentSelector);
            this.transfer = 28; //пока записываем статически курс валют
            this.changeToUAH(); // вызываем метод для конвертирования, он выполниться перед методом создания верстки
        }
    
        changeToUAH() { // Метод для конвертирования цены из долларов в гривну когда эта информация будет приходить с сервера
            this.price = this.price * this.transfer;
        }
    
        render() { //метод для формирования верстки. 
            const element = document.createElement("div"); //создаем элемент div
            //Вставлем верстку из хтмл в innerHTML созданного div
            element.innerHTML = `
                <div class="menu__item">
                    <img src=${this.src} alt=${this.alt}>
                    <h3 class="menu__item-subtitle">${this.title}</h3>
                    <div class="menu__item-descr">${this.descr}</div>
                    <div class="menu__item-divider"></div>
                    <div class="menu__item-price">
                        <div class="menu__item-cost">Цена:</div>
                        <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                    </div>
                </div>
            `;
            //Для размещения этой структуры нужно знать родителя, добавляем в принимаемые аргументы parentSelector, 
            //он может быть разный в зависимости от создаваемой карты MenuCard, сразу получаем его элемент
            this.parent.append(element);
        }
    }


    //Можно использовать вызов объекта на месте, без присвоения его к переменной, но тогда в будущем не сможем к нему обратиться
    new MenuCard(
        "img/tabs/vegy.jpg",
        "vegy",
        'Меню "Фитнес"”',
        'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт 
    //   активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
        9,
        ".menu .container"
    ).render();

    //заменяем карточки которые были в верстке и удаляем их оттуда
    new MenuCard(
        "img/tabs/elite.jpg",
        "elite",
        'меню “Премиум”',
        'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение 
    //   блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',
        9,
        ".menu .container"
    ).render();
    
    new MenuCard(
        "img/tabs/post.jpg",
        "post",
        'Меню "Постное"',
        'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного 
    //   происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и 
    //   импортных вегетарианских стейков.',
        9,
        ".menu .container"
    ).render();
       
    //Структура HTML верстки. Обращаемся к самому верхнему элементу .menu а потом к его div .container
    /* <div class="menu">
            <h2 class="title">Наше меню на день</h2>
    
            <div class="menu__field">
                <div class="container">
                    <div class="menu__item"></div> */
    }

}



{//  314    ====    Rest оператор и параметры по умолчанию (ES6)     ====


    // Spread - оператор разворота, берет сущность и раскладывает на отдельные элементы.

    // Rest - объединяет отдельные элементы в один массив, обратен spread синтаксис такой же но в других условиях.
        // записывается как ...name(name-любой) всегда последним аргументом, используется для аргументов (опциональных), 
        // если мы не знаем сколько еще дополнительных аргументов будет(их может и не быть)
        
        const log = function(a, b, ...rest) {
            console.log(a, b, ...rest);
        };
        
        log("basic", "else", "operator", "usage"); // basic else ["operator", "usage"]
    

    // ПАРАМЕТРЫ по УМОЛЧАНИЮ
    //Метод который использовался до (ES6). Задание параметра по умолчанию, если он будет отсутсвовать
        
    function calcOrDouble(number, basis) {
            basis = basis || 2; // *! ИЛИ возвращает первую правду
            console.log(number * basis);
        }
        calcOrDouble(3, ); // если второго аргумента не будет - ошибка, и что бы этого избежать раньше писали basis = basis || 2;

        // в некоторых случаях такая проверка приводила к ошибкам, и поэтому в ES6 можно присвоить 2 сразу в объявлении
        function calcOrDouble(number, basis = 2) {
            console.log(number * basis);
        }
        calcOrDouble(3, );  // 6
    

        
    // Переходим в файл со скриптом о карточках

    // В методе render мы создаем лишний div, что бы от этого избавится нужно класс "menu__item" из верхнего дива весртки
    // присвоить создаваемому div (а старый удалим), и еще продумаем, возможно при создании карточки захотим добавить еще 
    // еще классы этому div (для увеличения карточки или еще для чего-то), можно их задать через rest в аргументы класса
    // parentSelector, ...classes){. Потом запишем его в свойства что бы можно было с ним работать(использовать) 
    // this.classes = classes;, помним что это у нас будет массив и с ним нужно будет работать как с массивом, через перебор
    // this.classes.forEach(className => element.classList.add(className)); - индекс нам не нужен, поэтому запишем перебор
    // с одним аргументом - именем класса, которые будем присваивать новосозданному диву(element). Теперь удаляем лишний див из
    // создания верстки. Добавляем в создаваемые карточки последним аргументом название класса "menu__item" - прописываем без
    // точки потому что мы его поместим в массив и будем присваивать через classList.add. 
    
    // Предусмотрим еще поведение если пользователь забудет прописать класс, тогда верстка не построится вообще.
    // Значит нужно установить класс "menu__item" через условие if, потому что такой способо записи не подойдет 
    // ...classes = "menu__item"(рест оператор не поддерживает) дефолтные значения. Также не сработает и такой способ
    //  this.classes = classes || "menu__item"; потому что в classes поместится строка и мы ее не сможем перебрать 
    // this.classes.forEach. В условии мы будем сравнивать if(this.classes.length === 0) длинну classes с нулем, потому
    // что rest оператор все равно сформирует массив, даже пустой, и он при проверке if(this.classes) - не выдаст false, а
    // всегда будет true. Также ведут себя qeurySelectorAll, getElementsByClassName и т.д. когда мы пытаемся
    // получить эл. со страницы и их не находит, формируется пустой массив.
    // После сравнения если массив пустой то присвоим element.classList.add("menu__item"); но вдруг нам понадобится этот
    // класс в будущем, тогда мы его присвоим свойству this.element = "menu__item"; а уже его добавим элементу
    // element.classList.add(this.element);
    
    class MenuCard{
        constructor(src, alt, title, descr, price, parentSelector, ...classes){
            this.src = src;
            this.alt = alt;
            this.title = title;
            this.descr = descr;
            this.price = price;
            this.classes = classes;
            this.parent = document.querySelector(parentSelector);
            this.transfer = 28; 
            this.changeToUAH(); 
        }

        changeToUAH() { 
            this.price = this.price * this.transfer;
        }

        render() { //метод для формирования верстки. 
            const element = document.createElement("div"); 
            
            // Задаем параметр класса по умолчанию, в случае если его не будет. Проверку выполняем на количество элементов, так как 
            // rest все равно сформирует пустой массив, который в условии будет интерпретироваться как true. Также ведут себя 
            // qeurySelectorAll, getElementsByClassName и т.д. когда мы пытаемся получить эл. со страницы и их не находит, формируется 
            // пустой массив
            if(this.classes.length === 0) {
                this.element = "menu__item"; //присваиваем класс в пустой массив для возможной дальнейшей работы с ним
                element.classList.add(this.element);
            } else {
                //перебираем массив выдергиваем каждое название класса и присваи ваем его как класс класслисту элемента
                this.classes.forEach(className => element.classList.add(className)); 
            }
        
            // Убираем <div class="menu__item">, и присваивам его при задании новой карточки последним аргументом
            // Записываем без точки потому что присвоние через classList
            element.innerHTML = `
                    <img src=${this.src} alt=${this.alt}>
                    <h3 class="menu__item-subtitle">${this.title}</h3>
                    <div class="menu__item-descr">${this.descr}</div>
                    <div class="menu__item-divider"></div>
                    <div class="menu__item-price">
                        <div class="menu__item-cost">Цена:</div>
                        <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                    </div>
            `;
            this.parent.append(element);
        }
    }

    new MenuCard(
        "img/tabs/vegy.jpg",
        "vegy",
        'Меню "Фитнес"”',
        'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. 
    //   Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
        9,
        ".menu .container",
        "menu__item",
        "big"    // добавили еще класс что бы посмотреть сработает ли rest оператор 
    ).render();

    new MenuCard(
        "img/tabs/elite.jpg",
        "elite",
        'меню “Премиум”',
        'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд.
    //   Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',
        14,
        ".menu .container",
        "menu__item"
    ).render();

    new MenuCard(
        "img/tabs/post.jpg",
        "post",
        'Меню "Постное"',
        'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения,
    //   молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',
        12,
        ".menu .container",
        "menu__item"
    ).render();

}





// 400 ========================================== ПРОДВИНУТЫЙ ==================================================================


{//  401    ====    Local servers    ====

    //Разновидности серверов: Простые - выполняют одну задачу или несколько простых(LiveServer в VSCode, http server, JSON server),
    // Комплексные - выполняют всё
    //Самые популярные HTTP запросы  Get и Post. Простые сервера принимают только Get запросы.
    //AJAX серверная технелогоия позволяет отправлять Гет и Пост запросы без перезагрузки страницы

}



{//  402    ====    JSON, глубокое клонирование объектов    ====

    "use strict";
    //JSON текстовый формат обмена данных. В файлах с расширениями JSON можно хранить данные в формате ключ - значение.
    //Главное правило - все строки должны быть в двойных кавычках
    
    // const persone = {
    //     name: "Alex",
    //     tel: "+7777744444"
    // };
    
    //Что бы передать этот объект на сервер нужно его преобразовать в один из вариантов который можно транспортировать.
    //Посмотреть основы протокола http. 
    //В уроках будем разбирать стандартный URL encoded  - форма просто отправляется с сайта с перезагрузко страницы(даже без скрипта)
    //Передача объекта form - data  и формат данных JSON
    
    //Все современные браузеры имеют встроенные инструменты для работы с данными JSON это свойства и методы
    //методов два 
    
    //1) stringify - превращает объекты в нужный формат 
    // console.log(JSON.stringify(persone)); // {"name":"Alex","tel":"+7777744444"}
    
    // //2)parse превращает информацию с сервера JSON в привычный формат данных
    // console.log(JSON.parse(JSON.stringify(persone))); // получаем объект {name: 'Alex', tel: '+7777744444'} с которым можно работать
    
    //данные в JSON занимают мало места и легко читаются, до него был XML там не было таких преимуществ
    
    //============================ Клонирование объектов. ГЛУБОКИЕ КОПИИ ===================================
    const persone = {
        name: "Alex",
        tel: "+7777744444",
        parents: {
            mom: "Olga",
            dad: "Mike"
        }
    };
    //такая структура превращает объект в формат JSON потом парсит обратно и отвязывает от исходного объекта, присваивая НОВЫЙ переменной
    const clone = JSON.parse(JSON.stringify(persone)); 
    clone.parents.mom = "Ann" ;
    console.log(persone);
    console.log(clone);

}



{//  403    ====    AJAX и общение с сервером CALC (Converter)    ====

    "use strict";
    //AJAX (Asynchronous Javascript and XML) позволяет обновлять часть контента страницы, без полной перезагрузки, экономя траффик
    //Создадим конвертер валю где курс будет приходить от сервера по требованию
    //разбираем самый первый вариант AJAX который реализуется при помощи объекта XML hhtp request(не актуален, но встречается)
    //который встроен в браузер
    
    //в папке JS файл current.json с внутренним текстом (путь js/current.json) 
    // {
    //     "current": {     //свойство объекта содержит объект usd со свойством 74 - курс доллара
    //         "usd": 74    // это значение будет доставать через usd
    //     }
    // }
    
    //получаем элементы инпутов со страницы. В один rub будет пользователь вводить значение, а во второй usd будем выводить 
    //сконвертированное значение на основании запроса от сервера и обработки
    const inputRub = document.querySelector("#rub"),
          inputUsd = document.querySelector("#usd");
    
    //назначаем обработчик события для получения данных от пользователя. Выбор между input и change
    //change - происходит когда пользователь напечатала что то в поле и увел фокус(табом или клацнул в другое место на странице)
    //input - происходит каждый раз когда что то вводится или удаляется в поле
    inputRub.addEventListener('input', () => {
        const request = new XMLHttpRequest(); //создаем запрос на сервер
    
        // этот метод собирает настройки которые позволят в будущем сделать запрос request.open(method, url, async, login, pass); 
        //method - метод для запроса (GET,POST)  пишутся в верхнем регистре, url - путь к серверу(файлу) относительно index.html , 
        //async - по умолчанию true, чтобы остальной код не ждал ответа от сервера,
        // потому что неизвестно как долго это будет, можно поставить в false при надобности
        //login и pass используются для некоторых запросов требующих авторизации
        request.open('GET', 'js/current.json'); // запрос, остальные аргументы для нас сейчас необязательны
        //для уточнения серверу что мы хотим получить используются заголовки Header
        //'Content-type' - тип контента, 'application/json' указываем что хотим json файл с кодировкой utf-8
        request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        request.send(); // отправляем запрос на сервер
        //если метод post или подобный то send(body) - принимает аргументы для отправки
    
        //СВОЙСТВА запроса: status - код с которым вернется запрос(200 OK - успешные, 400 - ошибка клиента(404 Not Found) ... и тд)
        //посмотреть состояния можно по запросу  << Список кодов состояния HTTP >>
        //statusText - текстовое описание ответа сервера (ок, Not found, ... и тд)
        //response - ответ от сервера (то что задл бэк енд разработчик), используем его в клиенте
        //readyState - содержит текущее состояние запроса(цыфра). Цыфра 0 значение UNSENT, 1 OPENED, 2 HEADERS_RECEIVED,
        //3	LOADING, 4	DONE (выполнена)
    
        //СОБЫТИЯ loadstart, progress, abort, timeout, loadend, но чаще всего используются cледующие 2 события
        //рассмотрим реализацию каждого из них
    
        //readystatechange - отслеживает статус готовности запроса в текущий момент например с 0 на 1 - сработало, с 1-2 сработало
        // request.addEventListener('readystatechange', () => { //
        //     if(request.readyState === 4 && request.status === 200){
        //         console.log(request.response); // получаем объект из json файла который нужно трансформировать в объект JS
        //         const data = JSON.parse(request.response); //получаем объект JS
        //         //рассчитываем курс валют на основании ввода пользователя и ответа сервера и выводим в поле
        //         inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2); //toFixed(2) - округляем до 2х заков после точки
        //     } else { //дописываем елсе если сервер сломался что бы пользователь увидел ошибку
        //         inputUsd.value = 'Что то пошло не так';
        //     }
        // });
        //Используется редко потому что обычно промежуточные стадии 0, 1, 2, 3 не нужны, а нужна сразу 4 DONE (выполнена)
    
        //load - срабатывает когда запрос полностью загрузился и получен результат. 4 DONE (выполнена) - не значит что выполнен
        //успешно, данные могут потерятся или еще что то
        request.addEventListener('load', () => { // оставляем проверку на успешное выполнение status
            if(request.status === 200){
                const data = JSON.parse(request.response); //получаем объект JS
                //рассчитываем курс валют на основании ввода пользователя и ответа сервера и выводим в поле
                inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2); //toFixed(2) - округляем до 2х заков после точки
            } else { //дописываем елсе если сервер сломался что бы пользователь увидел ошибку
                inputUsd.value = 'Что то пошло не так';
            }
        });
    });

}



{//  404    ====    Реализация скрипта ОТПРАВКИ данных на сервер (POST) XML http request    ====

    //Переходим в файл со скриптом о карточках Food. Запускаем его на сервере для работы POST
    //Задача собрать данные из форм  Имя и Телефон в двух местах(на сайте и в модальном окне) и отправить на сервер при нажатии кнопки
    //Для контроля правильной отработки бэкенда создаем в корне проэкта файл server.php и запишем <?php echo var_dump($_POST);
    //Эта комманда берет данные которые пришли из клиента ( массив _POST ) превращает в строку и показывает обратно на клиенте(ответ сервера, responce)

    //формы две (имя, телефон) поэтому функция отправки будет повторятся, что бы не дублировать два обработчика, обернем
    //в функцию для последующего вызова. Тут еще используем XML hhtp request, в следующих уроках будет более современный метод

    //получаем все формы по тегу
    const forms = document.querySelectorAll('form');

    //Создаем объект для вывода текстовых сообщений пользователю о ходе запроса
    const message = {
        loading: 'Загрузка',
        success: 'Спасибо! До связи',
        failure: ' Что-то пошло не так...'
    };

    //берем все form и для каждой подвязываем функцию postData
    form.forEach(item => {
        postData(item);
    });


    //Функция для постинга данных
    function postData(form) { //принимаем аргумент form для удобства навешивания на него обработчика события submit
        form.addEventListener('submit', (e) => {  // submit срабатывает по Enter или button с type submit. если в верстке кнопка задана
                                                //тегом <button - у нее автоматически установлен type submit
            e.preventDefault(); // принимаем аргумент е - события, что бы отменить стандартное повередение - перезагрузку страницы
            
            //Создаем переменную для вывода пользователю сообщений
            const statusMessage = document.createElement('div');
            statusMessage.classList.add('status'); //добавляем класс status
            statusMessage.textContent = message.loading;
            form.append(statusMessage); // Прикрепляем этот див с сообщением к form для отображения на странице

            const req = new XMLHttpRequest(); //создаем объект запроса
            req.open('POST', 'server.php'); // вызываем метод open для настройки запроса

            //как получить все данные введенные пользователем и отправить на сервер. Можно вручную. взять форму, взять все инпуты
            //которые есть внутри, взять их value, перебрать, сформировать объект, но это очень нерационально потому что есть готовые
            //механизмы, и самый простой способ подготовить данные для отправки из формы использовать объект - formData
            //не всегда нужно передавать в формате JSON, зависит от поддержки сервера или программиста бэкенда
            //рассмотрим formData и второй формат JSON

            // Если работаем с JSON, FormData спецыфический объект который просто превратить в JSON не получится, есть спецю прием
            req.setRequestHeader('Content-type', 'application/json');
            //Для этого создаем пустой объект и через переюор FormData через forEach запушим в новый объект значения
            const object = {};
            formData.forEach(function(value, key){
                object[key] = value;
            });
            //Теперь используем конвертацию в json и помещаем его в  req.send(json);
            const json = JSON.stringify(object);

            //если передаем через XMLHttpRequest
            //req.setRequestHeader('Content-type', 'multipart/form-data'); // multipart/form-data - используем что бы работал FormData
                                                                        //согласно описанию FormData, но есть ***ньюанс - смотр ниже!!!

            const formData = new FormData(form); // формирует объект ключ-значение из полей input/option/textarea, но только если 
                                                // у них прописан тег name, иначе не найдет эти значения.(name="name", name="phone")
            req.send(formData); // так как мы отправляем данные то есть body - formData

            //Если работаем с JSON то 
            //req.send(json);

            req.addEventListener('load', () => {
                if (req.status === 200) {
                    console.log(req.response);
                    statusMessage.textContent = message.success;
                    form.reset(); // очищаем форму
                    setTimeout(() =>{
                        statusMessage.remove()   // удаляем блок со страницы
                    }, 2000);
                }else{
                    statusMessage.textContent = message.failure;
                    }
            });
        });
    }
    //Что бы изменения сохраненные в коде применились при работе с сервером, нужно каждый раз сбрасывать кеш. shift+f5
    // После заполнения полей и нажатия кнопки отправить, данные ушли - смотрим по вкладке Network, статус сервера -200 ОК
    // нам написало 'Спасибо! До связи' но в консоль получили пустой массив, это случилось из-за заголовка  multipart/form-data
    // Когда используем связку XMLHttpRequest(), Объекта и FormData - заголовок устанавливать не нужно, он устанавливается
    //автоматически, поэтому весь заголовок req.setRequestHeader('Content-type', 'multipart/form-data'); нам не нужно прописывать
    //поэтому закомментируем его и все будет отрабатывать хорошо. 
    //Если нужно отправлять данные в JSON тогда прописываем req.setRequestHeader('Content-type', 'application/json');
    //*** Ньюанс PHP нативно не умеет работать с данными JSON, чаще всего такие данные отправляют на сервера Node.JS
    //Но можно вручную прописать совместимость с PHP в файле допишем строку 
    //<?php echo 
    //$_POST = json_decode(file_get_contents("php://input), true);
    //var_dump($_POST);

}



{//  405    ====    Красивое оповещение пользователя    ====

    //Переходим в файл со скриптом о карточках Food. Запускаем его на сервере для работы POST
    //============================ 005 Красивое оповещение пользователя
    //Прикручиваем спиннер в течении отправки запроса на сервер, а после успешного выполнения появление нового модального окна с текстом
    //Если запрос неудачный то будет другое сообщение. Модальное окно можно сделать новое, а можно использовать существующее.
    //Используем существующее и в нем заменим <div class="modal__dialog"> для изменения контента окна. Стили действуют прежние
    {/* <div class="modal">
            <div class="modal__dialog">
                <div class="modal__content">
                    <form action="#">
                        <div data-close class="modal__close">&times;</div>
                        <div class="modal__title">Мы свяжемся с вами как можно быстрее!</div>
                        <input required placeholder="Ваше имя" name="name" type="text" class="modal__input">
                        <input required placeholder="Ваш номер телефона" name="phone" type="phone" class="modal__input">
                        <button class="btn btn_dark btn_min">Перезвонить мне</button>
                    </form>
                </div>
            </div>
        </div> */}

    function showThanksModal(message) {
        const prevModalDialog = document.querySelector('.modal__dialog');
    
        //скрываем, а не удаляем предыдущее модальное окно что бы пользователь повторно его мог использовать
        prevModalDialog.classList.add('hide');
        openModal(); // открывается модальное окно
    
        const thanksModal = document.createElement('div'); //Создаем обвертку для нового модального окна
        thanksModal.classList.add('modal__dialog'); // добавляем стили для модального окна
        //Создаем новый тайтл и крестик х - закрытия, но он динамически создается и на него обработчик события ранее созданный closemodal
        // которая вешалась на modalCloseBtn получаемому по аттрибуту [data-close] действовать не будут, поэтому мы их подправим
        // modalCloseBtn = document.querySelector("[data-close]") и modalCloseBtn.addEventListener("click", closeModal); - этот удалим
        //
        //Этот подправим    modal.addEventListener("click", (e)=>{
        //                      if(e.target === modal){    
        //                      closeModal();          
                                //}
                            //});
        //теперь выглядит так 
        //005 Усовершенствованное для динамически создаваемых окон
        // modal.addEventListener("click", (e)=>{
        //     // Проверяем равенство объекту modal или объект содержащий аттрибут data-close равен пустой строке, мы туда ничего не помещаем
        //     if(e.target === modal || e.target.getAttribute('data-close') == '') {  
        //         closeModal();          // тут вызываем функцию
        //     }
        // });
    
        //***Крестик x  - специальный ХТМЛ символ (✖	&#10006;	Жирный символ закрыть (крестик))
        //Сообщение для пользователя в modal__title будем перелаваит как аргумент message в showThanksModal который будем брать из
        //объекта message
        thanksModal.innerHTML = `
        <div class="modal__content">
            <div class="modal__close" data-close>x</div> 
            <div class="modal__title">${message}</div> 
        </div>
        `;
    
        //Получаем модальное окно и сразу аппендим наш блок для замены старого окна новым
        document.querySelector('.modal').append(thanksModal);
    
        //Реализуем появление старого окна если пользователь снова его вызовет
        setTimeout(() => { // удаляем наш новый блок
            thanksModal.remove();
            prevModalDialog.classList.add('show');
            prevModalDialog.classList.remove('hide');
            closeModal(); // закрываем окно что бы не мешало пользователю
        } , 4000);
    }
    
    // Теперь в функции отправки проведем изменения
    // function postData(form) { 
    //     form.addEventListener('submit', (e) => {  
          
    //         e.preventDefault(); 
            
    //          const statusMessage = document.createElement('div');
    //         statusMessage.classList.add('status'); 
    //         statusMessage.textContent = message.loading;
    //         form.append(statusMessage); 
    
    //         const req = new XMLHttpRequest(); 
    //         req.open('POST', 'server.php'); 
    
    //         req.setRequestHeader('Content-type', 'application/json');
    //         const object = {};
    //         formData.forEach(function(value, key){
    //             object[key] = value;
    //         });
           
    //         const json = JSON.stringify(object);
    
    //         const formData = new FormData(form); 
    //         req.send(formData); 
    
    //         req.addEventListener('load', () => {
    //             if (req.status === 200) {
    //                 console.log(req.response);
    //                 showThanksModal(message.success); // запускаем нашу нункцию с аргументом сообщением
    //                 form.reset(); //Удалили таймаут потому что она будет использоваться только для спинера
    //                 statusMessage.remove(); // удаляется спиннер   
    //             }else{
    //                 showThanksModal(message.failure);
    //             }
    //         });
    //     });
    // }
    
    //Раскоментируем const modalTimerId = setTimeout(openModal, 50000); потому что она давала ошибку в консоле и если так и оставить
    //то вызов  openModal() в функции showThanksModal завершится ошибкой и дальше код не пойдет
    
    //Добавляем вместо loading: 'Загрузка' в объекте message - картинку спиннер "spinner.svg". В папке img создаем папку form
    //и туда помещаем спиннер, как относящийся к этому элементу
    // const message = {
    //     loading: 'img/form/spinner.svg',
    //     success: 'Спасибо! До связи',
    //     failure: ' Что-то пошло не так...'
    // };
    
    //Также изменяем
    // form.addEventListener('submit', (e) => {  
    //     e.preventDefault(); 
    //     //005 изменяем для показа картинки и класс
    //     const statusMessage = document.createElement('img');
    //     statusMessage.src = message.loading;
    //     //записываем инлайн стили что бы картинка была по центру
    //     statusMessage.style.cssText = `
    //         display: block;
    //         margin: 0 auto;
    //     `;
    //     form.append(statusMessage); 
    
    //При первой эмуляции медленного интернета slow 3G(вместо online) на вкладке Network в консоли изображение мелькнуло и пропало,
    //так как эмулируется медленный интерней картинка не успела подгрузится до выполнения запроса, нужно повторить отправку формы
    //для нормального отображения.
    //При сбросе кеша параметр slow 3G нужно менять снова на online, а то будет долго перекешироваться страница
    
    //При проверке второй формы без модального окна, спиннер сдвигает форму влево, потому что верстка на флексах(фликсах) этого
    //можно избежать если вместо аппенда  form.append(statusMessage) присоединять спиннер после формы
            //form.append(statusMessage);  - удалена в 005 что бы не сдвигалась форма используем insertAdjacentElement послеформы
            // form.insertAdjacentElement('afterend', statusMessage);
            
}



{//  406    ====    Promise    ====

    "use strict";
    //Позволяет удобно работать с асинхронными операциями(timeOut или запросы на сервер). При выполнении клика хотим что бы только
    // в этом случае выполнялся заданный код, тогда мы используем коллбек фунции. ПРИМЕР :Когда делаем запрос на сервер получаем
    //данные, выполняем с ними какие то действия и снова отправляем на сервер что бы получить следующие данные и снова с ними произвести
    //какие то операции. Цепочка действий зависит от предыдущих результатов (выполняем действие только после успешного выполнения 
    // предыдущих действий). Для такого кода можно написать много функций обратного вызова что превратится в большой нечитабельный код,
    // его также иногда называются call back hell.  Promise заменяет большой код с функциями обратного вызова.

    // Promise после reject/resolve – неизменны. после вызова resolve/reject промис уже не может «передумать».
    // Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда.
    // Последующие вызовы resolve/reject будут просто проигнорированы.



    // НЕБОЛЬШОЙ ПРИМЕР (вместо setTimeot  будут запросы к серверу)
    // console.log('Запрос данных...');

    // setTimeout(() => {
    //     console.log('Подготовка данных...');

    //     const product = {
    //         name: 'TV',
    //         price: 2000
    //     };

    //     setTimeout(() => {
    //         product.status = 'Ordered';
    //         console.log(product);
    //     }, 2000);
    // }, 2000);


        console.log('Запрос данных...');

    //создаем новый промис с коллбек функцией внутри обычно принимает 2 аргумента function(resolve, reject). resolve, reject - функции
    //которые мы сами сможем передавать. resolve - означает что то выполнилось правильно, reject - что то пошло не так, 
    //обещание не выполнилось. Сеттаймут с  product.status - заменяем на resolve, потому что он выполнится только в случае выполнения
    //предыдущего кода
            const req = new Promise(function(resolve, reject) {
                setTimeout(() => {
                    console.log('Подготовка данных...');
                
                    const product = {
                        name: 'TV',
                        price: 2000
                    };
                
                    resolve(product);
                }, 2000);
            }); 

    //vscode подсказывает что есть методы req (catch, then, finally). then - запускает функцию в случае положительного выполнения
    //предыдущего кода, будет вызыватся из места где resolve впредыдущем коде. В этом коде product не существует, поэтому его
    //нужно вернуть из предыдущей функции, вписав аргументом в resolve(product) и req.then((product)
    // req.then((product) => {
    //     setTimeout(() => {
    //         product.status = 'Ordered';
    //         console.log(product);
    //     }, 2000);
    // });
        
        
    //Для дальнейших действий с кодом req.then оборачиваем его в промис как и предыдущий(исходный код) 
    // req.then((product) => {
    //     const req2 = new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             product.status = 'Ordered';
    //             resolve(product);
    //         }, 2000);
    //     });
    //
    //     req2.then(data => {
    //         console.log(data);
    //     });
    // });
    //

    //***Если код не обернуть в новый промис то второе обращение then будет обращаться к первому промису и будет выполнятся не 
    //после второго, а совместно с первым tnen ***  МОЙ ПРИМЕР
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //        
    //         console.log(x);
    //         resolve(x);
    //     }, 2_000);
    //    
    // });
    // prom.then((x) => {
    //      setTimeout(() => {
    //       x = x + 2;
    //         console.log(x);
    //         return x;
    //     }, 2_000);
    // });
    // prom.then((x2) => {
    //     setTimeout(() => {
    //     x2 = x2 + 4;
    //         console.log(x2);
    //         return x2;
    //     }, 2_000);
    // });
    //Тут я ожидал увидеть  в консоли 10 12 16 через каждые 2 секунды, но по факту 10 12 14 - 12 и 14 выполняются одновременно и
    //используют данные которые отдает resolve. Для того что бы отдать данные дальше и нужно создавать новый промис.
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //       
    //         console.log(x);
    //         resolve(x);
    //     }, 2_000);
    //  
    // });
    //
    // prom.then((x) => {
    //     const prom2 = new Promise((resolve) =>{
    //         setTimeout(() => {
    //             let  x2 = x + 2;
    //               console.log(x2);
    //               resolve(x2);
    //           }, 2_000);
    //     });
    //
    //     prom2.then((x2) => {
    //    
    //         setTimeout(() => {
    //         let    x3 = x2 + 4;
    //             console.log(x3);
    //         }, 2_000);
    //     });
    // }); 
    //*** Но второй then обращается к prom2.then внутри предыдущего then потому что глобально нового промиса не существует
    //он существует в prom.then - первом then. И для дальнейшего вызова снова нужно создавать новый рпомис prom3, это
    //неудобно и накладывает ограничения, поэтому в коде ниже мы будет ВОЗВРАЩАТЬ новый промис для последующего взаимодействия
    //с then  и для того что бы не создавать каждый раз новый промис и называть его. После первого resolve, дальнейшая 
    //передача данных осуществляется через return
    //*** На завершённых промисах обработчики запускаются сразу
    //Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его. Однако, если промис уже завершён, 
    //то обработчики выполнятся сразу. Что бы таймауты работали правильно нужно каждый раз вызывать новый промис
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //         console.log(x);
    //         resolve(x);
    //     }, 1_000);
    //    
    // });
    //
    // prom.then(x => {
    //     return new Promise((resolve, reject) =>{
    //         setTimeout(() => {
    //             x = x + 2;
    //             console.log(x);
    //             resolve(x);
    //           }, 1_000);
    //     });
    // }).then(x => {
    //     return new Promise((resolve, reject) =>{
    //     x = x + 4;
    //     setTimeout(() => {console.log(x); resolve(x);}, 1_000);
    //     //return x;
    //     });
    // }).then(x => {
    //     return new Promise((resolve, reject) =>{
    //      x = x + 5; 
    //      setTimeout(() => {console.log(x); resolve(x);}, 1_000);
    //      //return x;
    //      });
    // }).then(x => {
    //     return new Promise((resolve, reject) =>{
    //     x = x + 5;
    //     setTimeout(() => {console.log(x); resolve(x);}, 1_000);
    //     //return x;
    //     });
    // }).catch(() =>{
    //     new Error("…");
    // }).finally(() => {console.log(`Job's done`)});


    //По сравнению с обычными колбеками преимуществом промисов является то что мы можем возвращать промис из then по цепочке.
    //Когда одна операция выполнится, выполним следующую, и т.д. сокращая написание функции вот так
    // req.then(product => {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             product.status = 'Ordered';
    //             resolve(product);
    //         }, 2000);
    //     });
    // }).then(data => {
    //     data.modify = true;
    //     return data;
    // }).then((prevData) => {
    //     console.log(prevData);
    // });

    //***МОЙ ПРИМЕР*** setTimeout работает нормально только в паре с resolve. Если в then уже идет return, из тайм аута он не вернет 
    //значение, его нужно использовать вне таймаута, наверное из-за этого все итерации с then и  return после первого выполняются
    //мгновенно. В консоль получаем 10 12 16 21 26. 10 12 - с интервалом 2 скунды и еще через 2 секунды  сразу 3 числа 16 21 26
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //        
    //         console.log(x);
    //         resolve(x);
    //     }, 2_000);
    //    
    // });
    //
    // prom.then(x => {
    //     return new Promise((resolve) =>{
    //         setTimeout(() => {
    //             x = x + 2;
    //             console.log(x);
    //             resolve(x);
    //           }, 2_000);
    //     });
    // }).then(x => {
    //     x = x + 4;
    //     setTimeout(() => {console.log(x);}, 3_000);
    //     return x;
    // }).then(x => {
    //      x = x + 5; 
    //     setTimeout(() => {console.log(x);}, 3_000);
    //     return x;
    // }).then(x => {
    //     x = x + 5;
    //     setTimeout(() => {console.log(x);}, 3_000);
    // });
        


    //При помощи reject обрабатывается невыполнение кода из-за ссылки на несуществующий файл при его запросе, не существующий сервер,
    // падение сервера и его ответ - ошибка. Метод catch обычно идет в конце. При ошибке все then пропускаются и выполнение кода
    //переходит на catch. (При возникновении ошибки – она отправляется в ближайший обработчик onRejected.)
            req.then(product => {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        product.status = 'Ordered';
                        resolve(product);
                    }, 2000);
                });
            }).then(data => {
                data.modify = true;
                return data;
            }).then((prevData) => {
                console.log(prevData);
            }).catch(() => {
                console.error('Произошла ошибка');
            }).finally(() => {
                console.log('Finally');
            });
    // Блок finally всегда в конце - позволяет выполнить действия не зависимо от успеха выполнения кода. Используется например для
    //очистки формы от старых данных по завершении работы кода

    //Пример с learn.javascript.ru/promise
    // 'use strict';
    // httpGet('/article/promise/userNoGithub.json')
    // .then(JSON.parse)
    // .then(user => httpGet(`https://api.github.com/users/${user.name}`))
    // .then(
    //     JSON.parse,
    //     function githubError(error) {
    //     if (error.code == 404) {
    //         return {name: "NoGithub", avatar_url: '/article/promise/anon.png'};
    //     } else {
    //         throw error;
    //     }
    //     }
    // )
    // .then(function showAvatar(githubUser) {
    //     let img = new Image();
    //     img.src = githubUser.avatar_url;
    //     img.className = "promise-avatar-example";
    //     document.body.appendChild(img);
    //     setTimeout(() => img.remove(), 3000);
    // })
    // .catch(function genericError(error) {
    //     alert(error); // Error: Not Found
    // });

        
    // Промисификация – это когда берут асинхронную функциональность и делают для неё обёртку, возвращающую промис.
    // После промисификации использование функциональности зачастую становится гораздо удобнее.
    // В качестве примера сделаем такую обёртку для запросов при помощи XMLHttpRequest.
    // Функция httpGet(url) будет возвращать промис, который при успешной загрузке данных с url будет переходить в
    // fulfilled с этими данными, а при ошибке – в rejected с информацией об ошибке:      

    //Пример с learn.javascript.ru/promise    
    // function httpGet(url) {
    //     return new Promise(function(resolve, reject) {
        
    //       var xhr = new XMLHttpRequest();
    //       xhr.open('GET', url, true);
        
    //       xhr.onload = function() {
    //         if (this.status == 200) {
    //           resolve(this.response);
    //         } else {
    //           var error = new Error(this.statusText);
    //           error.code = this.status;
    //           reject(error);
    //         }
    //       };
        
    //       xhr.onerror = function() {
    //         reject(new Error("Network Error"));
    //       };
        
    //       xhr.send();
    //     });
    //   }   

    //Использование:
    //     httpGet("/article/promise/user.json")
    //   .then(
    //     response => alert(`Fulfilled: ${response}`),
    //     error => alert(`Rejected: ${error}`)
    //   );


    //Рассмотрим методы all и race - принимают аргументом массив с промисами

    // Эта функция запускается принимает аргумент time(колю времени) возвращает Promise который зарезолвится через время time
    //Эту функцию используют для запуска одинаковых операций через разные промежутки времени
    const test = time => {
        return new Promise(resolve => { // ***Очень редко бывает второй аргумент reject не нужен, тогда мы его не передаем
            setTimeout(() => resolve(), time); //resolve выполнится через time
        });
    };

    test(1000).then(() => console.log('1000 ms')); // - console.log - через then для того что бы увидеть результат
    test(2000).then(() => console.log('2000 ms'));
    test(3000).then(() => console.log('3000 ms'));

    // all получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, 
    //пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.
    //Промисы вернут результат который можем обработать через then. Этот метод служит для того что бы точно убедится что все
    //промисы выполнились. Например запрашиваем 4 картинки из разных серверов, и что бы одновременно их показать ждем пока 
    //все промисы выполнятся. Ориентируемся на промис который выполнится последним. Если какой-то из промисов завершился с ошибкой,
    // то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются.
    Promise.all([test(1000), test(2000), test(3000)]).then(() => {
        console.log('All');
    });
    //Можно дописать catch для обработки ошибки

    // Пример с learn.javascript.ru/promise
    // Promise.all([
    //     httpGet('/article/promise/user.json'),
    //     httpGet('/article/promise/guest.json'),
    //     httpGet('/article/promise/no-such-page.json') // (нет такой страницы)
    //   ]).then(
    //     result => alert("не сработает"),
    //     error => alert("Ошибка: " + error.message) // Ошибка: Not Found
    //   )

        
    // race  - в отличие от all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.
    //этот метод начнет выполнятся как только выполнится самый первый промис из массива
    Promise.race([test(1000), test(2000), test(3000)]).then(() => {
        console.log('Race');
    });
    // 1000 ms
    // Race
    // 2000 ms
    // 3000 ms
    // All

    //     Пример с learn.javascript.ru/promise
    //     Promise.race([
    //         httpGet('/article/promise/user.json'),
    //         httpGet('/article/promise/guest.json')
    //       ]).then(firstResult => {
    //         firstResult = JSON.parse(firstResult);
    //         alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше
    //       });


    // ИТОГО
    // Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и колбэки.

    // При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, 
    //которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке.

    // Аргумент resolve/reject (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.

    // Обработчики назначаются вызовом .then/catch.

    // Для передачи результата от одного обработчика к другому используется чейнинг.

    // У промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для «отмены» промиса, 
    //хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.

    // В современной JavaScript-разработке сложные цепочки с промисами используются редко, так как они куда проще 
    //описываются при помощи генераторов с библиотекой co, которые рассмотрены в соответствующей главе. Можно сказать, 
    //что промисы лежат в основе более продвинутых способов асинхронной разработки.

    //***Функция для выполнения действия через заданное количество времени на промисе
    // function delay(ms) {
    //     return new Promise(resolve => setTimeout(resolve, ms));
    //   }
    //   delay(1000).then(() => console.log('выполнилось через 1 секунду'));
    //   delay(2000).then(() => console.log('выполнилось через 2 секунду'));
    //   delay(3000).then(() => console.log('выполнилось через 3 секунду'));
    //Заметьте, что resolve вызывается без аргументов. Мы не возвращаем из delay ничего, просто гарантируем задержку.

}



{//         ====    ЦЕПОЧКА ПРОМИСОВ  https://learn.javascript.ru/promise-chaining    ====
    
    // Давайте вернёмся к ситуации из главы Введение: колбэки: у нас есть последовательность асинхронных задач, которые должны
    // быть выполнены одна за другой. Например, речь может идти о загрузке скриптов. Как же грамотно реализовать это в коде?

    // Промисы предоставляют несколько способов решения подобной задачи.

    // В этой главе мы разберём цепочку промисов.

    // Она выглядит вот так:
        
    new Promise(function(resolve, reject) {

        setTimeout(() => resolve(1), 1000); // (*)

    }).then(function(result) { // (**)

        alert(result); // 1
        return result * 2;

    }).then(function(result) { // (***)

        alert(result); // 2
        return result * 2;

    }).then(function(result) {

        alert(result); // 4
        return result * 2;

    });
    // Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.

    // Поток выполнения такой:

    // Начальный промис успешно выполняется через 1 секунду (*),
    // Затем вызывается обработчик в .then (**).
    // Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
    // …и так далее.
    // В итоге результат передаётся по цепочке обработчиков, и мы видим несколько alert подряд, которые выводят: 1 → 2 → 4.


    // Всё это работает, потому что вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.

    // Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в 
    //следующий .then.

    // Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису. Но это не цепочка.

    // Например:

    let promise = new Promise(function(resolve, reject) {
        setTimeout(() => resolve(1), 1000);
    });

    promise.then(function(result) {
        alert(result); // 1
        return result * 2;
    });

    promise.then(function(result) {
        alert(result); // 1
        return result * 2;
    });

    promise.then(function(result) {
        alert(result); // 1
        return result * 2;
    });

    // Мы добавили несколько обработчиков к одному промису. Они не передают друг другу результаты своего выполнения, а действуют 
    //независимо.

    // Все обработчики .then на одном и том же промисе получают одно и то же значение – результат выполнения того же самого промиса.
    //Таким образом, в коде выше все alert показывают одно и то же: 1.

    // На практике весьма редко требуется назначать несколько обработчиков одному промису. А вот цепочка промисов используется куда
    // чаще.

    // Возвращаем промисы
    // Обработчик handler, переданный в .then(handler), может вернуть промис.

    // В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.

    // Например:
        
    new Promise(function(resolve, reject) {

        setTimeout(() => resolve(1), 1000);

    }).then(function(result) {

        alert(result); // 1

        return new Promise((resolve, reject) => { // (*)
        setTimeout(() => resolve(result * 2), 1000);
        });

    }).then(function(result) { // (**)

        alert(result); // 2

        return new Promise((resolve, reject) => {
        setTimeout(() => resolve(result * 2), 1000);
        });

    }).then(function(result) {

        alert(result); // 4

    });
    // Здесь первый .then показывает 1 и возвращает новый промис new Promise(…) в строке (*). Через одну секунду этот промис успешно
    //  выполняется, и его результат (аргумент в resolve, то есть result * 2) передаётся обработчику в следующем .then. Он находится
    //   в строке (**), показывает2 и делает то же самое.

    // Таким образом, как и в предыдущем примере, выводятся 1 → 2 → 4, но сейчас между вызовами alert существует пауза в 1 секунду.

    // Возвращая промисы, мы можем строить цепочки из асинхронных действий.

    // Пример: loadScript
    function loadScript(src) {
        return new Promise(function(resolve, reject) {
        let script = document.createElement('script');
        script.src = src;
    
        script.onload = () => resolve(script);
        script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));
    
        document.head.append(script);
        });
    }
    // Давайте используем эту возможность вместе с промисифицированной функцией loadScript, созданной нами в предыдущей главе, чтобы
    // загружать скрипты по очереди, последовательно:

    loadScript("/article/promise-chaining/one.js")
        .then(function(script) {
        return loadScript("/article/promise-chaining/two.js");
        })
        .then(function(script) {
        return loadScript("/article/promise-chaining/three.js");
        })
        .then(function(script) {
        // вызовем функции, объявленные в загружаемых скриптах,
        // чтобы показать, что они действительно загрузились
        one();
        two();
        three();
        });
    // Этот же код можно переписать немного компактнее, используя стрелочные функции:

    loadScript("/article/promise-chaining/one.js")
        .then(script => loadScript("/article/promise-chaining/two.js"))
        .then(script => loadScript("/article/promise-chaining/three.js"))
        .then(script => {
        // скрипты загружены, мы можем использовать объявленные в них функции
        one();
        two();
        three();
        });
    // Здесь каждый вызов loadScript возвращает промис, и следующий обработчик в .then срабатывает, только когда этот промис завершается.
    //  Затем инициируется загрузка следующего скрипта и так далее. Таким образом, скрипты загружаются один за другим.

    // Мы можем добавить и другие асинхронные действия в цепочку. Обратите внимание, что наш код всё ещё «плоский», он «растёт» вниз,
    //  а не вправо. Нет никаких признаков «адской пирамиды вызовов».

    // Технически мы бы могли добавлять .then напрямую к каждому вызову loadScript, вот так:

    loadScript("/article/promise-chaining/one.js").then(script1 => {
        loadScript("/article/promise-chaining/two.js").then(script2 => {
        loadScript("/article/promise-chaining/three.js").then(script3 => {
            // эта функция имеет доступ к переменным script1, script2 и script3
            one();
            two();
            three();
        });
        });
    });
    // Этот код делает то же самое: последовательно загружает 3 скрипта. Но он «растёт вправо», так что возникает такая же проблема,
    //  как и с колбэками.

    // Разработчики, которые не так давно начали использовать промисы, иногда не знают про цепочки и пишут код именно так, как
    //  показано выше. В целом, использование цепочек промисов предпочтительнее.

    // Иногда всё же приемлемо добавлять .then напрямую, чтобы вложенная в него функция имела доступ к внешней области видимости.
    //  В примере выше самая глубоко вложенная функция обратного вызова имеет доступ ко всем переменным script1, script2, script3.
    //   Но это скорее исключение, чем правило.

    // Thenable
    // Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, такие объекты
    //  называют «thenable», и этот объект будет обработан как промис.

    // Смысл в том, что сторонние библиотеки могут создавать свои собственные совместимые с промисами объекты. Они могут иметь свои
    //  наборы методов и при этом быть совместимыми со встроенными промисами, так как реализуют метод .then.

    // Вот пример такого объекта:

    class Thenable {
        constructor(num) {
        this.num = num;
        }
        then(resolve, reject) {
        alert(resolve); // function() { native code }
        // будет успешно выполнено с аргументом this.num*2 через 1 секунду
        setTimeout(() => resolve(this.num * 2), 1000); // (**)
        }
    }

    new Promise(resolve => resolve(1))
        .then(result => {
        return new Thenable(result); // (*)
        })
        .then(alert); // показывает 2 через 1000мс
    // JavaScript проверяет объект, возвращаемый из обработчика .then в строке (*): если у него имеется метод then, который можно
    //  вызвать, то этот метод вызывается, и в него передаются как аргументы встроенные функции resolve и reject, вызов одной из 
    //  которых потом ожидается. В примере выше происходит вызов resolve(2) через 1 секунду (**). Затем результат передаётся дальше
    //   по цепочке.

    // Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от Promise.

    // Более сложный пример: fetch
    // Во фронтенд-разработке промисы часто используются, чтобы делать запросы по сети. Давайте рассмотрим один такой пример.

    // Мы будем использовать метод fetch, чтобы подгрузить информацию о пользователях с удалённого сервера. Этот метод имеет много
    //  опциональных параметров, разобранных в соответствующих разделах, но базовый синтаксис весьма прост:

    // let promise = fetch(url);
    // Этот код запрашивает по сети url и возвращает промис. Промис успешно выполняется и в свою очередь возвращает объект response
    //  после того, как удалённый сервер присылает заголовки ответа, но до того, как весь ответ сервера полностью загружен.

    // Чтобы прочитать полный ответ, надо вызвать метод response.text(): он тоже возвращает промис, который выполняется, когда данные
    //  полностью загружены с удалённого сервера, и возвращает эти данные.

    // Код ниже запрашивает файл user.json и загружает его содержимое с сервера:

    fetch('/article/promise-chaining/user.json')
        // .then в коде ниже выполняется, когда удалённый сервер отвечает
        .then(function(response) {
        // response.text() возвращает новый промис,
        // который выполняется и возвращает полный ответ сервера,
        // когда он загрузится
        return response.text();
        })
        .then(function(text) {
        // ...и здесь содержимое полученного файла
        alert(text); // {"name": "iliakan", isAdmin: true}
        });
    // Есть также метод response.json(), который читает данные в формате JSON. Он больше подходит для нашего примера, так что
    //  давайте использовать его.

    // Мы также применим стрелочные функции для более компактной записи кода:

    // то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
    fetch('/article/promise-chaining/user.json')
        .then(response => response.json())
        .then(user => alert(user.name)); // iliakan, получили имя пользователя
    // Теперь давайте что-нибудь сделаем с полученными данными о пользователе.

    // Например, мы можем послать запрос на GitHub, чтобы загрузить данные из профиля пользователя и показать его аватар:

    // Запрашиваем user.json
    fetch('/article/promise-chaining/user.json')
        // Загружаем данные в формате json
        .then(response => response.json())
        // Делаем запрос к GitHub
        .then(user => fetch(`https://api.github.com/users/${user.name}`))
        // Загружаем ответ в формате json
        .then(response => response.json())
        // Показываем аватар (githubUser.avatar_url) в течение 3 секунд (возможно, с анимацией)
        .then(githubUser => {
        let img = document.createElement('img');
        img.src = githubUser.avatar_url;
        img.className = "promise-avatar-example";
        document.body.append(img);

        setTimeout(() => img.remove(), 3000); // (*)
        });
    // Код работает, детали реализации отражены в комментариях. Однако в нём есть одна потенциальная проблема, 
    // с которой часто сталкиваются новички.

    // Посмотрите на строку (*): как мы можем предпринять какие-то действия после того, как аватар был показан и удалён? 
    // Например, мы бы хотели показывать форму редактирования пользователя или что-то ещё. Сейчас это невозможно.

    // Чтобы сделать наш код расширяемым, нам нужно возвращать ещё один промис, который выполняется после того, как 
    // завершается показ аватара.

    // Примерно так:

    fetch('/article/promise-chaining/user.json')
        .then(response => response.json())
        .then(user => fetch(`https://api.github.com/users/${user.name}`))
        .then(response => response.json())
        .then(githubUser => new Promise(function(resolve, reject) { // (*)
        let img = document.createElement('img');
        img.src = githubUser.avatar_url;
        img.className = "promise-avatar-example";
        document.body.append(img);

        setTimeout(() => {
            img.remove();
            resolve(githubUser); // (**)
        }, 3000);
        }))
        // срабатывает через 3 секунды
        .then(githubUser => alert(`Закончили показ ${githubUser.name}`));
    // То есть, обработчик .then в строке (*) будет возвращать new Promise, который перейдёт в состояние «выполнен» только после того,
    //  как в setTimeout (**) будет вызвана resolve(githubUser).

    // Соответственно, следующий по цепочке .then будет ждать этого.

    // Как правило, все асинхронные действия должны возвращать промис.

    // Это позволяет планировать после него какие-то дополнительные действия. Даже если эта возможность не нужна прямо сейчас,
    //  она может понадобиться в будущем.

    // И, наконец, давайте разобьём написанный код на отдельные функции, пригодные для повторного использования:

    function loadJson(url) {
        return fetch(url)
        .then(response => response.json());
    }

    function loadGithubUser(name) {
        return fetch(`https://api.github.com/users/${name}`)
        .then(response => response.json());
    }

    function showAvatar(githubUser) {
        return new Promise(function(resolve, reject) {
        let img = document.createElement('img');
        img.src = githubUser.avatar_url;
        img.className = "promise-avatar-example";
        document.body.append(img);

        setTimeout(() => {
            img.remove();
            resolve(githubUser);
        }, 3000);
        });
    }

    // Используем их:
    loadJson('/article/promise-chaining/user.json')
        .then(user => loadGithubUser(user.name))
        .then(showAvatar)
        .then(githubUser => alert(`Показ аватара ${githubUser.name} завершён`));
        // ...
    // Итого
    // Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут,
    //  пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.

}



{//  407    ====    Fetch API, promise + server    ====

    // API - Application Programming Interface (интерфейс программного приложения). Это набор данных и возможностей которые 
    //предоставляет нам какое то готовое решение, мы уже пользуемся DOM API (document.qerySelector - используя методы doument)

    // Fetch API - уже встроена в браузер, построена на промисах и позволяет общаться с сервером.
    //Будем обращаться к jsonplaceholder.typicode.com - небольшая база данных в интернете к которой можно обращаться для тестирования

    // Что на сервере хранится
    // /posts	100 posts
    // /comments	500 comments
    // /albums	100 albums
    // /photos	5000 photos
    // /todos	200 todos
    // /users   10 users

    //Какие запросы можно отправлять
    // GET	/posts
    // GET	/posts/1
    // GET	/posts/1/comments
    // GET	/comments?postId=1
    // POST	/posts
    // PUT	/posts/1
    // PATCH	/posts/1
    // DELETE	/posts/1

    //На этом сайте есть пример как обращаться к базе, копируем его - обращаемся к todo
    //Без указания дополнительных параметров - это будет класический GET запрос который получит данные
    // response.json- встроенный метод fetch заменяет JSON.parse и возвращает promise(потому что не знаем сколько будет длится операция)
    // fetch('https://jsonplaceholder.typicode.com/todos/1') // 1 - уникальній идентификатор по которому делаем запрос (id: 1)
    //     .then(response => response.json()) 
    //     .then(json => console.log(json));
    // получили объект {userId: 1, id: 1, title: 'delectus aut autem', completed: false}
    //Также с сервера может прийти текст который нужно будет потом превратить в объект

    //Для формирования POST запроса нужно добавить объект с настройками (обязательные 2 свойства - mehod и body, желательно указывать
    // еще заголовки для указания что мы отправляем )
    // fetch('https://jsonplaceholder.typicode.com/posts', { // обращаемся к POST	/posts 
    //     method: "POST",
    //     body: JSON.stringify({name:"Alex"}),
    //     headers: {
    //         'Content-type': 'application/json'
    //     }
    // }) 
    // .then(response => response.json()) 
    // .then(json => console.log(json));
    // {name: 'Alex', id: 101} - запостили и получили назад ответ с фейковой id: 101, на самом деле мы ничего не записали на сервер
    //просто получили такой ответ, который говорит нам что все работает 

    // Метод запросов fetch намного проще XMLHttpRequest запросов. url задается одной строкой, а настройки идут одним объектом. Этот
    //метод запросов сейчас используется почти везде, однако можно встретить и XMLHttpRequest запросы.

    //======== Перписываем функционал сайта продуктов с использованием fetch
    //============================ 007 Переписываем запросы с помощью fetch
    // 1) отправим классическую формдейту 2) отправим JSON файл на наш сервер
    function postData(form) { 
        form.addEventListener('submit', (e) => {  
            e.preventDefault(); 
            
            //005 изменяем для показа картинки и класс
            const statusMessage = document.createElement('img');
            statusMessage.src = message.loading;
            //записываем инлайн стили что бы картинка была по центру
            statusMessage.style.cssText = `
                display: block;
                margin: 0 auto;
            `;
            //form.append(statusMessage);  - удалена в 005 что бы не сдвигалась форма используем insertAdjacentElement послеформы
            form.insertAdjacentElement('afterend', statusMessage);

            //007 Убираем этот запрос, вместо него будет fetch - который перемещаем ниже под создание formData
            // const req = new XMLHttpRequest(); 
            // req.open('POST', 'server.php'); 
            
            //007 из req.setRequestHeader берем headers только через двоеточие и удаляем строку
            //req.setRequestHeader('Content-type', 'application/json');
        
            const formData = new FormData(form);

            //007- пока закоментируем потому что  отправляем только FormData и превращать в json не нужно
            // const object = {};
            // formData.forEach(function(value, key){
            //     object[key] = value;
            // });
            // const json = JSON.stringify(object);

    
            // req.send(formData);  //007 убрано

                    //007  Раньше обрабатывали результат запроса так, теперь с помощью промисов
            // req.addEventListener('load', () => {
            //     if (req.status === 200) {
            //         console.log(req.response);
            //         showThanksModal(message.success); // запускаем нашу функцию с аргументом сообщением
            //         form.reset(); //Удалили таймаут потому что она будет использоваться только для спинера
            //         statusMessage.remove(); // удаляется спиннер   
            //     }else{
            //         showThanksModal(message.failure);
            //     }
            // });

            fetch('server.php', {
                method: 'POST',
                // headers: {                // заголовок раскоментируем когда будем отправлять json данные
                //     'Content-type': 'application/json'
                // },
                body: formData
            }).then(data => data.text()) //От сервера пришел отве Responce объект, но не данные которые мы отправляли, что бы их получить
            //что бы понимать какой ответ приходит нужно этот ответ модифицировать. В данном случае в текст, потому что мы знаем
            //что отправляли не json. ***Так же в Сервере .php  закоментируем строку для работы с json
            .then(data => { 
                console.log(data);
                showThanksModal(message.success); // запускаем нашу функцию с аргументом сообщением
                statusMessage.remove(); // удаляется спиннер  
            }).catch(() => {
                showThanksModal(message.failure); // Показываем ошибку если есть
            }).finally(() => {
                form.reset(); //очищаем форму в любом случае в конце этого кода
            });
        });
    }
    // Что бы передать JSON изменяем

    //007- пока закоментируем потому что  отправляем только FormData и превращать в json не нужно
            // const object = {};
            // formData.forEach(function(value, key){
            //     object[key] = value;
            // });

            // const json = JSON.stringify(object); // - избавляемся от лишней переменной и подставляем вместо formData

            fetch('server.php', {
                method: 'POST',
                headers: {                // заголовок раскоментируем для отправки json данных 
                    'Content-type': 'application/json' //***Так же в Сервере .php  раскомментируем строку для работы с json
                },
                body: JSON.stringify(object)
                //body: formData 
            }).then(data => data.text()) 
            .then(data => { 
                console.log(data);
                showThanksModal(message.success); // запускаем нашу функцию с аргументом сообщением
                statusMessage.remove(); // удаляется спиннер  
            }).catch(() => {
                showThanksModal(message.failure); // Показываем ошибку если есть
            }).finally(() => {
                form.reset(); //очищаем форму в любом случае в конце этого кода
            });

    //**** Проверим вывод ошибки для пользователя. Допустим ошибку в пути сервера server1.php, при этом в консоль выкидывается ошибка
    //но сообщение в модальном окне выводится как при положительном ответе. Это особенность fetch, промис который он запускает
    // не перейдет в состояни отклонено(rejected) из-за ответа http который считается ошибкой (404, 500, 502, ...) он все равно
    //выполнится нормально у него поменятся только status который будет false. (Еще раз простыми словами - если внутри фетча промис
    //попадает на ошибку которая связана с http протоколом - он не выкинет reject, для него это не считается ошибкой, он нормально
    //отработает resolve. Главное для фетча что он вообще смог сделать запрос, соответственно reject юудет только в случае сбоя сети
    // или если что то помешало запросу выполнится)

}



{//  408    ====    Методы перебора массивов и объектов    ====

    // 1) filter - фильтрует массив согласно заданному правилу и ***возвращает в новом массиве. Поэтому присваиваем результат переменной
    //в примере нужно получить все имена которые меньше 5 символов

    const names = ['Ivan', 'Ann', ' Ksenia', 'Volandemort'];

    const shortNames = names.filter(function(name) {
        return name.length < 5; // можно использовать запись через if if(name.length < 5) { return name.length;}
    });


    // 2) map - аналогичен forEach но ***возвращает новый массив
    //Нам нужно все элементы привести к нижнему регистру для дальнейшоего использования

    let answers = ['iVaN', 'AnnA', 'Hello'];

    const result = answers.map(item => {  //  сокращаем запись  answers.map(item => item.toLowerCase());
        return item.toLowerCase(); 
    });
    console.log(result); // ['ivan', 'anna', 'hello']

    // //Можно переприсвоить значение исходному массиву, объявляя его через let. 
    // //***С точки зрения Иммутабельности лучше создавать новую переменную
    answers = answers.map(item => item.toLocaleLowerCase()); // ['ivan', 'anna', 'hello']


    // 3) every/some
    // some - если хотя бы один эл. подходит под условие возвращает true
    //*** при использовании стрелочной записи функции return подставляется автоматически
    const some = [4, 'Some', 'user'];
    console.log(some.some(item => typeof(item) === 'number')); //true  сравниеваем эл. с типом number

    //every - true если все эл. массива подходят под условие
    console.log(some.every(item => typeof(item) === 'number')); //false  сравниеваем эл. с типом number


    // 4) reduce - собирает массив в единое целое ( чаще всего работает с числами)
    const arr = [4, 3, 2, 1];

    const result = arr.reduce((sum, current) => sum + current); //10

    //Можно проводить другие действия 
    //*** Если не задавать значение по умолчанию для sum - тогда оно равняется первому элементу массива 
    const resultMinus = arr.reduce((sum, current) => sum - current); // -2 (4 -3 -2 -1)
    //*** Если задать 0
    const resultMinus2 = arr.reduce((sum, current) => sum - current, 0); // -10 (0 -4 -3 -2 -1)

    const resultDouble = arr.reduce((sum, current) => (sum + current)*2, 0); // 98 ((0+4)*2 = (8+3)*2 = (22+2)*2 = (48+1)*2 = 98)

    //*** Массив со строками можно собрать в единую строку
    const str = ['Apple', 'Juice', 'Awesome'];
    //Метод 1 через конкатенацию
    const solidStr = str.reduce((sum, current) => sum + ', ' + current); //Apple, Juice, Awesome
    //Метод 2 через интерполяцию
    const solidStr2 = str.reduce((sum, current) => `${sum}, ${current}`); //Apple, Juice, Awesome


    //*** ПРАКТИЧЕСКИЙ ПРИМЕР
    // После обращения к серверу с него пришел объект с поменяными сетами названиями и свойствами (так делают потому что объект не может
    // содержать одинаковые названия свойств). Задача - вытащить имена пользователей ivan и ann, при том что расположение свойств 
    //в объекте неизвестно (индекс не известен)
    const obj = {
        ivan: 'persone',
        ann: 'persone',
        dog: 'animal',
        cat: 'animal'
    };

    // entries - метод для преобразования объекта в матрицу (*НОВЫЙ массив с вложенными массивами)
        //const newArr = Object.entries(obj);  // [ ['ivan', 'persone'], ['ann', 'persone'], ['dog', 'animal'], ['cat', 'animal'] ]

    //теперь фильтруем массив и оставляем те массивы у которых вторым эл. persone. Сделаем это методом цепочек(chaining) как промисы
    const newArr = Object.entries(obj)
    .filter(item => item[1] === 'persone')  //[ ['ivan', 'persone'], ['ann', 'persone'] ] снова используем цепочку
    .map(item => item[0]);                  // ['ivan', 'ann']

}



{//  409    ====    Подробно про npm и проект. JSON-server    ====

}



{//         ====    Деструктуризация / todo list    ====

}
