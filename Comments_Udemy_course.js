{//  ====    МЕТОДЫ ОТ SNIEDA    ==== 

    //++++++++++++++++++++++++ СТРОКИ ++++++++++++++++++++
    
    let str = 'Hello , World !';
    
    str.length // 15 Длина строки ( 15 элементов) последний элемент под индексом 14
    
    str.charAt(0); // 'H' - Возвращает букву под индексом 0
    str[0]; // 'H'
    
    str.charCodeAt(0); // 72 - код буквы
    

    str.concat (33); // 'Hello , World !33' - присоединяет к строке
    str.concat ([1,2,4]); // 'Hello , World !1,2,4'
    str.concat ({a:1, b:2}); //'Hello , World ![object Object]'
    

    str.startsWith('Hello') //true  Проверяет содержит ли строка это выражение в начале
    str.startsWith('ello'); //false
    str.startsWith('hello') //false регистр влияет
    str.startsWith('Hello', 1) //false Можхно задать начальный индекс поиска
    
    str.endsWith("!"); // true, Проверяет с конца строки, можно задать индекс
    str.endsWith("!", 10); //false
    

    str.includes('Hello') //true Проверяет содержится ли где то в строке такая подстрока
    str.includes('o') // true  Ищет по всей строке, а не только сначала
    str.includes('o', 13) //false можно указать индек с какого начинать искать
    
    str.indexOf('o') //4 Возвращает индекс первого совпадения
    str.indexOf('o', 5) //9 Можно задать начальный индекс, тогда вернет индекс следующего совпадения
    str.indexOf('y') // -1  При отсутствии совпадений возвращает минус 1
    

    str.slice() //'Hello , World !' - Обрезает строку и возвращает обрезанную. Если не указать индексы вернет всю строку
    str.slice(0, 5) //'Hello' Обрезает с 0 до 5го индекса НЕ включая 5й индекс
    str.slice(-7, -3) //'Worl' Принимает отрицательные числа
    str.slice(7) //' World !' указывая один первый индекс, возвратит строку обрезанную с 7го символа *включительно до конца

    str.substr(1, 8); //'ello , W' Обрезает строку и возвращает обрезанную. 
    //Первый аргумент - начальный индекс, второй - количество символов которые нужно вернуть
    

    str.split() // ['Hello , World !'] - возвращает массив, разделенный заданным разделителем. Тут нету разделителя. 1 элем
    str.split('') //['H', 'e', 'l', 'l', 'o', ' ', ',', ' ', 'W', 'o', 'r', 'l', 'd', ' ', '!'] Разделитель - пустая строка. 15 элем
    str.split(' ') // ['Hello', ',', 'World', '!'] Разделитель - пробел. 4 элемента
    str.split(',') // ['Hello ', ' World !'] Разделитель - запятая.  2 элемента
    str.split('o') // ['Hell', ' , W', 'rld !'] 3 элемента, разделитель удаляется и отсутствует в возвращенном массиве
    
    
    str.toLowerCase()  // 'hello , world !'  Возвращает новую строку в нижнем регистре      ***НЕ ИЗМЕНЯЕТ исходную строку.
    str.toUpperCase()  // 'HELLO , WORLD !'  В верхнем  регистре.                           ***НЕ ИЗМЕНЯЕТ исходную строку.
    
    
    let str2 = '     Hello , World !     ';
    
    str2.trim() //'Hello , World !'  Убирает пробелы в начале и в конце текста
    str2.trimStart() //'Hello , World !     ' - Только в начале
    str2.trimEnd() // '     Hello , World ! ' - Только в конце
    
    
    
    //++++++++++++++++++++++ МАССИВЫ ++++++++++++++++++++
    
    let arr = ["one", 'two', 'three', 'four', 'five'];
    
    arr.push(100) // 6 (показывает сколько элементов теперь содержит массив) - Добавляет переданные элементы в КОНЕЦ массива,
                                                                                //прадварительно превращая его в строку
    // ['one', 'Two', 'Three', 'Four', 'Five', 100] -                                    ***ИЗМЕНЯЕТ исходный массив

    console.log(arr.push(['six'])); // 7 Возвращает новое количество элементов, добавляет массив ['six'] как вложенный
    //['one', 'two', 'three', 'four', 'five', 100, Array(1)]                            ***ИЗМЕНЯЕТ исходный массив
    
    arr.push({a:1}) //8 ['one', 'two', 'three', 'four', 'five', 100, Array(1), {…}]     ***ИЗМЕНЯЕТ исходный массив
    
    arr.pop() //{a: 1} - Удаляет один последний элемент и возвращает его значение       ***ИЗМЕНЯЕТ исходный массив
    
    arr.unshift(1, 2) //9 - Добавляет элементы в начало массива, возвращает колличество элем.  
    //[1, 2, 'one', 'two', 'three', 'four', 'five', 100, Array(1)]                       ***ИЗМЕНЯЕТ исходный массив
    
    arr.shift(); //1   Удаляет первый элемент и возвращает его
    //[ 2, 'one', 'two', 'three', 'four', 'five', 100, Array(1)]                          ***ИЗМЕНЯЕТ исходный массив
    
    arr.concat([1, 2]); // Добавляет эл. в конец массива как push, но если добавим массив то он добавляет его элементы, а не сам 
                                                                                                                        //массив. 
    //(10) [2, 'one', 'two', 'three', 'four', 'five', 100, Array(1), 1, 2] ***НЕ ИЗМЕНЯЕТ исходный массив, а возвращает ***НОВЫЙ
    
    
    
    // ++++++++ Методы ПЕРЕБОРА массива forEach, map, some, every, find, findIndex, filter, reduce +++++++++++++++

    //Каждый из этих методов проходится по массиву от начала и до конца и принимает коллбэк функцию в качестве параметра(аргумента)
    arr = [1, 2, 3, 4, 5];
    

    // 1) forEach - перебирает эл. массива.  Аргументы el - элемент, ind - индекс, arr - массив.    ***МОЖЕТ ИЗМЕНЯТЬ исходный массив
        // ind и arr - указываем если хотим их использовать, имена произвольны.
        arr.forEach((el, ind, arr) => {
            console.log(`Element ${el}, Index: ${ind}, Massive: ${arr}`);
        })
        
        arr.forEach((elem, index) => {
            console.log(`Element ${elem}, Index: ${index} in this massive`);
        })
        //  Element 1, Index: 0 in this massive
        //  Element 2, Index: 1 in this massive
        //  Element 3, Index: 2 in this massive
        //  Element 4, Index: 3 in this massive
        //  Element 5, Index: 4 in this massive 

        // Так изменит свой же массив
        arr.forEach((el, ind) => {
            arr[ind] = el + 50;
        }) 
            console.log(arr); // [51, 52, 53, 54, 55]

    
    
    // 2) map - обязан вернуть значение поэтому прописываем return. ***возвращает НОВЫЙ массив, для хранения присваиваем переменной
        
        const mapArr = arr.map((el, ind, arr) => {
            return el * 2 + ind
        });
        //mapArr (5) [2, 5, 8, 11, 14]      при этом       arr  (5) [1, 2, 3, 4, 5];
        
    
    // 3) some Проверяет есть ли в массиве заданное условие, если хоть одно истинно возвращает true, если нет false
        
        const checkSome = arr.some ((el, ind, arr) => {
            return el > 1
        }) // true
    
    
    // 4) every Проверяет истину условия для каждого елем. если хоть один элем. не подходит, прекращает выполнение и возвращает false
        
        const checkEvery = arr.every ((el, ind, arr) => {
            return el > 1
        }) // false
    

    // includes Проверяет содержится ли где то в массиве такая подстрока. Возвращает - true / false
        
        arr.includes('new') //true
        arr.includes('new', 5) //false - второй параметр - начальный индекс поиска

    

    // 5) find - позволяет найти эл. в массиве и возвращает его (проверка останавливается на нем), если элемента нет - undefined
        
        const foundElem = arr.find((el, ind, arr) => {
            return el === 1
        }) // 1
    
    
    
    // 6) findIndex - возвращает индекс первого найденого элемента, если элемента нет - undefined
        
        const foundIndex = arr.findIndex ((el, ind, arr) => {
            return el === 1
        }) // 0
    

    
    // 7) filter - проверяет эл. на соответствие условию и ***возвращает НОВЫЙ массив с подходящими по условию элементами 
        
        const filterArr = arr.filter((el, ind, arr) => {
            return el > 3
        }) //(2) [4, 5]
    

    
    // 8) reduce - возвращает сумму всех элементов массива в ***НОВЫЙ. sum - переменная в которую ложится сумма(название 
        //произвольное)  init - можно задать значение по умолчанию для sum (0, 10, функцию, объект)
    
        const arrReduce = arr.reduce((sum, el, ind, arr) => {
            return sum + el
        }, init);   
        
        const arrReduce = arr.reduce((total, el) => {
            return total + el
        }, 0);  // 15
    


    //++++++++ ++++++++ ++++++++ ++++++++
    

    // flat - возвращает ***НОВЫЙ массив в котором раскрывает 1 степень вложенности массива   ***НЕ ИЗМЕНЯЕТ исходный массив
        const arr2 = [0, [1, 2], [3, [4, 5], [6, 7] ] ];  //  [0, Array(2), Array(3)]
        const arrFlat = arr2.flat(); // (6) [0, 1, 2, 3, Array(2), Array(2)]
        arrFlat.flat(); // (8) [0, 1, 2, 3, 4, 5, 6, 7]    Можно записать как arr.flat().flat()
    

    // indexOf Возвращает индекс элемента. первый аргумент - искомый элемент, второй - с какого индекса начинать искать
        arr.indexOf(1); // 0
        arr.indexOf("six"); // -1  - если не найдено совпадений
        arr.indexOf(1, 1); // -1
    


    // lastIndexOf - Начинает искать с конца массива. первый аргумент 
        arr.lastIndexOf(1); // 0
        arr.push(1);
        arr.lastIndexOf(1); //5
        arr.lastIndexOf(1, 1); //0
        arr.lastIndexOf("six"); // -1
    


    /* slice - обрезает часть массива и возвращает обрезанный кусок в виде массива. 1 аргум - с какого обрезать, 2й - до какого
                                                                                     ***НЕ ИЗМЕНЯЕТ исходный массив  */
        arr.slice(1, 5); // (4) [2, 3, 4, 5]
        arr.slice();     //(6) [1, 2, 3, 4, 5, 1]
        
    //fill - заполняет массив заданным аргументом - 1й, 2й - с какого по какой 3й аргумент заполнить  ***ИЗМЕНЯЕТ исходный массив
        
        arr.fill(0) // (6) [0, 0, 0, 0, 0, 0]
        arr.fill(1, 0, 3) // (6) [1, 1, 1, 0, 0, 0]
    
    // join - преобразует массив в строку с разделителем который принимает. Возвращает строку. ***НЕ ИЗМЕНЯЕТ исх. массив
        
        arr.join() // '1,1,1,0,0,0'
        arr.join('') //'111000' - пустая строка
        arr.join(' ') //'1 1 1 0 0 0'   пробел
    
    // reverse - изменяет порядок эл. массива на обратный. ***ИЗМЕНЯЕТ исходный массив
        reverse()  //(6) [0, 0, 0, 1, 1, 1]
    

    // sort - сортирует эл. массива. 2 аргумента а и b. Сортировка от меньшего к большему a - b, b - a - от большего к меньшему
    
        let arr3 = [10, 5, 2, 15, 11];                  //   Имена произвольные         ***ИЗМЕНЯЕТ исходный массив
        arr3.sort((a, b) => {
            return a - b
        })

        let arr = [2, 1, 3, 15, 6, 5, 4];
        let arr2 = ['Banana', 'Orange', 'Apple', 'Mango'];
        arr2.sort(); //['Apple', 'Banana', 'Mango', 'Orange'] - сортирует элементы в массиве в алфавитном порядке по первой букве
        arr.sort(); // [1, 15, 2, 3, 4, 5, 6]; - (если цифры то они тоже воспринимаются как строка и сравнение происходит по
                                                    //первой цифре)           
            /*Чтобы числа сортировало по возрастанию(как числа), нужно добавить вспомогательную функцию, она принимает параметры - 
                а и b - это соседние элементы массива, при первой итеррации это будут 2 и 1, при второй 1 и 3, и т.д. Функция
                каждый раз возвращает разницу этих элементов а - b, если разница плюсовое число, элементы массива меняются местами,
                если равна 0 или отрицательная то элементы остаются на своих местах.*/
            arr.sort((a, b) => {
                return a - b
            });                 //// [1, 2, 3, 4, 5, 6, 15];

    

    // splice - заменяет определенные эл. массива задаными, возвращает удаленные элем.   ***ИЗМЕНЯЕТ исходный массив
        // 1й аргумент - начальный индекс, 2й - сколько эл. удалить, следующие аргум - добавляемые элем.(может быть больше чем удаляемых)
        arr.splice(3, 2, 'two', 'three', 'four') // (2) [1, 1]  
        arr //(7) [0, 0, 0, 'two', 'three', 'four', 1]
        arr.splice(3, 3, 'new') //(3) ['two', 'three', 'four']
        arr //(5) [0, 0, 0, 'new', 1]
        arr.splice(1, 0, 2) //[]            - не удаляли эл. , а только вставили в индекс 1
        arr //(6) [0, 2, 0, 0, 'new', 1]
    
   
    
    //++++++++++++++++++++++ ОБЪЕКТЫ ++++++++++++++++++++
        
        const obj1 = {
            name: 'Maks',
            age: 33,
            hi: function() {console.log(this.name);}
        };

        const obj2 = {
            country: 'Ua',
            skills: ['html', 'css', 'js'],
            obj: {name2: 'Vladimir'}
        };
        const targetObj = {};
    
    
    // Object.assign()  - Копирует свойства, методы и ОБЪЕКТЫ объектов в другой объект. Обращаемся к глобальному классу Object
    // Object.assign(target, source); - 1й объект куда копируем, 2й из которого копируем
    
        Object.assign(targetObj, obj1, obj2);  // копируемых объектов может быть несколько
        targetObj //{name: 'Maks', age: 33, country: 'Ua', skills: Array(3), hi: ƒ}
        const person = Object.assign({}, obj1, obj2); // присваиваем константе, аргумент - пустой объект
        person    //{name: 'Maks', age: 33, country: 'Ua', skills: Array(3), hi: ƒ}
        Object.assign(obj1, obj2);//                                                
        obj1      //{name: 'Maks', age: 33, country: 'Ua', skills: Array(3), hi: ƒ}   ***ИЗМЕНЯЕТ исходный массив obj1
    
    

    //Object.entries(obj) - принимает объект и возвращает массив с вложенными массивами
    
        Object.entries(obj2); //(3) [Array(2), Array(2), Array(2)]
        // 0: (2) ['country', 'Ua'] 1: (2) ['skills', Array(3)] 2: (2) ['obj', {…}]
        //Вложенные массивы и объекты обекта - сохраняют свою структуру
    

    
    //Object.fromEntries([]) - принимает массив с лож. массивами и вернет объект
    
        const obj3 = Object.fromEntries([['name', 'John'],['age', 44]]); // {name: 'John', age: 44}
        obj3 // {name: 'John', age: 44}
    
    

    //Object.is(el1, el2) - определяет являются ли оданиковыми эти два значения, возвращает true / false
    
        Object.is(1, 2) //false
        Object.is(1, 1) //true
        Object.is(1, '1') //false
        Object.is(NaN, NaN) //true  - только при этой проверке NaN равняется NaN
    
    

    //Object.keys(obj) - возвращает массив из ключей (название свойств, методов, объектов объекта)
    
        Object.keys(obj3) //(2) ['name', 'age']
        Object.keys(obj2) //(3) ['country', 'skills', 'obj']
        
        

    //Object.values(obj) - возвращает массив из значений (сохраняет структуру вложенных ассивов и объектов)
    
        Object.values(obj3) //(2) ['John', 44]
        Object.values(obj2)  // (3) ['Ua', Array(3), {…}]
    
    

    // ++++++++  ПРИСВОЕНИЕ в ОБЪЕКТАХ    bind, call, apply - позволяют изменить контекст вызова (изменить this)
    
    const person1 = {
        name: 'Maks',
        age: 33,
        getInfo: function(country, standart) {
            if(standart){
            return `Hi, my name is ${this.name}, i'm from ${standart}`
            }else{
            return `Hi, my name is ${this.name}, i'm from ${country}`};}
    };
    const person2 = {
        name: 'Oleg',
        age: 18,
    };
    
    
    /* 1) bind - возвращает метод присвоенного объекта(присоединяет метод одного объекта к контексту другого)
        obj1.method.bind(obj2)() -  obj2 - объект контекст которого используем для метода obj1
        
        console.log(person1.getInfo('Ua')); // Hi, my name is Maks, i'm from Ua
        console.log(person2.getInfo('Ua')); // Получаем ошибку
        
        console.log(person1.getInfo.bind(person2)); // ƒ (country) {return `Hi, my name is ${this.name}, i'm from ${country}`}
                                        не срабатывает как нужно потому что в country передается объект, а в стандарт ничего.
        console.log(person1.getInfo.bind(person2)('Ukr')); // Hi, my name is Oleg, i'm from Ukr - вызываем функцию
                                        Срабатывает потому что передается два аргумента.

            Может принимать несколько параметров
        console.log(person1.getInfo.bind(person2)('Ukr', 'Ukraine')); //// Hi, my name is Oleg, i'm from Ukraine
            или
        console.log(person1.getInfo.bind(person2, 'Ukr', 'Ukraine')()); //// Hi, my name is Oleg, i'm from Ukraine
        
        const getInfoPerson2 = person1.getInfo.bind(person2); // присваиваем метод переменной для сокращения вызова
        console.log(getInfoPerson2("Ru")) // "Hi, my name is Oleg, i'm from Ru"   */
    
    
    /* 2) call - ***НЕ ВОЗВРАЩАЕТ функцию, изменяет контекст передавая параметры, поэтому скобки вызова отсутствуют
        console.log(person1.getInfo.call(person2, 'Ukr', 'Ukraine'));
        
        Так как метод не привязывается к функции то невозможно позже через вызов переменной задавать новые параметры, их нужно
        присвоить переменной сразу
        const getInfoCall = person1.getInfo.call(person2, 'Ukr');
        console.log(getInfoCall);   */
        
        
        // 3) apply - не привязывает метод. Работает как и call но синтаксис другой(запись)
        // console.log(person1.getInfo.call(person2, ['Ukr'], ['Ukraine'] ));
    
    
    
    //++++++++++++++++++++++ ЧИСЛА ++++++++++++++++++++
    
    //Обращаемся через глобальный объект Number
    
    //isInteger - проверяет целое число или нет. Возвращает true / false
        Number.isInteger(10) // true
        Number.isInteger(10.5) // false
    
    //isFinite() - определяет передаваемый параметр число или нет true / false
        Number.isFinite(1) //true
        Number.isFinite('1') //false
        // но если обращатся без Number то происходит преобразование к числу и сравнение
        isFinite(1) //true
        isFinite('1') //true
        isFinite('') //true
        isFinite([1]) //true
        isFinite('o') //false
        isFinite({}) //false
    
    //parseInt - преобразует содержимое в целое число (обрезая остальное если числа в начале) и возвращает его
        parseInt('1.6 bb') //1
        parseInt('bb') //NaN
    
    //parseFloat - преобразует содержимое в дробное число
        parseFloat('1.6'); // 1.6
        
    //toFixed - вызывается у числа обернутого в скобки для округления к целому числу, возвращает число в СТРОКЕ
        (5.4).toFixed(); // 5
        (5.555555).toFixed(2) // '5.55'   (2) - Параметр определяет знаки после запятой
        +(5.556666).toFixed(2) // 5.56 - через + получаем число
    
    

    //++++++++++++++++++++++ MATH ++++++++++++++++++++
    
    // ceil - округляет к ближнему большему целому числу
        Math.ceil(25.1) // 26
    

    // floor - округляет к ближнему меньшему целому числу
        Math.floor(25.9999) // 25
    

    // round - округляет к  целому числу
        Math.round(25.1) // 25
        Math.round(25.9999) // 26
    

    // min - из принимаемых элементов возвращает наименьший
        Math.min( 20, 10, 5, 15) //5
    

    // max - из принимаемых элементов возвращает наибольшее
        Math.max( 20, 10, 5, 15) //20
    

    // trunc - удаляет дробную часть
        Math.trunc(25.55) // 25
    

    // random - возвращает случайное число от 0 до 1
        Math.random() // 0.43748290973274084

}


{/*  ====    Понимание ВЕСА CSS-селекторов    ====

        Опубликовано Feb 15, 2015 в «CSS»
        Введение
        Как и любая моя статья, эта начинается с введения. Дабы не говорить на разных языках, начнём с самых основ в мире CSS, 
        то есть с терминологии. Чувствую себя преподавателем в университете — как же это круто.

        Для того чтобы успешно разбираться в CSS и стать крутым специалистом в этой области, нужно первым делом разобраться с тем, 
        что называют селектором. На изображении ниже представлена простейшая структура CSS-правила.

        Простейшая структура CSS-правила

        Селектор — это строка, представляющая собой формальное описание структуры, на основе которого выбирается элемент или группа
         элементов в дереве документа и применяется объявленный блок свойств.

        Селекторы бывают самые разные. Существуют простые селекторы, например, состоящие из одной буквы или одного слова, и 
        сложные, состоящие из большого количества слов и различных синтаксических конструкций.

        Я не буду вдаваться в подробности того, что селекторы должны начинаться с буквы и некоторых других символов. Я также не 
        буду говорить про неинтересные прописные истины, которые можно найти в любой статье на тему основ CSS. Речь в этой статье 
        пойдёт про вес CSS-селекторов, а если говорить простым языком — о его числовом представлении и понимании.

        Вес селекторов
        Нет, здесь не идёт речь об их реальном весе (его нет), а также о количестве символов. Такой вес нельзя измерить весами, 
        так как он не вещественен в обычном понимании и вообще не существует в нашем с вами мире людей. Зато он есть в виде нулей 
        и единиц. Получается, что селектор можно взвесить, используя некую систему, о которой мы и будем говорить дальше.

        Что такое вес селектора?
        Вес селектора — это условные четыре позиции x, x, x, x, которые заполняются нулями и единицами в соответствии с содержимым 
        селектора. Каждая из позиций имеет своё содержимое:

        Инлайн стили
        Идентификаторы
        Классы, атрибуты и псевдоклассы
        Теги и псевдоэлементы
        Как это читать?
        Очень просто. Справа налево. Слева идут числа старшего разряда, поэтому они имеют больший вес, числа, идущие справа, 
        наоборот, имеют наименьший вес. Всё это станет понятным дальше, поэтому можно даже не вдумываться в смысл этого абзаца.

        Как заполнять?
        Немного сложнее, чем читать. Рассмотрим предложенную систему четырёх позиций на реальном примере для того, чтобы понять 
        всю технологию.

        h1 {
        color: #777;
        }
        В этом примере селектором выступает заголовок h1, который состоит из одного тега. Получается, что напротив столбца «тег» 
        мы ставим единичку. Получается следующая картина: 0, 0, 0, 1.

        Всё это замечательно, но в реальных проектах встречается разве что в ядре стилей или normalize, а это значит, что нужно 
        усложнить задачу.

        #main .container article.post > header h1.giga {
        color: #777;
        }
        Пример получился хардкорнее, чем предыдущий и в реальной жизни достоин премии «самого избыточного селектора». Такая 
        избыточность должна преследоваться по закону, но подробнее на эту тему мы поговорим в отдельной части статьи. Окей, 
        вернёмся к примеру и немного поработаем весами.

        Давайте начнём слева, так как в начале стоит единственный идентификатор #main. Далее мы видим три класса 
        .container, .post и .giga, а также три тега article, header и h1. Для ещё большей наглядности я распишу это в виде этапов:

        // Селектор
        #main .container article.post > header h1.giga

        // Начальный вес
        0, 0, 0, 0

        // Идентификаторы
        #main         0, 1, 0, 0

        // Классы, атрибуты и псевдоклассы
        .container    0, 1, 1, 0
        .post         0, 1, 2, 0
        .giga         0, 1, 3, 0

        // Теги и псевдоэлементы
        article       0, 1, 3, 1
        header        0, 1, 3, 2
        h1            0, 1, 3, 3

        // Итог
        #main .container article.post > header h1.giga
        =>
        0, 1, 3, 3
        Давайте напишем какой-нибудь безбашенный селектор, который я, надеюсь, никогда не увижу ни у кого в коде:

        // Селектор
        body.page-posts #main .container article.post ul.list-unstyled > li:first-child h2.article-title:hover {
        color: #333;
        }

        // Начальный вес
        0, 0, 0, 0

        // Идентификаторы
        #main             0, 1, 0, 0

        // Классы, атрибуты и псевдоклассы
        .page-posts       0, 1, 1, 0
        .container        0, 1, 2, 0
        .post             0, 1, 3, 0
        .list-unstyled    0, 1, 4, 0
        :first-child      0, 1, 5, 0
        .article-title    0, 1, 6, 0
        :hover            0, 1, 7, 0

        //  Теги и псевдоэлементы
        body              0, 1, 7, 1
        article           0, 1, 7, 2
        ul                0, 1, 7, 3
        li                0, 1, 7, 4
        h2                0, 1, 7, 5

        // Итог
        body.page-posts #main .container article.post ul.list-unstyled > li:first-child h2.article-title:hover
        =>
        0, 1, 7, 5
        Ну и напоследок, для полного понимания темы, будет пример с атрибутами и псевдоэлементами.

        // Селектор
        .main[data-columns]:before {
        content: "3 .column.size-1of3";
        }

        // Начальный вес
        0, 0, 0, 0

        // Идентификаторы
        0, 0, 0, 0

        // Классы, атрибуты и псевдоклассы
        .main             0, 0, 1, 0
        [data-columns]    0, 0, 2, 0

        //  Теги и псевдоэлементы
        :before           0, 0, 2, 1

        // Итог
        .main[data-columns]:before
        =>
        0, 0, 2, 1
        Вот такие вот дела.

        На самом деле, тема очень простая, но очень важная на практике для посредственного (минимального) понимания того, как 
        браузер определяет какой блок объявлений необходимо применить к тому или иному элементу на странице.

        А что, если вес селекторов одинаковый?
        Допустим, что у вас есть два или несколько селекторов так или иначе указывающих на один и тот же элемент. И вот так 
        сложилось, что вы посчитали или просто взглянули на них, и вес оказался одинаковым. Не стоит отчаиваться, просто блок 
        объявлений последнего селектора в вашем CSS-коде из этой группы и будет применяться к элементу. Как-то так. Мне кажется 
        это логичным. Прямо как в поговорке «кто не успел, тот опоздал», но наоборот: «кто опоздал, тот и успел».

        Зачем это нужно?
        Это очень интересный момент, ибо понять какой блок объявлений будет применяться к элементу, можно и без расчёта веса 
        селектора, то есть просто посмотрев на него и слегка подумав. Однако, глазомер может подвести, а вот машина не подведёт, 
        посчитает вес и испортит вёрстку. Ошибка, конечно, не машины, а прослойки между компьютером и стулом, но это уже совсем 
        другая история.

        Ещё одним применением такого вот расчёта являются сервисы или скрипты, которые строят диаграммы специфичности CSS. Это 
        может быть очень удобно для анализа и оценки избыточности вашего кода.

        Интересным фактом будет то, что единственный раз, когда мне приходилось считать вес селектора, был тестом от Mail.ru на 
        какой-то сертификат. Если интересно, то я поищу этот тест у себя в истории.

        Я ленивый и не хочу понимать, как считать вес селекторов, что тогда?

        Ох, специально для вас у меня есть сервис, на который я наткнулся при подготовке к изложению этого материала: 
        Specificity Calculator — это простой и эффективный калькулятор веса селекторов.

        Специфичность селекторов
        Раз уж зашла речь про вес CSS-селекторов, то неизбежно задумываешься о том, как бы его оценить: когда нужно ему худеть, 
        а когда наоборот — поправляться. Как и у человека, у селекторов всё таки есть оптимальный вес.

        Так сложилось, что многие веб-разработчики считают оптимальной специфичностью селекторов три вложения. Максимальной 
        специфичностью селекторов называется пять вложений и рекомендуется стараться это число не превышать. Разумеется, вложений 
        может быть и больше, так как в жизни всякое бывает. Хотя, лучше всего, если вы всё таки будете соблюдать эту рекомендацию 
        хотя бы косвенно. Такой подход вам поможет сэкономить время в будущем.

        Хорошо, всё это замечательно, но причём тут вес? — да очень просто, он напрямую от этого зависит. Чем больше вложений, 
        тем больше вес. Логично, однако.

        Оценить ваш CSS-код можно с помощью ресурса CSS Specificity Graph Generator. По предложенному вами CSS-коду строится 
        интерактивный график специфичности вашего кода, на котором можно визуально определить проблемные участки ваших стилей.

        Выводы
        Постарайтесь поддерживать оптимальный вес селекторов и изредка проводите рефакторинг кода. Сначала это кажется избыточным 
        и ненужным, но в итоге это может сыграть с вами плохую шутку.

*/}





//==============================================  UDEMY COURSE ===================================================================
// 200 ======================================= ОСНОВЫ Java Script ================================================================
                                 

                                    //ДЛЯ ЭТОГО КУРСА НУЖНы ЗНАНИЯ БАЗОВОЙ ВЕРСТКИ


{//  201    ====    ЧТО ТАКОЕ JS и как его ПОДКЛЮЧИТЬ

    // При создании любого сайта используют несколько технологий HTML - это скелет нашего сайта(язык разметки) на него добавляются
        // стили CSS (шрифты, цвета, расположение элементов), а для того что бы все это работало используют JS(для взаимодействия
        // страницы с пользователем), PHP(для взаимодействия страницы с сервером или базой данных), базы данных, и т.д.

    // Изначально JS был придуман для создания интерактивности на странице и взаимодействия с пользователем(меню, подсказки,
        // слайдеры, табы), те элменты на которые пользователь может нажать или как то взаимодействовать. Отсюда вывод что нам
        // нужно уметь работать со структурой стайта(документа). 

    // Сейчас с помощью JS можно создавать серверные программы(NODEjs), десктопные программы(ELECTRONjs), 
        // мобильные приложения(react native), виртуальную реальность (React 360) и многое другое, но что бы зайти так далеко
        // для начала нужно выучить БАЗОВЫЙ(ванильный/нативный) JS который работает в браузере, тот с которого всё и началось.

    // Базовый JS имеет свои ограничения - он не умеет работать с файлами на компьютере и не работает между вкладками браузера,
        // это сделано в целях безопасности. JS высокоуровневый язык - это значит что браузер будет воспринимать наш код так
        // как он написан без перевода(компиляции) в двоичную систему. Был создан для непрограммистов поэтому он легче в
        // изучении/использовании и большинство комманд - английские слова и словосочетания.



    // +++ ПОДКЛЮЧЕНИЕ JS

    // JS (script.js) как и файлы стилей (style.css) подключается в основном файла страницы который обычно назыают index.html.
        // ХТМЛ страница имеет свою структуру
        
        // <!DOCTYPE html>
        //     <html lang="ru">

        //         <head>
        //             <meta charset="utf-8">
        //             <meta http-equiv="X-UA-Compatible" content="IE=edge">
        //             <title>JavaScript</title>
        //             <link rel="stylesheet" href="css/elements_style.css">
        //         </head>

        //         <body>
        //              <p> Hello World.</p>
        //             <script src="js/elements_script.js"></script>
        //         </body>

        //     </html>

    // Можно подключить как в 1)сам документ, так и в 2)отдельный файл. 
    
    // *** 1) - используется для очень маленьких скриптов и в реальных проектах скорее всего мы его не увидим, потому что там
        // много кода и что бы не загромождать ХТМЛ файл, чтобы он нормально читался, скрипт JS подключают как отдельный файл.
        // Откроем нашу страницу и увидим текст Hello World. Потом пропишем в теге body тег скрипт(подключим JS) 
        // <script> alert("Hello") </script>

        //Сохраним файл JS и обновив браузер увиди сообщение Hello в выпрыгнувшем окне.


    // *** 2) - Для этого метода создадим в папке проекта папку - js и в ней создадим файл с раширением js - script.js
        // Для подключения также используем тег скрипт только теперь он будет пустой а в аттрибуте src(source) указываем путь 
        // к файлу с кодом.
        // <script src="./js/script.js"></script>

        // В файле пропишем команду console.log("Hello in console");
        // Открываем нашу страницу(index) и видим что ничего не изменилось, потому что эта команда console.log выводит сообщение
        // в консоль. Ее обычно можно открыть f12, ctrl+shift+I или клацнув правой кнопкой мыши на странице и выбрав пункт -
        // просмотреть код- вкладка console. Там и увидим наше сообщение Hello in console.

        // При таком подключении скрипта в файле если мы внутри тега скрипта начнем писать код, то он будет игнорироваться, нужно
        // или писано в новом теге скрипта или в файле.
        // В старом коде можно встретить в теге скрипт аттрибут type="text/javascript" - его нужно удалять потому что валидатор
        // будет на него ругаться.

    // +++ МЕСТО ПОДКЛЮЧЕНИЯ
        // Сейчас в начале курса мы подключаем скрипт в самый конец ХТМЛ страницы перед закрывающим тегом </body>. Это делается
        // для того что бы мы избежали ошибок. 

        // БАЗОВОЕ ПРАВИЛО ВЕРСТКИ (как строится страница). Браузер открывает наш документ - видит какой тип документа <!DOCTYPE html>
        // какой язык установлен. Потом переходит к тегу head видит кодировку страницы смотрит на тайтл страницы (title), если
        // тут будут какие-то стили - подключает их. После этого переходит к тегу body и начинает загружать всю верстку элемент
        // за элементом, а в самом конце увидит скрипт и подключит его.

        // Если мы подключим скрипт в head то сначала будет выполнятся код скрипта и при обращении из него к какому-то элементу
        // на странице сделать это будет невозможно, потому что этот элемент еше не будет построен, так как верстка еще будет
        // ждать окончания выполнения скрипта. И второй главный минус такого подхода - если скрипт будет большой или лежат
        // на каком то сервере то пока он обработается пользователь будет смотреть на пустую страницу пока подгрузится/выполнится
        // потому что верстка не сформируется.

}



{/*  202    ====    ПЕРЕМЕННЫЕ И СТРОГИЙ РЕЖИМ    ====

    =(равно) - знак присваивания. Название переменной не должно начинаться с цифры и не должно совпадать с зарезервированными названиями
    и может содержать буквы, цифры и знак доллара и нижнего подчеркиния. Записываем кемэл кейсом. Num и num - разные переменные


    let -(можно использовать переменную после ее объявления) изменяемая переменная с ограниченной областью 
    видимости(в пределах фигурных скобок {} если объект или функция, если в основной зоне видимости тогда - глобальная)


    const - (используется только после того как объявлены)(константа), ограниченная областью видимости
    не изменяется на прямую, но если задать объект, то его можно изменять. Прямых констант в JS нет.

    const obj = {
        a: 50
    }
    obj.a = 10;
    console.log(obj);// {a:10}


    var (старый метод задания переменной), существует еще до того как была объявлена(всплытие переменной при первом проходе браузера) 
    поэтому будет undefined  вместо ошибки 

    console.log(name);
    var name = "Ivan";
    это затрудняет debugging. проблемы: глобальная область видимости из любого места, поднятие кода(всплытие переменной, hoisting)


    Новый стандарт let и const не поддерживается в старых версиях браузеров, тогда нужно программой-конвертером переводить код в 
    старый режим, для того что бы использовать новый режим существует директива "use strict"; - существует для вывода ошибок.
    прописывается на первой строке кода при этом также не работает такое выражение a = 15; будет выдавать ошибку.

*/}



{/*  203    ====    ТИПЫ ДАННЫХ    ====

    Тип данных можно проверить typeof.  console.log(typeof(5));


    +++ ПРОСТЫЕ ТИПЫ (примитивы): 

    1) Числа (1, 2, 3.2) , infinity - получается при делании на 0(может быть отрицательной если делить отрицательное число на 0)
    NaN (not a number)- получается при операции с не математической логикой ("string" * 9)

    2) Строки ("string", 'name', `you are ${years}`, "5")

    3)Логический тип(boolean) (true, false) 

    4) null - что то чего не существует. null в консоль получаем редко, чаще будет ошибка ReferenceError: something is not defined
    ошибка ссылочного типа, которая говорит что мы ссылаемся на не существующий объект.

    5) undefined - существует но значение не определено.

    6) Symbol 

    7) BigInt - тип данных для больших чисел больше чем 2 в 53 степени.


    +++ КОМПЛЕКСНЫЕ (объекты)

    обычные объекты - коллекция данных, может содержать разные типы данных (свойства) и действия(методы) */
    const obj = {
        age: 10, 
        name: "John",
        say: function() {
            console.log("Hello");
        },
        isMarried: false
    }
    console.log(obj.age); //10       
    console.log(obj["age"]);//10
    console.log( obj.say() ); // Hello

    /* +++ СПЕЦ. ОБЪЕКТЫ: 

    1) Массивы ["text", 6, {}, [], true] - частный случай объектов, конструкция для хранения данных строго по порядку. 
    Первый элемент под номером 0. let arr = [6, true]; console.log(arr[1]); //true
    Для записи эл. в массив используем arr[0] = "9";

    2) Функции
    3) Объекты даты
    4) Регулярные выражения 
    5) Ошибки

*/}



{//  204    ====    alert, confirm, prompt, document.write    ====

    //alert, confirm, prompt Эти события не могут быть стилизированы и их вид зависит от браузера. Они вызывают модальные окна
    // которые блокируют построение страницы.


    //alert - окно предупреждения имеет 1 кнопку -  ок
    alert("hello"); 


    // confirm - 2 кнопки ок и отмена.
    const result = confirm("are u here?"); // Результат нажатия этих клавиш будет записан в result
    console.log(result); //При нажатии ок - true, false - при нажатии кнопки отмена


    //prompt - 2 кнопки (ок и отмена) и поле ввода.
    const answer = prompt("Вам есть 18", "");//первый аргумент вопрос, второй аргумент пустые кавычки, 
    //для получения ответа пользователя в них можно указать значение по умолчанию prompt("Вам есть 18", "18")
    //ответ пользователя приходит в виде строки, что бы перевести в число ставим плюс впереди +prompt;
    console.log(answer);
    console.log( typeof(answer) );
    //если просто promt - при закрытии окна Esc или Отмена - получим null (объект)
    //если +prompt - 0 (number), если введут что то кроме числа - NaN (number)


    //Помещаем ответы в массив
    const answers = [];

    answers[0] = prompt("Как ваше имя?", "");
    answers[1] = prompt("Как ваша Фамилия?", "");
    answers[2] = prompt("Сколько вам лет?", "");

    //Если записать в консоле на сайте то заменяет все содержимое страницы
    document.write(answers);

}



{//         ====   СОРТИРОВКА МАССИВА (сортировка по порядку)    ====

    const arr = [1, 14, 4, 30, 54];
    let sorted = arr.sort(CompareNum);
    console.log(sorted); // [1, 4, 14, 30, 54]

    function CompareNum(a, b){
        return a-b;
    };


    let arr = [2, 1, 3, 15, 6, 5, 4];
    let arr2 = ['Banana', 'Orange', 'Apple', 'Mango'];
    arr2.sort(); //['Apple', 'Banana', 'Mango', 'Orange'] - сортирует элементы в массиве в алфавитном порядке по первой букве
    arr.sort(); // [1, 15, 2, 3, 4, 5, 6]; - (если цифры то они тоже воспринимаются как строка и сравнение происходит по
                                                  //первой цифре)           
        /*Чтобы числа сортировало по возрастанию(как числа), нужно добавить вспомогательную функцию, она принимает параметры - 
            а и b - это соседние элементы массива, при первой итеррации это будут 2 и 1, при второй 1 и 3, и т.д. Функция
            каждый раз возвращает разницу этих элементов а - b, если разница плюсовое число, элементы массива меняются местами,
            если равна 0 или отрицательная то элементы остаются на своих местах.*/
        arr.sort((a, b) => {
            return a - b
        });                 //// [1, 2, 3, 4, 5, 6, 15];

}



{//  205    ====    ИНТЕРПОЛЯЦИЯ (ES6)    ====

    //Интерполяция - вставка значения переменной внутрь строки, используя кавычки на тильде(косые бэктики - кнопка под Esc).


    //Задача - подставить в пусть перехода по ссылке переменную category. До ES6 реализовывалось через конкатенацию строк.
    const category = 'toys';
    console.log('https://someurl.com/' + category);

    //Далее есои нужно перейти на четвертую игрушку например, код начинает выглядеть не очень красиво и удобно
    console.log('https://someurl.com/' + category + '/' + '4');

    //Теперь это реализуется интерполяцией
    console.log(`https://someurl.com/${category}/4`);
    //Можно динамически менять содержимое строки в зависимости от  пришедших данных.

}



{//  206    ====    ОПЕРАТОРЫ    ====

    //Вычитание(-), умножение(*), деление(/) - работают также как в матиматике. 


    // +++ СЛОЖЕНИЕ (+)

    //При сложении Двух строк или строки с чем-либо получим строку(конкатенация)
    console.log('arr' + ' - object'); // arr - object  - строка
    console.log(4 + ' - object');     // 4 - object    - строка
    console.log(4 + '5');             // 45            - строка

    // Плюс перед строкой (унарный - ставится перед чем то(использует только 1 аргумент)) позволяет получить из нее число
    console.log(4 + +'5');            // 9             - строка


    // +++ ИНКРЕМЕНТ(++) и ДЕКРЕМЕНТ(--)

    // Используются для укорочения кода. Существуют префиксные и постфиксные.

    let incr = 10,
        decr = 10;

    //Префиксные - сначала возвращает старое значение, а потом выполняет операцию  
    console.log(++incr); // 11
    console.log(--decr); // 9

    //Постфиксные - сначала выполняет операцию, а потом возвращает значение
    console.log(incr++); // 10
    console.log(decr--); // 10


    // +++ ОСТАТОК ОТ ДЕЛЕНИЯ(%)

    console.log(5%2); // 1
    //5 делится на 2 столько раз сколько может а остаток возвращается.


    // +++ РАВЕНСТВО(==) и СТРОГОЕ РАВЕНСТВО(===)

    console.log(2*4 == 8); // true    - сравнивает по значению, а не типу данных.
    console.log(2*4 == '8'); // true  - сравнение со строкой тоже дает истину.

    console.log(2*4 === '8'); // false - строгое равенство сравнивает сначала типы, если типы не совпадают, дальше сравнение не идет.
    
    console.log(2*4 === 8); // true 


    // +++ ЛОГИЧЕСКИЕ ОПЕРАТОРЫ И(&&) и ИЛИ(||)

    // И(&&) - возвращает true если ВСЕ аргументы true, иначе выводит false 
    const isCheked = true,
        isClose = true,
        isFalse = false;

    console.log(isCheked && isClose); // true
    console.log(isCheked && isClose && isFalse); // false

    // ИЛИ(||) - возвращает true если ХОТЯБІ ОДИН аргумент true, возвращает false если все аргументы false.
    console.log(isCheked || isClose || isFalse); // true


    // +++ ОТРИЦАНИЕ(!) - превращает значение в обратное
    console.log(isCheked && isClose && !isFalse); // true
    console.log(!isCheked || !isClose || isFalse); // false
    console.log(2 + 2 * 2 != 8); // true  - потому что 6 (НЕ) равно 8
    console.log(2 + 2 * 2 != '6'); // false - потому что 6 (НЕ) равно 6
    console.log(2 + 2 * 2 !== '6'); // true - потому что 6 число (НЕ) НЕ равно 6 строке

    // +++ ПОРЯДОК ВЫПОЛНЕНИЯ ОПЕРАТОРОВ - приоритет можно посмотреть по таблице
    console.log(2 + 2 * 2 == 8); //false - потому что умножение выполнится раньше и получится 6 == 8


    //Существуют еще побитовые операторы, но в первы годы работы с кодом они не стречаются.

}



{/*  207    ====    GIT    ====

    GIT - система контроля версий, GitHub - сервис для хранения репозиториев.

    Скачать GIT с сайта git-scm.com, установить.

    Для создания репозитория в папке проекта нужно вызвать через shift+правая кнопка мыши - PowerShell или Graphic user inerface.
    Если такой функции нету тогда вызываем cmd прописываем cd(change directory) - и докопируем путь к папке проекта, что бы туда  перейти. Также можно работать с Терминалом в VS Code, что бы в него перейти нужно нажать мышкой в 
    левом нижнем углу на значки крестика в кружочке и треугольника(у меня не получилось через терминал пройти
    к папке именно нужного проекта, только в папке хранения всех проектов открывается).
    Если гит остался с предыдущей виндовс или портабл версия, все действия нужно писать в его окошке.


    Первым действием прописываем комманду git init , для того что бы гит следил за файлами в папке(если все прошло успешно появится сообщение в терминале и в папке с проектом должна появится скрытая папка гита ).

    Сделаем настройки для доступа к гитхабу. Это можно сделать как локально для текущего проекта, так и глобально - 
    настройки будут общими для всех проектов. Если в проекте установлены локальные настройки будут действовать
    они перебивая глобальные настройки. 
    Пропишем 
    git config --local user.name "AoDWork"
    git config --local user.email aodtest07@gmail.com  -второе обязательное поле для заполнения конфига.
    Можно увидеть применились ли настройки в файле конфиг в папке гита.
    Первый раз при настройке на компьютре реекомендуется прописать эти настройки глобально
    git config --global user.name "AoDWork"
    git config --global user.email aodtest07@gmail.com

    У гит репозитория есть три состояния файла: 1) когда файл только создан и просто лежит в папке, 2) когда гит следит
    за определенными файлами(они попадают в индекс), 3) когда гит созздал контрольную точку к которой можно позже 
    вернуться - commit.
    Для того что бы посмотреть статус репозитория пропишем 
    Выдаст такое сообщение  No commits yet
                            Untracked files:(use "git add <file>..." to include in what will be committed)
    
    Далее добавим(add) все файлы(-A) в папке в индекс что бы гит за ними следил
    git add -A 
    Прописав снова гит статус можно увидеть что файлики стали зелеными и гит предлагает сделать контр.точку
    git status
   
    Что бы создать контр. точку прописываем гит коммит -а(все файлы) -m(месседж - описание коммита).
    git commit -a -m"First state"
    Теперь контрольная точка создана(папка с проектом скопирована). При дальнейшем изменении файлов нужно будет
    снова добавлять(add) модифицированные файлы и делать коммит для сохранения.

    Что бы посмотреть какие коммиты были нужно прописать 
    git log

    Для заливки проекта на гитхаб нужно в профиле на гитхабе в директории Repositories нажать кнопку New для создания нового
    репозитория. Прописать имя репозитория -> Create repository(нажать на кнопку). Так как у нас репозиторий в папке проекта уже
    создан пожтому пропускаем первый абзац (create a new repository on the command line) и переходим к заливке репозитория или пуша
    (or push an existing repository)
    
    Копируем эту строчку remote(создается даленный репозиторий) в окно и запускаем
    git remote add origin git@github.com:AoDWork/test.git
    Визуально ничего не изменилось, но теперь локальный репозиторий связан с удаленным.
    
    Далее копируем и запускаем эти строки -u(значит что все следующие пуши будут идти в этот репозиторий)
    git branch -M main  эта комманда переименовывает главную ветку master в main(в связи с движение black lives matter)
    git push -u origin main
    
    Все файлы проекта должны были запушится на гитхаб, о чем сообщило окно терминала и теперь обновив страницу гитхаба мы видим
    наши файлы и папки в репозитории.

    Подробная инструкция и курс по использовнию гита можно пройти на githowto.com

*/}



{/*  208    ====    РАБОТА с GitHub  С РАЗНЫХ КОМПЬЮТЕРОВ, Gitignore, Git Kraken    ====

    Для работы с разных компьютеров (домашний, рабочий). Для начала нужно скачать последнюю версию файлов проекта и Гитхаба на
    компьютер. В репозитории нажимаем на зеленую кнопку Code, и можно выбрать или скачать зип архив распаковать его или строку
    для окна терминала. В окне терминала должна быть выбрана папка в которую будем клонировать проект, далее прописываем
    git clone + адресс скопированный с гитхаба + название папки в которую будет клонироваться
    git clone git@github.com:AoDWork/Git_ignore.git test_work

    После работы с файлами, их нужно заново запушить в репозиторий, для этого
    git add -A
    git commit -a -m"modifyed on work"
    git push

    Для возобновления работы на домашнем компьютере нужно обновить этот проект до последней версии
    git pull
    Всегда перед началом работы с проектом нужно обновлять его состояние до последней версии.

    Ошибка которая может возникнуть если кто то изменил репозиторий а мы не запулили или сами добавили файл на гитхабе и не запулили
    а потом модифицировав другие файлы, пытаемся запушить. 
    Тогда нужно запулить файлы
    git pull
    при этом происходит слияние(merge) проекта локального и удаленного, нужно ввести название коммита без "" - кавычек.
    Далее 2 раз нажать Ctrl+C, внизу освободится поле и курсор перепрыгнет на него, и там ввести 
    :wq!
    Должно произойти слияние. 
    git status              Проверим файлы 
    git push                и далее запушим мердженные файлы 


    +++ Git Ignore
    Игнорирование файлов которые не должны попасть в репозиторий при пуше (node_modules, тяжеловесные файлы которые помогают
    запускать проект на нашем компьютере). Файл .gitignore должен быть в папке с проектом.
    Его структура такая 
    
    # See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

    # dependencies
    /node_modules
    /.pnp
    .pnp.js

    # testing
    /coverage

    # production
    /build

    # misc
    .DS_Store
    .env.local
    .env.development.local
    .env.test.local
    .env.production.local

    npm-debug.log*
    yarn-debug.log*
    yarn-error.log*


    +++ Git Kraken
        Для более удобного вида и работы с ветками проекта существует программа Git Kraken.
    
*/}



{//  209    ====    ПРАКТИКА 1. Создаем консольное приложение    ====

    /*  Изучение новых языков программирования почти всегда начинаются с написания консольных приложений, это общепринятая практика
    Этот проект будет дополнятся и расширять функциональность, так происходит в любом реальном приложении. Также научимся рефакторить
    код проекта.
    
    ЗАДАНИЕ
    1) Создать переменную numberOfFilms и поместить в нее ответ пользователя на вопрос:
    "Сколько фильмов вы уже посмотрели?"

    2) Создать объект personalMovieDB и в него поместить такие свойства:
        - count     - сюда передается ответ на первый вопрос
        - movies    - поместить пустой объект
        - actors    - поместить пустой объект
        - genres    - поместить пустой массив
        - privat    - поместить boolean значение false
    
    3) Задать пользователю по два вопроса:
        - "Один из последних просмотренных фильмов?"
        - "На сколько его оцените?"
    Ответы поместить в отдельные переменные и
    записать в объект movies в формате:
    movies: {
        'logan': '8.1'
    }
    Подсказка: обратиться к свойству в объекте можно двумя способами:
    movies.keyMovie;     keyMovie - свойство объекта
    movies[keyMovie];    - такой метод позволит избежать багов при работе с кирилицей(*если значение ключа динамическое)

    ***Проверить что бы все работало без ошибок в консоли.  */



    //  +++ РЕШЕНИЕ
    {"use strict";
    const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');
    
    const personalMovieDB = {
        count: numberOfFilms,
        movies: {},
        actors: {},
        genres: [],
        privat: false
    };
    
    const movieName = prompt('Один из последних просмотренных фильмов?', ''),
            movieRank = prompt('На сколько его оцените?', ''),   
            movieName2 = prompt('Один из последних просмотренных фильмов?', ''),
            movieRank2 = prompt('На сколько его оцените?', '');
    
    personalMovieDB.movies[movieName] = movieRank;
    personalMovieDB.movies[movieName2] = movieRank2;
    
    
    console.log(personalMovieDB.movies);
    console.log(typeof(personalMovieDB.movies));
    }

}



{//  210    ====    УСЛОВИЯ    ====

    if (4 == 4) {   // при условии 4 равно 4 выполнится следующий код, ***условие ПРЕОБРАЗУЕТСЯ к булевому
        console.log('Ok');
    }
    //Звучит как ЕСЛИ(IF) 4 равно 4 тогда в консоль выведется сообщение.

    if (4) {   // такое условие будет всегда true
        console.log('Ok');
    }


    //В некоторых случаях нужно пойти от обратного, тоесть если условие не выполнилось то будем делать другие действия ELSE
    
    if (4 == 9) {   // при этом условии выполнится блок елс , в консоль выведется еррор
        console.log('Ok');
    }else {
        console.log('Error'); 
    }  

    //В условие можно поместить содержимое какого то элемента на странице, если содержимое будет - то условие будет true и будет
    //выполнятся, если содержимого не будет, ничего не передастся в условие  преобразуется к false и выполнится блок else.


    //Часто условий много поэтому они проверяются вложенностью условий  -  else if
    const num = 50;

    if (num < 49) {
        console.log('Error');
    } else if (num >100) {
        console.log('Too much');
    } else {
        console.log('Ok');
    }


    //Запись условий при помощи ***тернарного(тройной) оператора
    const num = 50;
    (num === 50) ? console.log('Ok') : console.log('Error'); // Ок
    // Если условие правдивое (true) то выполнится код после знака вопроса и до двоеточия console.log('Ok'), если условие окажется
    //false тогда выполняется код после двоеточия console.log('Error').


    //Когда много условий else if, запись становится неудобной альтернативой является конструкция switch. Классически она всегда 
    // использует *** СТРОГОЕ СРАВНЕНИЕ(по типам), и больше/меньше отсутствуют. Хотя существуют хаки как это обойти.
    const num = 50;
    switch (num){
        case 49:
            console.log('not right');
            break;
        case 100: 
            console.log('not right');
            break;
        case 50: 
            console.log('right');
            break;
        default:
            console.log('Not this time');
            break;
    }
    //После каждой проверки и кода ставится слово break; что бы после выполнения кода совпавшего условия не выполнился 
    //следующий код например default. default - выполняется если ни одно условие не совпало.

}



{//  211    ====    ЦИКЛЫ    ====

    //Циклы используют когда нужно автоматизировать повторяющиеся(однотипные) действия. Одно выполнение цикла, один проход 
    // называется - ИТЕРРАЦИЯ.
    let num = 50;

    
    // +++ WHILE(пока)
    // пока условие верно, выполнять код. После выполнения кода первый раз, снова идет проверка, поэтому чтобы 
    // не сделать бесконечный код, нужно в данном случае увеличивать переменную num++; Код выполняется до тех пор пока условие не
    // станет false - 55 в консоль не выведется потому что при num 55 условие не выполнится, что бы оно вывелось можно прописать
    //(num <= 55), тогда последнее значение будет 55.
    while (num < 55) {  // 50 51 52 53 54
        console.log(num);
        num++;
    }


    // +++ DO WHILE (1 раз Делает(выполняет код), а потом проверяет условие)
    do {
        console.log(num);
        num++;
    }
    while (num < 55);


    // +++ FOR
    // Самый часто использующийся цикл, потому что легко настраивается, состоит из трех необязательных аргументов.  
    //Первый аргумент цикла - начальное условие let i = 1;  і - сокращение от Итерратор. Когда цикл запустится создастся переменная 
    // i со значением 1, которая будет доступна только в этом цикле, извне к этой переменной обратится нельзя. Но можно вернуть
    // финальное значение через return.
    // Второй арг. - условие при котором цикл остановит свою работу.
    // Третий арг. - это шаг цикла, что будт происходить каждый раз в новом цикле, чаще всего конструкция с инкрементом i++, тоесть
    // с каждой итеррацией i будет увеличиваться на 1.
    for (let i = 1; i < 8; i++){ // 1 2 3 4 5 6 7 - выполняется 7 раз
        console.log(i);
    }

    let num = 50;
    for (let i = 1; i < 8; i++){ // 50 51 52 53 54 55 56 - выполняется 7 раз потому что ориентируемся на условие по i.
        console.log(num);
        num++;
    }


    // *** Нужно внимательно следить какое условие мы ставим, потому что можно создать бесконечный цикл и программа или браузер зависнет
    // пример бесконечного цикла for (let i = 1; i < 0; i++) - i - всегда будет больше 0, поэтому условие не сработает.

    //Можно досрочно завершить работу цикла при определенных условиях коммандой - break.
    for (let i = 1; i < 10; i++){ // 1 2 3 4 5  - прерывание цикла при условии i === 6
        if(i === 6) {
            break;
        }
        console.log(i);
    }


    //*** Опертор continue
    for (let i = 1; i < 10; i++){ // 1 2 3 4 5 7 8 9  - пропуск итерации при условии i === 6
        if(i === 6) {
            continue;
        }
        console.log(i);
    }

}



{//  212    ====    ПРАКТИКА 2. Применяем условия и циклы    ====

    /*ЗАДАНИЕ
    1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

    2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
    отменить ответ или ввести название фильма длинее, чем 50 символов. Если это происходит -
    возвращать пользователя к вопросам снова. (К любой строке можно обратиться str.length - получить ее длинну)

    3)При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
    "Просмотрено довольно мало фильмов", 10-30 "Вы классический зритель", больше 30ти "Вы киноман".
    Если не подошло ни одного варианта - "Произошла ошибка"

    4) Потренироваться и переписать цикл еще двумя способами. */



    //  +++ РЕШЕНИЕ
    {    "use strict";
        const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

        const personalMovieDB = {
            count: numberOfFilms,
            movies: {},
            actors: {},
            genres: [],
            privat: false
        };

        //При сравнении нажатий на кнопку отмена -null и кнопки ок без данных(пустой строки) - '', они превращаются в 0 и засчитывается
        //  первый ответ, а не ошибка, в последующем мы это исправим, такие случаи нужно держать в голове и уметь с ними работать.
        if (personalMovieDB.count < 10){
            console.log("Просмотрено довольно мало фильмов");
        }else if(personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
            console.log("Вы классический зритель");
        }else if(personalMovieDB.count >= 30) {
            console.log("Вы киноман");
        }else {
            console.log("Произошла ошибка");
        }

        for (let i = 0; i < 2; i++) {
            const movieName = prompt(`Один из последних просмотренных фильмов? ${i}`, ''),
                movieRank = prompt('На сколько его оцените?', '');
            // первая и вторая переменная не равна null - который получаем при нажатии кнопки отмены и не равны пустой строке '' 
            // и первая переменная не длинее 50 символов. Что бы не было таких длинных цепочек можно называеть переменные которые не 
            // используются дальше в коде(технические) короткими названиями a и b - например.
            if(movieName != null && movieRank != null && movieName != '' && movieRank != '' && movieName.length < 50) {
                personalMovieDB.movies[movieName] = movieRank;
                console.log('Done');
            }else{
                console.log('Enter valid data');
                i--;    // если введены неправильные данные то цикл вернется на 1 итерацию назад уменьшая i на единицу и вопрос будет 
                        // задан повторно
            }
        }

        console.log(personalMovieDB.movies);
        console.log(personalMovieDB);
    }

}



{//  213    ====    ФУНКЦИИ, ФУНЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ, СТРЕЛОЧНЫЕ ФУНКЦИИ    ====

    // Функции - это наши действия в JS. Используют различные типы данных и изменяют информацию так как мы укажем. Также как циклы
        // значительно сокращает код. Можно представить функцию как калькулятор мы задаем числа и что с ними нужно сделать, а под
        // капотом происходят вычисления.


    // *** Объявление функции через ключевое слово function и название(имя функции) showFirstMessage. В круглые скобочки передаем
        // аргументы функции если они нужны, в фигурных находится выполняемый код. Аргументов может быть бесконечное количество, они
        // записываются через запятую function showFirstMessage(text, arg, num). 
        //* Переменные созданные внутри функции с помощью let и const работают только в этой функции(локальная область видимости)
        // их называют локальные переменные. 
    function showFirstMessage(text) {
        console.log(text);
        let num = 20;       
    }
    // ЧТобы функция начала работу необходимо ее вызвать, если функция использует аргументы их тоже передаем при вызове.
    showFirstMessage('Hello World!'); //'Hello World!'

    // Негласное правило - называть функцию глаголом с припиской того над чем выполняется действие. showFirstMessage - показать
        // первое сообщение, showForm, getName. Некоторые функции могут быть анонимными - без имени, они вызываются и используются 
        // сдесь и сейчас поэтому имя им не дают.

    // Чтобы изменять переменную при помощи функции в общей области видимости(глобально) нужно ее объявить в общей области, а в
        // функции уже просто с ней работать без объявления.
    let num = 20;

    function showFirstMessage(text) {
        console.log(text);
        num = 10; 
    }
    showFirstMessage('Hello World!'); //'Hello World!'
    console.log(num); // 10 - значение переменной изменилось после вызова и отработки функции.
    //Если в самой функции объявить такую же переменную но локальную let num = 10; то ошибки не будет, но и при вызове функции
        // глобальная переменная останется 20, и в консоль выведется тоже 20 потому что консоль лог нажодится в одной области
        // видимости с глобальной переменной и ничего не знает про локальную.


    // *** Замыкание - это сама функция вместе со всеми внешними переменными которые ей доступны.
        //Когда у нас в какой либо функции есть обращение к переменной, сначала функция ищет эту переменную внутри себя,
        // если не находит, то выходит на уровень выше и ищет там.
    let num = 20;

    function showFirstMessage(text) {
        console.log(text);
        let num = 10; 
        console.log(num); // 10
    }
    showFirstMessage('Hello World!'); //'Hello World!'
    console.log(num);   // 20


    // *** return.
    // return возвращает значение ф-и(в глобальную область видимости) из функции, и после этого слова она прекращает свое действие.
    function calc(a, b) {   // такую функцию можно переиспользовать много раз с различными аргументами
        return (a + b);
        console.log('Hi');  // - этот код не выполнится.
    }
    console.log(calc(1, 1)); // 2 
    console.log(calc(2, 2)); // 4

    function ret() {
        let num = 50;
        return num;
    }
    const anotherNum = ret(); // присваиваем переменной возвращенное значение что бы к нему можно было обратиться
    console.log(anotherNum); // 50


    //*** Объявление функции (FUNCTION DECLARATION) - Создается до начала выполнения скрипта(до запуска кода) при первом проходе
        // браузера по коду когда он находит все переменные var и function declaration, аналогично с переменной объявленной 
        // при помощи var, но в случае с функциями ошибок не возникает,  можно вызвать перед объявлением
    function ret() {
       код
    }   // - при этом способе точка с запятой не ставится


    //*** Функциональное выражение (FUNCTION EXPRESSION) - Создается только тогда, когда доходит очередь(поток кода), можно
        // вызвать только после объявления(создания).
    let ret = function() {
        код
    }; // - при этом способе точка с запятой обязательна, потому что мы создаем переменную


    //*** Стрелочные функции - не имеют своего контекста вызова (this)
    () => {};
    
    const calc = (a, b) => { 
        console.log('Hi');
        return a + b;
    };

    // Сокращенная запись если функция в одну строчку. 
    const calc = (a, b) => a + b;       // ***если тело ф-и пишем в той же строке что и ее имя - это заменяет return
    
    let sum = a  =>  a * 2;             // если параметр один то можно записать без круглых скобок

    let sum = ()  =>  console.log("Hi");     // если параметров нету указываем пустые скобочки

    
    //*** Конструктор.

    // Ф-я создается при помощи ключевых слов new Function. Такая запись полезна когда нужно сконструировать ф-ю во время выполнения
    // программы, например из данных с сервера или от пользователя. Недостатки такой записи - трудно читаемость и возможная дырка
    // в программе если придут невалидные данные от пользователя.

    let f = new Function("x", "y", "return x + y");
    console.log(f(1, 2));
    
}



{//  214    ====    МЕТОДЫ и СВОЙСТВА СТРОК и ЧИСЕЛ (ЧАСТОИСПОЛЬЗУЕМЫЕ)    ====

    // Методы - вспомогательные ф-и, свойсва - вспомогательные значения. Рассмотрим ОСНОВНЫЕ(часто используемые). Все методы и
                // и свойства можно посмотреть в официальной документации 
                // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String - тут дана ссылка на
                // строковые методы и свойства, они видны справа от основного контента. Также их можно найти в консоли
                // прописав console.dir(Number) - например для чисел, выведется объект число со всеми его возможным
                //методами и значениями.
                


    //  +++  СТРОКА  +++

    // *** length - свойство для получения количества элементов различных типов данных. Свойства мы никак не вызываем, прописываем
                // просто через точку, Методы(функции) вызываются при помощи круглых скобок.
    const str = 'test';
    const arr = [1, 2, 3];

    console.log(str.length); // 4 - количество элементов строки
    console.log(arr.length); // 3 - количество элементов массива


    console.log(str[2]);     // s - получили символ под индексом 2
    // Чтобы взаимодействовать со строкой сущестуют методы, тоесть вот так присвоить букву не получится str[2] = 'd'.
    

    // *** МЕТОДЫ СТРОКИ

    // Изменение регистра
    const str = 'teSt';
    str.toUpperCase(); // TEST - ВОЗВРАЩАЕТ НОВУЮ строку со всеми заглавными(большими) буквами           ***НЕ ИЗМЕНЯЕТ исходник
    str.toLowerCase(); // test - ВОЗВРАЩАЕТ НОВУЮ строку со всеми маленькими буквами                     ***НЕ ИЗМЕНЯЕТ исходник
                                    // используется для обработки данных из поля ввода, что бы с ними работать

    
    // Поиск подстроки (поиск буквы или выражения внутри строки)
    const fruit = "Some fruit";
    fruit.indexOf("fruit"); // 5 - возвращает индекс с которого начинается искомая буква или выражение
    fruit.indexOf("q"); // -1 - когда искомый фрагмент в строке отсутствует


    // Модификация строки 

    //slice - ВОЗВРАЩАЕТ НОВУЮ СТРОКУ согласно заданым параметрам. 1й - с какого индекса  включительно, 2й - по какой индекс
                // *НЕ включительно возвращать строку.                                                    ***НЕ ИЗМЕНЯЕТ исходник
    const logg = "Hello world!"; // индекс - 10, символов - 11
    logg.slice(6, 11);  // world
    logg.slice(6);      // world - если указать только 1 аргум. С какого индекса и до конца.
    logg.slice(-6, -1); // world - отсчет идет с конца строки

    // substring (НЕ поддерживает отрицательные числа, если -6 - будет интерпретировано как 0, также первое число можно задавать
                 // больше че второе).ВОЗВРАЩАЕТ НОВУЮ СТРОКУ.                                            ***НЕ ИЗМЕНЯЕТ исходник
    logg.substring(6, 11);  //world 

    // substr - 1й арг указываем с какого индекса, 2й сколько символов нужно вернуть.ВОЗВРАЩАЕТ НОВУЮ СТРОКУ.
                //                                                                                         ***НЕ ИЗМЕНЯЕТ исходник
    logg.substr(6, 5);  //world 



    //  +++  ЧИСЛО  +++

    //Для работы с числами есть встроенная в браузер библиотека Math
    const num = 12.2;
    Math.round(num);    // ВОЗВРАЩАЕТ НОВОЕ ЧИСЛО округленно к ближайшему целому                            ***НЕ ИЗМЕНЯЕТ исходник


    // parseInt - переводит число в другую систему исчисления (ВОЗВРАЩАЕТ НОВОЕ ЧИСЛО)                      ***НЕ ИЗМЕНЯЕТ исходник
    // для обрезания строки и перевода в целое число (xасто можно получить такие размеры элемента со страницы)
    const test = '12.2px';
    parseInt(test); // 12 - число


    //parseFloat - изначально служит для того что бы число или строку возвращает в десятичном варианте
                    //ВОЗВРАЩАЕТ НОВОЕ ЧИСЛО                                                                ***НЕ ИЗМЕНЯЕТ исходник
    parseFloat(test); // 12.2 - число c десятыми

}



{//  215    ====    ПРАКТИКА 3. Используем функции    ====

    /*ЗАДАНИЕ
    1) Первую часть повторить по уроку

    2) Создать ф-ю showMyDB, которая будет проверять свойство privat. Если оно false - выводит в консоль глвный объект.

    3) Создать ф-ю writeYuorGenres в которой пользователь будет 3 раза отвечать на вопрос 
        "Ваш любимый жанр под номером ${номер по порядку}?". Каждый ответ записывается в массив данных genres.

    PS: ф-ии вызывать не обязательно
    
    */



    //  +++ РЕШЕНИЕ
    
    {"use strict";
        // В ф-ю start поместим инициализирующий вопрос с которого начинается работа программы const numberOfFilms = +prompt('С...
        // также добавим проверку что бы пользователь не мог отменить вопрос, ввести пустую строку или нечисло.
        // Что бы он вводил число мы ограничивались плюсом перед +prompt, но теперь этого мало. Проверка будет на этапе выполнения,
        // когда он нажал клавишу ОК. *Для проверки на этапе ввода в инпут нужно использовать РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ которые изучим
        // позднее. 

        // При переносе numberOfFilms в ф-ю она станет локальной и мы не сможем записать ее в personalMovieDB напрямую(можно через
        // return сделать ее вывод), поэтому мы объявим переменную numberOfFilms глобально, а само присваивание и вопрос пренесем в
        // ф-ю и сменим объявление numberOfFilms с const на let чтобы можно было ее изменять.

        //Проверку на правильность ввода мы делали через цикл for и использовали проверку правдивости, но мы можем использовать и while, 
        // пойдем от обратного чтобы увидеть и другие логические конструкции. Тут мы будем проверять неправдивые(неправильные варианты)
        // если это так то вопрос повторится, а если все хорошо то цикл будет закончен. Проверям numberOfFilms - пустая строка или
        // (нажимает кнопку ОТМЕНА)null или isNaN(numberOfFilms) - метод проверяет аргумент и если внутри не число то он возвращает
        //  правду. Тоесть цикл будет выполняться(задавать вопрос пользователю пока он будет вводить невалидные данные в поле ввода) 
        // до тех пор пока уловия не будут ложными - тоесть введенные значения будут валидными для условия проверки но невалидные 
        // для нас.  А когда значения  будут невалидные для условия, но правильными для нас(числовой тип) тогда цикл остановится.

        let numberOfFilms;

        function start () {
            numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

            while (numberOfFilms == '' || numberOfFilms == null || isNaN(numberOfFilms)){
                numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');
            }
        }

        const personalMovieDB = {
            count: numberOfFilms,
            movies: {},
            actors: {},
            genres: [],
            privat: false
        };

        //Сделаем обвертку ф-цией этого блока для того что бы вызывать его только по требованию. Далее сделаем для нее вызов.
        function rememberMyFilms(){
            for (let i = 0; i < 2; i++) {
                const movieName = prompt(`Один из последних просмотренных фильмов? ${i}`, ''),
                    movieRank = prompt('На сколько его оцените?', '');
                
                if(movieName != null && movieRank != null && movieName != '' && movieRank != '' && movieName.length < 50) {
                    personalMovieDB.movies[movieName] = movieRank;
                    console.log('Done');
                }else{
                    console.log('Enter valid data');
                    i--;
                }
            }
        }

        // rememberMyFilms();

        // Эту часть кода тоже оборачиваем в ф-ю. *Таким образом у нас появились ф-и к которым можно обратиться и вызвать
        // их в нужное время или по событию.
        function detectPersonalLevel(){
            if (personalMovieDB.count < 10){
                console.log("Просмотрено довольно мало фильмов");
            }else if(personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
                console.log("Вы классический зритель");
            }else if(personalMovieDB.count >= 30) {
                console.log("Вы киноман");
            }else {
                console.log("Произошла ошибка");
            }
        }

        // detectPersonalLevel();

        // Мое решение
        // function showMyDB(){
        //     if (personalMovieDB.privat){
        //         console.log('This is a privat object.');
        //     } else {
        //         console.log(personalMovieDB);
        //     }
        // }
        // showMyDB();

        // Сделаем передачу данных из personalMovieDB.privat в параметр hidden. Тогда условие звучит так, если база
        // НЕ скрыта(!hidden - нот тру) показываем. false передается в хидден и через ! становится тру и показывается
        // база данных, а если в privat будет тру то оно превратится в фолс и покажется.
        function showMyDB(hidden){
            if (!hidden){
                console.log(personalMovieDB);
                } else {
                console.log('This is a privat object.');
            }
        }
        showMyDB(personalMovieDB.privat);


        //Мое решение
        // function writeYourGenres(){
        //     for(let i = 1; i < 4; i++){
        //         personalMovieDB.genres[i-1] = prompt(`Ваш любимый жанр под номером ${i}?`);
        //     }
        // }
        // writeYourGenres();

        function writeYourGenres(){
            for(let i = 1; i <= 3; i++){
                // Первоначальный код через переменную
                // const genre = prompt(`Ваш любимый жанр под номером ${i}?`);
                // personalMovieDB.genres[i - 1] = genre; 

                //personalMovieDB.genres.push(genre);  - так тоже работало с переменной

                //Уменьшим код такой записью - код работает быстрее потому что не нужно создавать переменную
                personalMovieDB.genres[i-1] = prompt(`Ваш любимый жанр под номером ${i}?`);
            }
        }
        writeYourGenres();

        console.log(personalMovieDB.genres);
        console.log(personalMovieDB);
    }

}



{//  216    ====    CALLBACK ФУНКЦИИ    ====

    // Ф-я выполняет какой то ко и потом нужно подождать какое то время например для того что бы сервер прислал данные
    // это ожидание можно сэмулировать такой конструкцией setTimeout в нее вкладываем ф-ю которая будет выполнена
    // через 0.5(500 мл секунд) секунды.
    function first() {
        //do something
        setTimeout(function() {
            console.log(1);
        }, 500);
    }
    
    // Эта ф-я выведет двойку в консоль без задержки
    function second() {
        console.log(2);
    }

    // Вызываем ф-ии по порядку, они обе будут выводить в консоль значения
    first();
    second();

    // В консоли получили рез-т сначала 2 потом 1, тоесть вторая ф-я сработала раньше чем первая. Но в реальной
    // работе мы можем не знать какая будет задержка(например через сколько ответит сервер), но когда мы вызываем
    // ф-и в коде в определенном порядке то предполагаем что они должны и выполнится в этом порядке, а с неизвестной
    // задержкой такого может не получиться и если вторая ф-я работает с рез-и первой то может произойти ошибка.
    // Что бы исключить такие ошибки придумана сallback ф-я
    // Вывод - если ф-ии в коде идут одна за другой это значит что запускаются они одна за другой но рез-т могут
    // отдать в разное время.


    // сallback - по простому это ф-я которая начинает выполнятся после того как другая ф-я завершилас свою работу.
    // В этом примере ф-я callback выполнится после того как отработает console.log
    function learnJS(lang, callback) {
        console.log(`Я учу ${lang}`);
        callback();
    }

    // Вызываем ф-ю learnJS. 1й аргумент строка которую нужно вывести первой, 2й - ф-я которая отработает позже
    // всю анонимную ф-ю написали сразу в аргументе learnJS("Java Script", function(){сonsole.log('Я прошел этот урок.')} );
    // Таким образом всегда будет соблюдатся последовательное выполнение ф-й
    learnJS("Java Script", function() {
        console.log('Я прошел этот урок.')
    });

    // Так как ф-я анонимная больше мы к ней не сможем обратиться и получить ее значения, но можно передавать и ф-ю
    // с именем, при этом ф-я без скобок потому что мы ее не вызываем тут, а вызываем в learnJS этой строкой callback();
    // после выполнения предыдущего кода
    function learnJS(lang, callback) {
        console.log(`Я учу ${lang}`);
        callback();
    }

    function done() {
        console.log('Я прошел этот урок.');
    }

    learnJS("Java Script", done);

    // В практике колбеки используются постоянно при запросах к серверу или при срабатывании какого-то события
    // на странице, после клика пользователя 1й аргумент, передаем имя ф-и которая будет после этого выполнятся.
    // Или если осваивать серверное программирование на NOD.js там все построено на колбэках.

}



{//  217    ====    ОБЪЕКТЫ и ИХ ДЕСТРУКТУРИЗАЦИЯ    ====

    //Углубимся в работу с методами объекта
    // Создадим объект вторым способом, не через фигурные скобки. Обычно им не пользуются, потому что такая запись длинее.
    "use strict";
    const obj = new Object();


    //Создадим объект для практики
    const options = {
        name: 'test',
        width: 1024,
        height: 1024,
        colors: {
            border: 'black',
            bg: 'red'
        }
    };
    console.log(options.name);
    console.log(options['colors']['border']); // black

    // Для удаления из объекта используем метод delete
    delete options.name;


    // Для перебора  объекта используем метод for in. В скобках указываем переменную, обычно ее называют key(ключ)
    // потому что мы не знаем имен параметров в объекте, а имя такое потому что используются пары - ключ + его значение.
    // и также указываем в каком объекте будем делать перебор in options.
    // В середине как в обычном цикле задаем действия которые будут повторятся при каждой итерации цикла, а итераций
    // будет столько сколько свойств(ключей) у объекта. *for of для объекта не работает.
    // for (let key in options) {
    //     console.log(`Свойство ${key} имеет значение ${options[key]}`);// *Обращение через точку не работает
    // }

    // в консоль выводятся свойства объекта, а для colors вывелось свойство [object Object] дело в том что все
    // значения выводятся в качестве строк, а значение colors это объект (вложенная конструкция) и когда JS
    // натыкается на нее он не может объект превратить в  строке поэтому и выводит строковое представление объекта.
    // С этим просто нужно уметь работать, в переборах можно использовать рекурсию, но ее мы изучим позднее.
    // Но сейчас сделаем проверку внутри цикла перебора на значение объекта, и если его получим то можно
    // запустить еще один перебор внутри основного перебора, с другим именем переменной.
    for (let key in options) {
        if (typeof(options[key]) === 'object') {
            for (let i in options[key]) {
                console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
            }
        } else {
            console.log(`Свойство ${key} имеет значение ${options[key]}`);
        }
    }
    // Теперь в консоль выводится правильные пары свойство(ключ) + значение. Чуть позже рассмотрим рекурсию
    // и по факту будет работать точно также но не с циклом, а с функцией.
    
    // Рассмотрим стандартные(встроенные методы) объектов, их как всегда можно рассмотреть в документации.
    // В ней можно увидеть что в объекте нету свойства length, мы не можем узнать сколько элементов(пар)
    // находится в объекте.
    // Самый простой способ это создать такой перебор, а в нем переменную которая будет подсчитывать сколько
    // свойств оказалось внутри, этот прием на первых порах используется очень часто.
    let counter = 0;
    for (let key in options) {
        if (typeof(options[key]) === 'object') {
            for (let i in options[key]) {
                console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
                counter++;
            }
        } else {
            console.log(`Свойство ${key} имеет значение ${options[key]}`);
            counter++;
        }
    }
    console.log(counter); // 5 - полное количество объектов вместе со вложенными. Если хотим получить только те
                            // которые на верхнем уровне тогда нужно удалить counter++; из блока if отвечающего за 
                            // true, и получим значение 3 потому что условие пошло по другой вилке if
                            // for (let i in options[key]) {
                            //     console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
                            // } else {

    // Поэтому классический метод перебора используемый для того что бы узнать количество свойств объекта такой
    let counter = 0;
    for (let key in options) {
        counter++;
    }
    console.log(counter); // 4 - как раз то что нужно


    // Но каждый раз объявлять переменную и запускать перебор для того что б узнать количество свойств в объекте
    // слишком много кода, можно использовать стандартные(встроенные) метод объекта Object.keys - он добавляет
    // все ключи первого(верхнего) уровня вложенности в массив и возвращает его, а в массиве мы уже можем узнать
    // его длинну через length
    console.log(Object.keys(options)); // ['name', 'width', 'height', 'colors']
    console.log(Object.keys(options).length); // 4


    // Такие методы мы можем создавать вручную. Модифицируем объект.
    const options = {
        name: 'test',
        width: 1024,
        height: 1024,
        colors: {
            border: 'black',
            bg: 'red'
        },
        makeTest: function () {
            console.log("It's test");
        }
    };
    // вызывается созданный метод как ф-я или метод через круглые скобки
    options.makeTest(); // Доступ к методу через [] - не работает.


    // Также в объектах есть - свойства акцессоры(access) get и set, рассмотрим позже.



    // +++ ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТА

    // Ее можно провести и с массивами, разберем далее в курсе.
    // Часто нужно достучаться до вложенных свойств и не очень удобно каждый раз использовать такую конструкцию
    // options['colors']['border'], для избежания такого и существует деструктуризация - по простому мы будем вытаскивать
    //  вложенные свойства в переменную в качестве отдельных структур(коробочек) за наш объект и там уже их использовать
    
    const {border, bg} = options.colors; // вытаскиваем свойства вложенного объекта по названиям и формируем переменные
                                          // с таким же названием
    console.log(border); // black - далее просто используем как переменную

    // У обычной строки через просмотр ее свойств через консоль дир можно увидеть что методы приходят от прототипа объекта,
    // это значит что в каком то объекта прописан такой метод, почти все сущности JS сводятся к объектам.
}



{//  218    ====    МАССИВЫ  и ПСЕВДОМАССИВЫ    ====

    // Массив - это структура которая содержит элементы по порядку(в определенном порядке)



    // +++ МЕТОДЫ МАССИВОВ

    // Создадим массив для практики
        const arr = [1, 2, 3, 8, 6];

        arr.pop();      // Удаляет последний элемент массива [1, 2, 3, 8]

        arr.push(10);   // Добавляет заданный элемент в конец массива [1, 2, 3, 8, 10]

    //Методы работы с НАЧАЛОМ массива используются очень редко потому что при добавлении/удалении первого элемента индексы
        // всех остальных эл. меняются, это вносит неразбериху и если массив содержит например 2 тысячи элементов, заставляет
        // программу задействовать много ресурсов компьютера для смены индексов и увеличивает время выполнения программы.
        arr.shift();    // Удаляет ПЕРВЫЙ элемент массива [2, 3, 8, 10]
        arr.unshift(20);// Добавляет эл. в НАЧАЛО массива [20, 2, 3, 8, 10]


    // *** Методы перебора массива.
    
    // Для этого можно использовать цикл for. В условии пропишем что бы он работал до тех пор пока и будет меньше длинны
        // массива "i < arr.length". Длинна массива 5 - элементов, на 1 больше чем индексов в нем. Так как наша i = 0, то
        // получится что мы выполним столько же итерраций цикла сколько и элементов потому что индекс 4 все еще меньше
        // длинны 5 и последний элемент будет перебран(прочитан). "инд. 4 < 5 эл."
        const arr = [1, 2, 3, 8, 6];
        for (let i = 0; i < arr.length; i++) {
            console.log(arr[i]);    // Все элементы выведутся по очереди в консоль, по одному за каждую итеррацию 1 2 3 8 6
        }


    // Также можно использовать конструкцию перебора for of. Объявляем переменную в которую будет присваиваться значения
        // массива по очереди, в данном случае value(можно любое) и указываем в каком массиве делать перебор of arr
        for (let value of arr) {
            console.log(value);     // Все элементы выведутся по очереди в консоль 1 2 3 8 6
        }
        // Этим методом мы НЕ можем перебрать объект, но можем перебрать массив и массивоподобные сущности. Строку, псевдомассив
            // и такие сущности как map и set(про них поговорим в следующих уроках), определенные элементы со страницы.


    // Обычно длинна масива равна количеству элементов. Но бывают случаи когда это правило нарушается.
        const arr = [1, 2, 3, 8, 6];
        arr[99] = 0;                // Поместим на 99 индекс число 0
        console.log(arr.length);    // 100 - получили длинну массива 100(вроде как 100 элементов, хотя мы знаем что их 6)
        console.log(arr);           // (100) [1, 2, 3, 8, 6, empty × 94, 0] - видим что 94 пустых ячейки
        // поэтому длинна массива равна индексу последнего элемента +1.


    // Наиболее часто используется структура forEach()
        // по факту он работает как и предыдущие методы перебора, но его можно подробнее настроить.
        // forEach в себя принимает callback ф-ю которая будет выполнена каждый раз для каждого элемента массива
        // она принимает 3 аргумента, 1й - элемент массива(именовать можно как угодно), 2й - индекс элем.(номер по порядку)
        // тоесть при переборе мы кроме значения можем также сохранить(обратиться) индекс элем., 3й - имя массива
        
        const arr = [1, 2, 3, 8, 6];
        arr.forEach(function(item, i, arr ) {
            console.log(`${i}: ${item} внутри массива ${arr}`);
        });
            // 0: 1 внутри массива 1,2,3,8,6
            // 1: 2 внутри массива 1,2,3,8,6
            // 2: 3 внутри массива 1,2,3,8,6
            // 3: 8 внутри массива 1,2,3,8,6
            // 4: 6 внутри массива 1,2,3,8,6
    // Этот метод позволяет удобно манипулировать массивом, например элементами со страницы. Их можно перебрать и например
        // каждой кнопке ${i} назначить дополнительный класс(значение) ${item}. Или взять каждый текстовы элемент по
        // определенному селектору и модифицировать его.

    // *Когда использовать forEach а когда for of. обычно всегда используют forEach, но в for of мы можем использовать ключевые
        // слова break и continue, они очень важны если нам нужно будет или остановить цикл или пропустить итерацию, а в forEach
        // мы такого сделать не сможем.

    // * Метод forEach НЕ изменяет массив. А методы(map, every/some, filter, reduce) это меотды трансформации, тоесть они берут
        // исходный материал и его модифицируют. map и filter ВОЗВРАЩАЮТ НОВЫЙ массив с измененными данными. Их расспотрим в 
        // послеующих уроках.
    

    // * split
        // Когда от пользователя или от сервера приходит большая строка с множеством например товаров разделенных каким то знаком
        // например запятой. Для более удобной работы с такой информацией ее лучше превратить в массив. split - принимает
        // аргументом знак разделения по которому нужно отделить элементы строки один от другого и записать в массив по порядку,
        // при этом нам нужно точно знать какой разделить будет в строке в данном случае запятая + пробел (", ")
        const str = prompt("Введите товары через запятую", "");
        const products = str.split(", ");
        console.log(products);  
        // такой код поделит строку только если слова будут разделены запятой+ пробел, если просто запятая, то будет 1 элемент
            // массива. А если вписать просто запятую, то если пользователь будет вводить через запятую + пробел, в таких элем.
            // будет перед буквами пробел.


    // * join
        // Это обратный метод, который из массива делает строку, например если нужно пользователю вывести строкой список
        // приглашенных. Аргументом принимает разделитель которым разделятся слова в строке.
        const str = prompt("Введите товары через запятую", "");
        const products = str.split(", ");   // создаем массив из строки разделяя на эл. по запятой + пробел
        console.log(products.join('; '));    // из массива создаем строку с разделителями между словами  ('; ')


    // * sort
        // Метод сортировки массива(всегда сортирует элемент массива как СТРОКУ ) по алфавиту
        //* При сортировке массива, отдается предпочтение словам начинающимся с большой буквы, тоесть Боб будет первее чем аня, 
        // поэтому при сортировке стоит приводить все слова к одному регистру.
        const str = prompt("Введите товары через запятую", ""); // qqq, aaa, bbb
        const products = str.split(", "); 
        products.sort();                                        // отсортировалось по алфавиту
        console.log(products.join('; '));                       //  aaa; bbb; qqq

        // Но если нужно отсортировать числа то получим такое поведение
        const arr = [2,13, 26, 8, 10];
        arr.sort();     // [10, 13, 2, 26, 8] - не по возрастанию как числа,
        // сортирует как строки посимвольно, тоесть сначала все числа у которых 1, потом сравнивает вторые символы.
        
        // * Чтобы числа в массиве сортировались как числа нужно дописать ф-ю, назовем ее compareNum, в которой будет 2 
            // аргумента а и б(можно именовать как угодно) в них будут приходить соседние элементы массива, и с ними будет
            // выполнятся отнимание, при этом они будут приводится к числовому значению, и если результат будет минусовое число
            // или равен 0, то элементы остаются на своих местах, а если плюсовое число, тоесть первое больше, тогда меняются
            // местами. И передать ф-ю как аргумент в метод sort
        function compareNum(a, b) {
            return a - b;
        }

        const arr = [2,13, 26, 8, 10];
        arr.sort(compareNum);   // [2, 8, 10, 13, 26]
        // Теперь сортировака числовых значений в массиве произошла правильно.



    // +++ ПСЕВДОМАССИВы

    // Они получаются когда мы работаем с элментами на странице. По факту это такой объект структура которого совпадает со
        // структурой массива. Выглядят он также как обычные массивы, но у них нету методов(forEach, filter, push, pop, 
        // join, и т.д.), только свойство length, это просто структура которая хранит данные по порядку.

}



{//  219    ====    ПЕРЕДАЧА ДАННЫХ по ССЫЛКЕ или по ЗНАЧЕНИЮ, Spread оператор (ES6-ES9)

    // Многие новички делают ошибки не различая передачу данных по ссылке и по значению. 
    


    // +++ ПЕРЕДАЧА ДАННЫХ

    //Рассмотрим пример, создаем переменную а
        // и в нее помещаем 5, создадим переменную b и в нее поместим значение а. Далее к значению b приплюсуем 5 и ожидаем что
        // в b у нас окажется 10.
        let a = 5,  
            b = a;          // присваивается значение 5

        b = b + 5;

        console.log(b);     // 10 - как мы и ожидали.
        console.log(a);     // 5 - а при этом не изменяется


    // Теперь создадим переменную obj с объектом и поместим ее в переменную copy. Потом в переменной copy изменим значение
        // свойства а на 10 и проверим что случилось с нашими объектами.
        const obj = {
            a: 5,
            b: 1
        };

        const copy = obj;   // присваивается ссылка на объект в переменной obj
        copy.a = 10;

        console.log(copy);  // { a: 10, b: 1 }
        console.log(obj);   // { a: 10, b: 1 }
        // Значение свойства а изменилось и в переменной obj, так получилось потому что const copy = obj; сработало не так
        // как мы расчитывали. Так получается потому что объект был передан по ссылке.

    // При работе с примитивами (строки, числа, лог. значения) - они передаются по значению(значение копируется). Когда же
        // мы работаем с объектами к которым относятся:массивы, функции и сец.объекты(Объекты даты), передача идет не по значению
        // а по ссылке, тоесть объект не копируется в новую переменную, а туда заносится ссылка на первоначальные объект, и
        // если мы обратимся к такой переменной она будет через ссылку работать с первоначальным объектом.

    

    // +++ Чтобы СКОПИРОВАТЬ(клонировать) объект существуют разные способы.
        // *Существуют поверхностные и глубокиt копии, далее в курсе будем рассматривать глубокое копирование,
        //  а пока рассмотрим поверхностное копирование.

    // *** ЦИКЛ. Создадим ф-ю которая аргументом будет принимать копируемый объект mainObj. Внутри создадим
        // переменную для нового объекта objCopy и через перебор for in переберем свойства текущего объекта. При этом видим что
        // переменную key можно создать вне цикла for in. В цикле создаем новое свойство у нового объекта objCopy[key] - с таким 
        // же именем как у копируемого обекта key и в его значение присваиваем значение этого же свойства из копирумого объекта
        // objCopy[key] = mainObj[key]; После завершения копирования нужно вернуть новый скопированный объект наружу через
        // return objCopy; (на сколько я понял метод копирования - объект разбивается на примитивы и копируется их значение.
        function copy(mainObj) {
            let objCopy = {};

            let key;
            for (key in mainObj) {
                objCopy[key] = mainObj[key];
            }
            return objCopy;
        }

        // Создадим объект вместе со вложенным объектом что бы проверить как отработает наша ф-я
        const numbers = {
            a: 2,
            b: 5,
            c: {
                x: 7,
                y: 4
            },
            func: function(){
                console.log('hey');
            }
        };

        //Пробуем скопировать в переменную newNumbers
        const newNumbers = copy(numbers);
        console.log(newNumbers);        // {a: 2, b: 5, c: {x: 7, y: 4}, func: ƒ} - * метод работает
        
        // При изменении свойства newNumbers видим что первоначальный объект остался не тронутыми.
        newNumbers.a = 10;
        console.log(newNumbers);    // {a: 10, b: 5, c: {x: 7, y: 4}, func: ƒ}
        console.log(numbers);       // {a: 2, b: 5, c: {x: 7, y: 4}, func: ƒ}
        
        // Таким образом мы клонировали(скопировали) объект numbers в новый newNumbers. Но если мы изменим свойство х
        newNumbers.с.x = 10;
        console.log(newNumbers);    // {a: 10, b: 5, c: {x: 10, y: 4}, func: ƒ}
        console.log(numbers);       // {a: 2, b: 5, c: {x: 10, y: 4}, func: ƒ}
        // мы видим что это свойство изменилось у обоих объектов.

        // *** При таком способе клонирования мы сделали ПОВЕРХНОСТНУЮ копию объекта, тоесть все элементы на первом уровне
        // скопируются хорошо, но если есть вложенный объект или массив(ф-я???) его значение тоже передается по ссылке


    // *** Object.assign 
        //У глобального типа Object, есть метод assign. Этот метод позволяет соединять несколько объектов.

        // соединим объект numbers c объектом add. Первым аргументом передаем тот объект в который мы хотим поместить второй,
        // второй аргумент - тот объект который мы помещаем.
        const add = {
            d: 17,
            e: 20
        };

        const numbers = {
            a: 2,
            b: 5,
            c: {
                x: 7,
                y: 4
            }
        };
        
        console.log(Object.assign(numbers, add)); // {a: 2, b: 5, c: {x: 7, y: 4}, d: 17, e: 20}

        // Таким образом у нас сформировалась независимый объект ни от numbers(не считая вложенного объекта) ни от add, и если
        // мы присвоим его какой то переменной то сможем с ним работать незавимо. 
        //Тоже самое можно сделать с пустым объектом что бы просто создать ПОВЕРХНОСТНУЮ копию объекта.
        const clone = Object.assign({}, add);

    
    // *** КОПИЯ МАССИВА.
        // * slice
        // Копию массива можно сделать также через цикл, но есть еще специальный метод slice. 
        // Массив скопируется поверхностно, тоесть
        // const oldArr = ['a', ['b', 'j'], 'c']; - если копировать такой массив и его элемент полностью заменить на новое
        // значение newArr[1] = 'yoyoyo'; то получим изменения только в новом массиве ["a", "yoyoyo", "c"], а в старом значения
        // останутся прежними, но если попробовать изменить значение одного элемента вложенного массива newArr[1][1] = 'yoyoyo';
        // тогда изменения будут и в старом массиве ["a", ["b", "yoyoyo"], "c"].
        const oldArr = ['a', 'b', 'c'];
        //const newArr = oldArr;        // передастся ссылка
        const newArr = oldArr.slice();  // скопирует массив (поверхностно!)

        newArr[1] = 'yoyoyo';
        console.log(newArr);    // ["a", "yoyoyo", "c"]
        console.log(oldArr);    // ["a", "b", "c"]

    

    // +++ НОВЫЕ МЕТОДЫ ES6 и ES9
        
    // *** SPREAD - Оператор разворота. 
        //В ES6 он появился для массивов, а в ES9 уже и для объектов. Он разворачивает структуру и превращает ее в набор данных.

        // Поверхностное клонирование массива
        const arr = ['a', 'b'];
        const newArr = [...arr];

        // Создаем три переменных. В двух лежат массивы с данными, а в третий нам нужно поместить данные из первых двух. Можно
        // сделать это через цикл, или посмотреть методы для массивов может там есть метод для этой задачи, но самый простым
        // способом соединить два массива в новом будет использовать спрэд оператор(...) что бы он развернул заданные массивы на
        // элементы в новом массиве, при этом можно еще добавть свои данные.
        const video = ['youtube', 'vimeo', 'rutube'],
              blogs = ['wordpress', 'Livejournal', 'blogger'],
              internet = [...video, ...blogs, 'vk', 'facebook'];

        console.log(internet);  // ["youtube", "vimeo", "rutube", "wordpress", "Livejournal", "blogger", "vk", "facebook"]


        // Рассмотрим пример посложнее. Ф-я принимает 3 аргумента и выводит их в консоль. Массив num содержит числа, но вместо
        // них нам могли с сервера прийти данные о видео 1 - сылка на видео, 2 - ссылка на заглушку, 3 - ссылка например на 
        // автора и эти данные нам нужно передать в ф-ю log. Но ф-я принимает отдельные аргументы. а не массив. Тут нам помогает
        // спред оператор, он развернеn массив в скобках при запуске ф-и.
        function log (a, b, c) {
            console.log(a);
            console.log(b);
            console.log(c);
        }
        
        const num = [2, 5, 7];

        log(...num); // 2 5 7


    // * Клонироване объекта методом spread оператора
        const obj = {
            one: 1,
            two: 2
        }

        const newObj = {...obj};
        console.log(newObj);

}



{//  220    ====    ОСНОВЫ ООП, прототипно-ориентированное наследование    ====
    
    // Прототипно-ориентированное программирование это стиль объектно ориентированного программирования(ООП). Смысл ООП
        // заключается в том что мы представляем любую вещь как объект с набором свойств и методов.


    // * Если мы работаем со строкой то можно увидеть что у нее есть свойство - длинна строки(length) и методы для изменения
        // ее регистра, модификации, и т.д. и можно подумать что это уже целый объект. Но если строка написана в таком
        // виде "Some string" - это обычный примитив(простой тип данных). Но когда мы вызываем у нее свойство или какой то
        // метод JS оборачивает ее в объект и после модификации возвращает строку на место.

    // ПРИМЕР
        // Создадим строку разными способами и посмотрим их тип
        let str = "some";               // обычный способ
        let strObj = new String(str);   // способ через new (конструктор???) помещаем нашу первоначальную строку в конструкцию

        console.log(typeof(str));       // string
        console.log(typeof(strObj));    // object
        // * Примерно так происходит создание строки из нашей первоначальной строки когда мы вызываем свойство или метод на
        //  обычной строке. Примитив оборачивается в объект используется какой то метод который есть у этого объекта и 
        // далее из объекта снова превращается в примитив


    // Откуда же JS знает как это делать. Представим легковое авто, они все разные: разных марок, количества мест, цветов но они
        // все построены по одному прототипу. От этого прототипа и отпочковался каждый новый экземпляр. У них погут быть разные
        // двигаетли, диаметр колес, форма кузова, но все эти свойства есть у каждого легкового автомобиля, это и есть применение
        // ООП и прототипно ориентированного программирования в реальной жизни.
        
    // Когда мы создаем строки или массивы они будут совершенно разными по наполнению, но каждый из них обладает одними и
        // теми же методами которые сможем использовать на любом экземпляре. Когда мы создаем массив мы создаем новый экземпляр
        // прототипа массивов
    console.dir([1, 2, 3]); // получаем экземпляр массива в котором если его раскрыть можно увидеть свойство _proto_
                            // Array(3)0: 1 1: 2 2: 3 length: 3 __proto__: Array(0) - а в нем и лежит прототим массива Array
                            // благодаря которому мы и можем создавать свои массивы. Если раскрыть и его можно увидеть все
                            // методы которые применимы к массивам и в конце мы снова обнаружиаем свойство _proto_ которое
                            // ссылается на объект __proto__: Object. 
        
        // * Тоесть все методы и свойства которые мы можем использовать на массиве приходят через _proto_ их прототипа массива
        //  Array.prototype а к нему через _proto_ из Object.prototype. Такаяже ситуация и с функциями и с числами.
        

        
    // +++ В реальных проектах мы сами будем создавать такие прототипы что бы от них создавать другие объекты. Например модального
        // окна у которого по умолчанию будут свойства - ширина, высота, базовые ф-ции и от него мы сможем создавать много других
        // модальных окон которые будут отличаться по какой то характеристике(свойству)
        const soldier = {   // Создаем прототип солдата
            health: 400,
            armor: 100
        };

        const john = {      // Создадим конкретного солдата джона у которого мало здоровья
            health: 200
        }

        // Теперь установим связь. чтобы Джон умел делать все тоже что и солдат и свойства которых у него не достает добавились,
        // но личные свойства что бы остались своими health: 100, сделать это можно несколькими способами.
        

    // *** Рассмотрим УСТАРЕВШИЙ формат. потому что он может встречаться в коде и нужно знать как с ним работать, но в новых
        // проектах уже не стоит его использовать.
        john.__proto__ = soldier;
        console.log(john);          // {health: 200} - видим единственное свойство 
        console.log(john.armor);    // 100 - но если обратимся к свойству  armor. то оно у него будет благодаря прототипу который
                                    // мы только что указали.
    

    // *** Сейчас вместо __proto__ нужно использовать 
        // Object.create()          - создает объект с опрееленным прототипом
        // Object.getPrototypeOf () - получает прототип
        // Object.setPrototypeOf () - устанавливает(назначить) прототип
        Object.setPrototypeOf (john, soldier); // современная запись john.__proto__ = soldier;

        // Теперь сделаем все тоже что и выше уже зная методы создания прототипов
        const soldier = {  
            health: 400,
            armor: 100
        };

        const john = Object.create(soldier);    // Создаем новый объект john который будет прототипно наследоваться от soldier
                                                // Что бы теперь установить свойство health нужно john.health = 200;
        console.log(john);

}



{//  221    ====    ПРАКТИКА 4. Используем объекты    ====

    // Сделаем РЕФАКТОРИНГ кода - переписывание кода под новые услови и новые задачи.



    /*ЗАДАНИЕ
    1)  Нужно переписать наше приложение состоящее из ф-й так, чтобы все ф-ии стали методами объекта personalMovieDB.
            Такое случается в реальных продуктах при смене технологий или подхода к аритектуре программы.

    2) Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false он будет
            переключит его в true, и наоборот. Протестировать вместе с showMyDB.

    3) В методе writeYourGenres запретить поользователю нажать кнопку "отмена" или оставлять пустую строку. Если он это сделал
            возвращать его к вопросу заново. После того как все жанры введены - при помощи метода forEach вывести в консоль
            сообщение в таком виде "Любимый жанр #(номер по порядку начиная с 1) - это (название из массива)"
    */



    //  +++ РЕШЕНИЕ

    {"use strict";
    // При переносе ф-и start в объект нужда в переменной numberOfFilms отпадает. Мы установим для свойства count значение равное 0.
    // а в ф-и вместо переменной numberOfFilms пропишем путь к count куда и будет ложиться результат personalMovieDB.count

    const personalMovieDB = {
        count: 0,
        movies: {},
        actors: {},
        genres: [],
        privat: false,
        start: function () {
            personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
        
            while (personalMovieDB.count == '' || personalMovieDB.count == null || isNaN(personalMovieDB.count)){
                personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
            }
        },
        rememberMyFilms: function() {
            for (let i = 0; i < 2; i++) {
                const movieName = prompt(`Один из последних просмотренных фильмов? ${i}`, ''),
                    movieRank = prompt('На сколько его оцените?', '');
                
                if(movieName != null && movieRank != null && movieName != '' && movieRank != '' && movieName.length < 50) {
                    personalMovieDB.movies[movieName] = movieRank;
                    console.log('Done');
                }else{
                    console.log('Enter valid data');
                    i--;
                }
            }
        },
        detectPersonalLevel: function (){
            if (personalMovieDB.count < 10){
                console.log("Просмотрено довольно мало фильмов");
            }else if(personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
                console.log("Вы классический зритель");
            }else if(personalMovieDB.count >= 30) {
                console.log("Вы киноман");
            }else {
                console.log("Произошла ошибка");
            }
        },
        showMyDB: function (hidden){
            if (!hidden){
                console.log(personalMovieDB);
                } else {
                console.log('This is a privat object.');
            }
        },
        //Так как цикл у нас уже есть, нам осталось добавить условие. Добавим переменную для хранения ответа genre.
        writeYourGenres: function (){
            for(let i = 1; i <= 3; i++){
                let genre = prompt(`Ваш любимый жанр под номером ${i}?`);
                            
                if (genre == '' || genre == null){
                    console.log("Вы ввели некорректные данные или не ввыели их вовсе.")
                    i--;
                } else {
                    personalMovieDB.genres[i-1] = genre;
                };

                // Моя корявая реализация.
                // if (i == 3) {
                //     personalMovieDB.genres.forEach(function(item, i){
                //         console.log(`Любимый жанр #${i+1} - это ${item}`)
                //     });

                personalMovieDB.genres.forEach((item, i) => {
                    console.log(`Любимый жанр №${i + 1} - это ${item}`);
                });
            }
        },
        toggleVisibleMyDB: function() {
            if (personalMovieDB.privat) {
                personalMovieDB.privat = false;
            } else {
                personalMovieDB.privat = true ;
            };
        }

    };


    // Реализуем метод writeYourGenres с использованием другого подхода. Изменим вопрос, теперь ожидаем строку с ответами. Значит вопрос
        // будет задан 1 раз, и нам не нужно 3 итерации - изменим i <= 3 на i < 2. И тперь передаем в genres - массив полученный из 
        //строки ответа пользователя через метод split с разделителем (", "). Потом отсортируем массив по алфавиту.
        //* При сортировке массива, отдается предпочтение словам начинающимся с большой буквы, тоесть Боб будет первее чем аня, поэтому
        //  при сортировке стоит приводить все слова к одному регистру, допишем к полученному ответу .toLowerCase();
        
    function writeYourGenres (){
        for(let i = 1; i < 2; i++){
            let genres = prompt(`Введите ваши любимые жанры через запятую.`).toLowerCase();
            
            if (genres == '' || genres == null){
                console.log("Вы ввели некорректные данные или не ввыели их вовсе.")
                i--;
            } else {
                personalMovieDB.genres = genres.split(", ");
                personalMovieDB.genres.sort();
            };
            
            personalMovieDB.genres.forEach((item, i) => {
                console.log(`Любимый жанр №${i + 1} - это ${item}`);
            });
        }
    };

    writeYourGenres();
    console.log(personalMovieDB);
    }

}



{//  222    ====    ОТЛАВЛИВАЕМ ОШИБКИ при помощи КОНСОЛИ разработчика. Breakpoints    ====

    // +++ ВКЛАДКИ КОНСОЛИ
        // *** Elements
        // ХТМЛ структура + стили которые применяются к каждому отдельному тегу. Тут можно посмотреть псевдоклассы, псевдоселекторы

        // Sources
        // Вкладка со всем исходными материалами которые нам доступны в проекте который сейчас открыт.

        // Network
        // Отвечает за работу с сетью. Тут мы можем как быстро происходит загрузка скриптов, картинок, хтмл структуры. Но самое
        // главное тут можно отслеживать запросы которые будут уходить на сайт.
    
        // Perfomance
        // тут можно увидеть как работает(загружается) какая то структура.

        // Memory
        // Сколько потребляет памяти наш сайт

        // Application
        // Можно увидеть подключенные апликухи. С Local storage мы еще будем работать.
    
    
    // Будем тренироваться на данном коде
        "use strict";

        function hello () {
            console.log("Hello World");
        }

        hello();

        function hi () {
            console.log("Say hi");
        }

        hi();

        const arr = [1, 14, 4, 30, 54],
            sorted = arr.sort(compareNum);

        function compareNum (a, b) {
            return a - b;
        }

        console.log(sorted);
        // в консоль будет выведено это 
        // Hello World
        // Say hi
        // (5) [1, 4, 14, 30, 54]

    // Консоль рассматривает в Гугл хром, в Эдж вкладки отличаются на русском языке.
    // Посмотрим как дебажить наш код, как получить промежуточные результаты которые возникают на том или ином шаге выполнения
        // нашей программы. Обратимся к Sources, тут мы можем устанавливать breakpoint(брейкпоинт - точка остановки), это такая
        // метка которая позволяет останавливать код в определенном участке.

        // В окне  слева выберем наш файл с кодом(скриптами JS) видим код, и кликаем на номер строки где хотим установить
        // брейкпоинт 7 hello(); и 13 hi();. 

        // Теперь перезапускаем страницу и получаем сообщение что наш сайт остановлен в дебаггере. Сообщения может и не быть,
        // но в панели справа от кода будет эта надпись. В console никаких значений еще не будет. 
        
        // Посмотрим на кнопки над правой панелью. 
            // 1 - переходит на следующий брейкпоинт
            // 2 - показывает вызывающиеся ф-ии или объявление переменных.
            // 3 - точки где происходит изменение данных (заходит внутрь ф-й). Если поставить брейкпоинт в compareNum на саму 
                // сортировку return a - b; можно увидеть значения ф-ии в каждой итеррации(какие элементы сравниваются и
                // что возвращает return), также тут видно что код выполняется справа - на лево. 
            // 4 - выход из ф-и. Аналогична предыдущей ф-ции, но если предыдущая return a - b; выполняла в 2 действия, сначала
                // сравнивала числа, потом выполняла return, то эта кнопка делает эту комманду за 1 действие, тоесть если много
                // раз сравниваются данные или происходит какое то действие, этой кнопкой проклацать ф-ю будет быстрее.
            // 5 - стрелочка "Шаг вперед", проходит выполнение кода пошагово в последовательности выполнения.
            // 6 - деактивировать брейкпоинты, тоесть они остаются, что бы мы их не ставили заново, но программу не останавливают

        // Вкладки под кнопками справа (зайдем в ф-ю hello третьей кнопкой, так что бы выбралась 4я строчка)
            // watch - позволяет следить за определенными выражениями
            // call stack - (стек вызовов) последовательность операций которая привела к данной строчке( по простому это как код
                //  пришел к данной строчке ), строчка 4 выделенная в окне  hello - 4 стр, (anonymus) - 7 стр. Тоесть код на 4й
                // строке был вызван с 7й.
            // scope - (область) переменные с которыми мы работаем в этой строке. Тут переменные разделены на local и global. Их 
                // тут мало перейдем на 19 строку return a - b; для примера. Теперь видим что в call stack  что 19 строка была
                // запущена из 16й sorted = arr.sort(compareNum). А в scope видим Local a:14 b:1 this:undefined, также через
                // шаг в этом меню видно что возвращает return. Global свернуто и добавилась вкладка Script в которой находится
                // наш массив над которым выполняются действия.
            // breakpoints - показывает в каких строках установленны брейкпоинты
            // XHR/fetch Breakpoints - брейпоинты для обращений к серверу
            // Dom Breakpoints - рбота с элементами на странице
            // Event listener/Global listenet - работа с обработчиками событий.

    // Поставить брейкпоинт можно и в самом коде написав ключ. слово debugger; - тогда код остановится на этой точке как будто
        // мы ее ставили из консоли разработчика.

}



{//  223    ====    ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ    ====

    // Повторим типы данных
        // ПРОСТЫЕ: числа, строки, логические(булиновые), null, undefined, Symbol, BigInt
        // ОБЪЕКТЫ: обычные объекты,
                 // специальные объекты: массивы, функции, объект Даты, регулярные выражения, ошибки.


    // ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ - возможность одного типа данных превращаться в другой. Тоесть число может стать строкой, строка
        // числом, а объект - булиновым значением. В других языках есть статическая типизация, когда число всегда остается 
        // числом.



    // +++ Рассмотрим примеры


        // *** TO STRING (как можно превратить в строку)

        // 1) String - самый старый и редкоиспользуемый способ(потому что не очень удобный) 
        console.log(String(null));          // "null" - взяло в кавычки само слово
        console.log(typeof(String(null)));  // string

        console.log(String(4));          // "4" - взяло в кавычки число
        console.log(typeof(String(4)));  // string

        // 2) Конкатенация - при сложении любого типа со строкой получаетсяя строка
        console.log(4 + '');            // "4" - сложили с пустой строкой
        console.log(typeof(4 + ''));    // string

        console.log(undefined + '');            // undefined
        console.log(typeof(undefined + ''));    // string

        // Создадим реальный пример, старым методом конкатенации(потому что уже есть 3) ИНТЕРПОЛЯЦИЯ) но такой код еще встречается
        // Например у нас есть путь и нам нужно динамически сформировать путь на 5ю категорию для перехода в нее
        const num = 5;
        console.log("https://vk.com/catalog/" + num); // тут динамически формируется строка адресса куда уже можно перейти

        // Также часто нужно изменять стили ксс при помощи JS и для этого нужно передавать их в виде строки. Нам приходит в 
        // переменную fontSize число 26(новый размер) и теперь нам нужно его передать в стиль, в строке потому что нужно указать
        // что єто будут пиксели или % или еще что то.
        const fontSize = 26 + 'px';


        // *** TO NUMBER (как можно превратить в число)

        // 1) Number - самый старый и редкоиспользуемый способ(потому что не очень удобный) 
        console.log(Number('4'));          // 4
        console.log(typeof(Number('4')));  // number

        // 2) "+" - унарный плюс - наиболее часто используемый
        console.log(+'4');          // 4
        console.log(typeof(+'4'));  // number

        // 3) parseInt (*2й аргумент - 10(десятичная система)) - неочевидное применение данного метода
        console.log(parseInt('15px', 10));          // 15 
        console.log(typeof(parseInt('15px', 10)));  // number

        // Пример нужно получить из поля ввода пользователя именно числовой тип данных
        let answer = +prompt("Сколько вам лет?", "");
        // Мы не можем таки образом запретить пользователю ввести буквы, но если он введет нужные значения они будут преобразованы
            // в число. * А что бы совсем убрать у него возможность ввести не число, нужно использовать регулярное выражение, с
            // ним познакомимся дальше в курсе.

        // * Все данные которые получаем от пользователя имеют тип СТРОКА (значение из prompt, input, textarea, и т.д.)


        // *** TO BOOLEAN (как можно превратить в булиновый тип)

        // Если перед нами пустота(null) или ничего - всегда будет ложь(false);
        // Эти типы и значения ВСЕГДА превращаются в false:
            // 0(ноль), ''(ПУСТАЯ строка, " "- это строка с пробелом, уже не пустая), null, undefined, NaN
        // Всё остальное будет превращаться true:
            // строки, пустые массивы, объекты, и т.д.


        // 1) Нативный
        //Преобразование в условии. Пример переменная switcher(переключатель) содержит начальное значение null, так часто 
        // указывают что бы потом присвоить другое значение по мере выполнения программы. 
        let switcher = null;        

        if(switcher) {      // преобразовуется в неправду(false) - условие не выполнится и код не сработает
            console.log(" Something working");
        }

        switcher = 1;       // происходит смена значения переменной в процессе выполнения программы

        // Какая то ф-я снова запускает проверку
        if(switcher) {      // теперь 1 будет преобразовано в true - условие  выполнится и код сработает
            console.log(" Something working");
        }

        // Такойже подход используют и для элементов на странице. Пока у нас какого то элемента не существует, вместо него будет
        // null, программа работает и периодически происходит проверка условия. И в какой то момент элемент появляется на странице
        // при этом в switcher помещается новый элемент который присутствует на странице, снова проверится условие, увидит что
        // элемент появился и начнет выполнять какие-то действия.

        // 2) Boolean - редкоиспользуемый способ
        console.log(Boolean('4'));          // true
        console.log(typeof(Boolean('4')));  // boolean

        // 3) !! - два знака отрицания
        console.log(!!"444");               // true
        console.log(typeof(!!"444"));       // boolean

}



{//  224    ====    ЗАДАЧИ С СОБЕСЕДОВАНИЙ на понимание основ    ====

    // Попробуем решить сами

    // 1)	Какое будет выведено значение: let x = 5; alert( x++ ); ?      

    // 2)	Чему равно такое выражение: [ ] + false - null + true ?         

    // 3)	Что выведет этот код: let y = 1; let x = y = 2; alert(x); ?     

    // 4)	Чему равна сумма [ ] + 1 + 2?                                   

    // 5)	Что выведет этот код: alert( "1"[0] )?                          

    // 6)	Чему равно 2 && 1 && null && 0 && undefined ?                   

    // 7)	Есть ли разница между выражениями? !!( a && b ) и (a && b)?     

    // 8)	Что выведет этот код: alert( null || 2 && 3 || 4 ); ?           

    // 9)	a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?            

    // 10)	Что выведет этот код: alert( +"Infinity" ); ?                   

    // 11)	Верно ли сравнение: "Ёжик" > "яблоко"?                          

    // 12)	Чему равно 0 || "" || 2 || undefined || true || falsе ?         


    
    // +++ Разберем ответы

    // *** 1) 
        let x = 5; alert( x++ );  // 5 - сначала вернет значение х , а потом постфиксно(после этой строчки квеличит на единицу)
                   alert( ++x );  // 6


    // *** 2) разобьем код на части [ ] + false - null + true. ВЫПОЛНЯЕТСЯ с ЛЕВА на ПРАВО
     
        console.log(typeof([ ] + false));   // "false" - строка
        // когда мы рабтаем с пусты массивом то в конкатенации он приводится к типу строка, а так как он пустой то получим пустую
        // строку, "" + false  и добавляя false его просто оборачивает строкой и добавляет пустую строку.

        console.log([ ] + false - null);    // NaN - когда проводим мат. операцию не с числом( кроме + со строкой) получаем 
                                            // НЕ ЧИСЛО NaN

        console.log([ ] + false - null + true); // NaN добавляя к НЕ ЧИСЛУ булиновое значение все равно получаем НЕ ЧИСЛО


    // *** 3) let y = 1; let x = y = 2; alert(x); 
        // Цепочка ПРИСВАИВАНИЯ выполняется справа на лево, сначала 2 присвается y а потом его значение, тоесть уже 2 присваеваем x.


    // *** 4) [ ] + 1 + 2 ВЫПОЛНЯЕТСЯ с ЛЕВА на ПРАВО
        // Пустой массив приравнивается к пустой строке и добавляется 1, получаем строку "1" к ней добавляем число 2 получая "12"

    
    // *** 5) alert( "1"[0] ) 
        // Когда разбирали строки говорили что к каждому эл. строки можно обратиться по индексу, и нулевой индекс строка - "1"


    // *** 6) 2 && 1 && null && 0 && undefined
        // Оператор И(&&) выведет true если все элементы истины(true), но если будет ложь то он выведет первый ложный элемент.
        // он проверяет с ЛЕВА на ПРАВО 2 && 1 - true, далее он проверяет 1 && null - false и он выведет этот ложный элемент. 
        // * И запинается на лжи возвращает его значение прекращая дальнейшее выполнение этого выражения. 
        // Если все элементы правдивы, возвращается последний элемент.


    // *** 7) !!( a && b ) и (a && b). Воспрос есть ли разница - значит проверяем и по типам(===)
        // Так как a и b - нам не известны, но они разные по значению, можно заменить эти буквы на числа а - первая буква 
        // алфавита -1 ,  b - вторая цифра, заменим на 2  и сравним !!( 1 && 2 ) === (1 && 2) - НЕ равны потому что двойной знак
        // восклицания превращает следующее за ним выражение в булиновое = true, а из вторых скобок вернется 2, при сравнении
        //  true превратится в 1, а 1 НЕ равно 2 - false


    // *** 8) alert( null || 2 && 3 || 4 );
        // Когда не уверенны какой из операторов сработает первым, нужно смотреть таблицу приоритетов операторов JS. Гуглим.
        // Видим что выполняется первее тот оператор у которого приоритет(число) больше, у И = 6, у ИЛИ = 5. Поэтому сначала
        // выполнится И, а потом будут выполнятся ИЛИ.
        // Значит из 2 && 3 - возврщается 3, потом так как остается такое выражение  (null || 3 || 4), код пойдет с ЛЕВА на ПРАВО
        // * Аналогично тому как И запинается на лжи, ИЛИ запинается на правде и возвращает первое его значение НЕ прекращая выполнять
        // код, сравнивает вернувшуюся правду со ледующим значением. 
        // Итого сравнивается null || 3 - возвращается 3(как единственная правда), далее сравнивается 3 || 4 - и возвращается ПЕРВАЯ 
        // правда (так как они оба правда).


    // *** 9) a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b?
        // объяснени лектора на примере из реального мира а - 1й ящик с 3мя яблоками, b - второй ящик с 3мя яблоками, 
        // да они идентичны, но оне НЕ одинаковы.
        // Я думаю что так как это частный случай объекта, а объекты у нас передаются по ссылке, то в каждой переменной лежит
        // своя ссылка на одинаковые массивы, и сравнивая ссылки - они будут не равны.


    // *** 10) alert( +"Infinity" ); 
        // Так как "Infinity" это строка, то с унарным плюсом ее переведет в число Infinity.


    // *** 11)  "Ёжик" > "яблоко"
        //  Сравнение идет по Юникоду. Маленькие буквы имеют большее значение перед большими и чем дальше в алфавите буква тем
        // больше ее значение. Cамая большая я, наименьшая А, потом идет от я(U+044F) - а(U+0430), потом Я(U+042F) - А(U+0410).
        // Сравнение идет посимвольно, если первые буквы одинаковые, переходит ко вторым буквам. Так как у нас первые
        // буквы неодинаковые и "я" имеет наибольший приоритет то "яблоко" будет больше "Ёжик". Итого выражение вернет false.


    // *** 12) 0 || "" || 2 || undefined || true || falsе
        // Тут лектор сказал что после ПЕРВОЙ правды код дальше не идет, в принципе это логично учитывая что из предыдущего(8го)
        // примера все равно вывелась только ПЕРВАЯ правда. Теперь мы не смотрим по парам а смотрим по одному числу. 
        // Итого 0 - ложь, "" - пустая строка - ложь, 2 - правда, код выведет 2 и дальше не пойдет.

}



{//  225    ====    GET ELEMENTS FROM PAGE    ====  

    // Будем получать элементы со страницы в JS скрипт и использовать его.

    // DOM - document object model(объектная модель документа). Что бы ее увидеть вживую откроем заготовленную страницу пример.
    
    
    // Для урока используются файлы с названием elements_index, elements_style, elements_script. В ксс заданы стили, и при открытии
    //  elements_index в браузере видим большой красный квадрат, 5 кнопок, 3 синих круга в столбце и 3 красных сердечка в ряду
    
    // Структура индекса
        // <body>
        //     <div class="box" id="box"></div>
        //     <button>1</button>
        //     <button>2</button>
        //     <button>3</button>
        //     <button>4</button>
        //     <button>5</button>

        //     <div class="circle"></div>
        //     <div class="circle"></div>
        //     <div class="circle"></div>

        //     <div class="wrapper">
        //         <div class="heart"></div>
        //         <div class="heart"></div>
        //         <div class="heart"></div>
                
        //     </div>

        //     <script src="js/script.js"></>
        // </body>

    // Весь ХТМЛ код является обычным документом у которого есть своя структура. И этот документ можно представить как дерево
        // узлов, при этом узлы связаны между собой отношениями родительский - дочерний.
        // Все элементы которые находятся в теге body являются его дочерними эл., а он по отношению к ним является родительским.
        // Такую структуру мы создаем во время верстки страницы. Когда такой документ сформирован мы его можем представить в
        // виде объекта, и как у любого объекта у него могут быть свои методы, их мы и будем использовать что бы иметь доступ
        // к определенным эл. на странице. Чтобы отбратиться к DOM нужно использовать такую сущность(глобальный объекат)
        // как document. Если в консоли написать document и поставить точку document. то высветится список из доступных ему 
        // свойств и методов, часть из которых мы и будем использовать.
        


    // +++ Работаем в  elements_script.

    // Создадим вместилище информации(переменную) в которую будем получать элементы методами const box =
     

    // Методы можно разделить на 1) устоявшиеся(старые) методы и 2) которые появились недаыно (новые). СНАЧАЛА(сейчас???) мы всегда 
        // обращаемся к document, (позже рассмотри как обращаться не через него ???) и так как это методы ставим для их вызова -().
        


        // *** 1) В скобках передаем просто строку без точек или хештегов с именем id, tag, class - потому что в самом запросе мы 
        // указываем к чему хоти обратиться.

        // * По ID. 
        // Получаем эл. по айди(Id) - уникальный идентификатор, как название переменной он может быть только один на странице
        // соответственно и получаем в переменную только 1 элемент. let box = document.getElementById(); В данном случае мы
        // получим элемент красного квадрата. <div class="box" id="box"></div>
        const box = document.getElementById("box");   
        console.log(box);       // <div class="box" id="box"></div> - получили элемент


        // * По TAG.
        // Получаем элементЫ по названию тега. Так как элементов с одинаковыми тегами много то мы получим псевдомассив со всеми 
        // элементами с именем такого тега, и обращаемся к тамим элементам во множественном числе Elements. * Так как это псевдо
        // массив то у него не будет никаких методов, только свойство length, потому что он наследуется не от [[Prototype]]: Array,
        // а от различных других объектов (более 50ти различный, вот небольшой список из них DOMTokenList, NamedNodeMap,DOMStringMap
        // HTMLCollection, NodeList, HTMLAllCollection, StyleSheetList, DOMStringList, HTMLMapElement, CSSRuleList) 
        // Что бы получить конкретный эл. из этого псевдомассива нужно указать индекс этого элемента.
        
        // * Даже если такой элемент будет 1 на странице мы все равно получим
        // псевдомассив с одним элементом, и что бы взяимодействовать с этим элементов все равно нужно обратиться к нему
        // таки мобразом btns[0] - по индексу 0.
        //Преобразование псевдомассива в массив https://habr.com/ru/post/336136/
        
        // Получаем эл сразу.
        btns = document.getElementsByTagName("button")[1];  // <button>2</button> - эл.
        
        // Получаем эл из массива прямо перед его использованием
        const btns = document.getElementsByTagName("button"); // [button, button, button, button, button] получили псевдомассив
        console.log(btns[1]);                               // <button>2</button> - эл. под индексом 1 в псевдомассиве
        
        
        // * По CLASS.
        // По имени класса, аналогично TAG.
        const circles = document.getElementsByClassName("circle");
        console.log(circles[1]);


        // * По NAME.
        // document.getElementsByName() - используется очень редко и даже в старом коде мы вредли его встретим. Похоже работает
        // аналогично TAG, потому что Elements.



        // *** 2) Современные методы более функциональны поэтому их чаще используют в проектах. Обращаемся по ксс селектору и
                // записывать его нужно как и в ксс  - тег 'button', имя класса '.heart' (с точкой), ID - '#box' (хэштег).
                // Ксс селектор может быть любой: вложенность классов, псевдоклассы, аттрибуты, непосредственных потомков,
                // первых правых соседей, и т.д. комбинация всего этого.
                // * Виды селекторов и как они записываются https://learn.javascript.ru/css-selectors


        // * ВСЕ элементЫ по данному ксс селектору. *Мы получаем псевдомассив который умеет работать ся методом forEach, наверное 
            // потому чnо наследуется от [[Prototype]]: NodeList, а не от [[Prototype]]: HTMLCollection как в случае со старыми
            // методами. Поэтому можно сделать перебор псевдомассива этим способом.
        const hearts = document.querySelectorAll('.heart'); 
        console.log(hearts);    // [div.heart, div.heart, div.heart]

        // Таким способом перебора будем пользоваться часто для смены стилей сразу у всех эл. псевдомассива, перебирая и каждому
            // присваивая какой-то стиль
        hearts.forEach(item => {
            console.log(item);  // <div class="heart"></div> <div class="heart"></div> <div class="heart"></div> - 3 эл.
        });
    

        // * Позволяет получить только ПЕРВЫЙ подходящий элемент
        const oneHeart = document.querySelector('.heart'); 
        console.log(oneHeart);

}



{/*         ====    ВИДЫ СЕЛЕКТОРОВ и как они записываются https://learn.javascript.ru/css-selectors

                Знаете ли вы селекторы?

        CSS3-селекторы – фундаментально полезная вещь.

        Даже если вы почему-то (старый IE?) не пользуетесь ими в CSS, есть много фреймворков для их кросс-браузерного использования CSS3 из JavaScript.

        Поэтому эти селекторы необходимо знать.

        Основные виды селекторов
        Основных видов селекторов всего несколько:

        * – любые элементы.
        div – элементы с таким тегом.
        #id – элемент с данным id.
        .class – элементы с таким классом.
        [name="value"] – селекторы на атрибут (см. далее).
        :visited – «псевдоклассы», остальные разные условия на элемент (см. далее).
        Селекторы можно комбинировать, записывая последовательно, без пробела:

        .c1.c2 – элементы одновременно с двумя классами c1 и c2
        a#id.c1.c2:visited – элемент a с данным id, классами c1 и c2, и псевдоклассом visited
        Отношения
        В CSS3 предусмотрено четыре вида отношений между элементами.

        Самые известные вы наверняка знаете:

        div p – элементы p, являющиеся потомками div.
        div > p – только непосредственные потомки
        Есть и два более редких:

        div ~ p – правые соседи: все p на том же уровне вложенности, которые идут после div.
        div + p – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div (если есть).
        Посмотрим их на примере HTML:

        <h3>Балтославянские языки</h3>

        <ol id="languages">
        ...Вложенный OL/LI список языков...
        </ol>
        CSS-селекторы:

        /*+ no-beautify *
        #languages li {
            color: brown;   /* потомки #languages, подходящие под селектор  LI *
        }
        
        #languages > li {
            color: black;   /* первый уровень детей #languages подходящих под LI *
        }
        
        #e-slavic { font-style: italic; }
        
        #e-slavic ~ li {  /* правые соседи #e-slavic с селектором LI *
            color: red;
        }
        
        #latvian {
            font-style: italic;
        }
        
        #latvian * {      /* потомки #latvian, подходяще под * (т.е. любые) *
            font-style: normal;
        }
        
        #latvian + li {  /* первый правый сосед #latvian с селектором LI *
        color: green;
        }
        Результат:
        
        
        Фильтр по месту среди соседей
        При выборе элемента можно указать его место среди соседей.
        
        Список псевдоклассов для этого:
        
        :first-child – первый потомок своего родителя.
        
        :last-child – последний потомок своего родителя.
        
        :only-child – единственный потомок своего родителя, соседних элементов нет.
        
        :nth-child(a) – потомок номер a своего родителя, например :nth-child(2) – второй потомок. Нумерация начинается с 1.
        
        :nth-child(an+b) – расширение предыдущего селектора через указание номера потомка формулой, где a,b – константы, а под n подразумевается любое целое число.
        
        Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо n. Например: -:nth-child(2n) даст элементы номер 2, 4, 6…, то есть чётные.
        
        :nth-child(2n+1) даст элементы номер 1, 3…, то есть нечётные.
        :nth-child(3n+2) даст элементы номер 2, 5, 8 и так далее.
        Пример использования для выделения в списке:
        
        
        /*+ hide="CSS к примеру выше"  no-beautify *
        li:nth-child(2n) { /* чётные *
            background: #eee;
        }
        
        li:nth-child(3) {  /* 3-ий потомок *
            color: red;
        }
        :nth-last-child(a), :nth-last-child(an+b) – то же самое, но отсчёт начинается с конца, например :nth-last-child(2) – второй элемент с конца.
        Фильтр по месту среди соседей с тем же тегом
        Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:
        
        :first-of-type
        :last-of-type
        :only-of-type
        :nth-of-type
        :nth-last-of-type
        Они имеют в точности тот же смысл, что и обычные :first-child, :last-child и так далее, но во время подсчёта игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.
        
        Пример использования для раскраски списка DT «через один» и предпоследнего DD:
        
        
        /*+ hide="CSS к примеру выше"  no-beautify *
        dt:nth-of-type(2n) {
            /* чётные dt (соседи с другими тегами игнорируются) *
            background: #eee;
        }
        
        dd:nth-last-of-type(2) {
            /* второй dd снизу *
            color: red;
        }
        Как видим, селектор dt:nth-of-type(2n) выбрал каждый второй элемент dt, причём другие элементы (dd) в подсчётах не участвовали.
        
        Селекторы атрибутов
        На атрибут целиком:
        
        [attr] – атрибут установлен,
        [attr="val"] – атрибут равен val.
        На начало атрибута:
        
        [attr^="val"] – атрибут начинается с val, например "value".
        [attr|="val"] – атрибут равен val или начинается с val-, например равен "val-1".
        На содержание:
        
        [attr*="val"] – атрибут содержит подстроку val, например равен "myvalue".
        [attr~="val"] – атрибут содержит val как одно из значений через пробел.
        Например: [attr~="delete"] верно для "edit delete" и неверно для "undelete" или "no-delete".
        
        На конец атрибута:
        
        [attr$="val"] – атрибут заканчивается на val, например равен "myval".
        Другие псевдоклассы
        :not(селектор) – все, кроме подходящих под селектор.
        
        :focus – в фокусе.
        
        :hover – под мышью.
        
        :empty – без детей (даже без текстовых).
        
        :checked, :disabled, :enabled – состояния INPUT.
        
        :target – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.
        
        Например, если на странице есть элемент с id="intro", то правило :target { color: red } подсветит его в том случае, если текущий URL имеет вид http://...#intro.
        
        Псевдоэлементы ::before, ::after
        «Псевдоэлементы» – различные вспомогательные элементы, которые браузер записывает или может записать в документ.
        
        При помощи псевдоэлементов ::before и ::after можно добавлять содержимое в начало и конец элемента:
        
        <style>
            li::before {
            content: " [[ ";
            }
        
            li::after {
            content: " ]] ";
            }
        </style>
        
        Обратите внимание: содержимое добавляется <b>внутрь</b> LI.
        
        <ul>
            <li>Первый элемент</li>
            <li>Второй элемент</li>
        </ul>
        
        Псевдоэлементы ::before/::after добавили содержимое в начало и конец каждого LI.
        
        :before или ::before?
        Когда-то все браузеры реализовали эти псевдоэлементы с одним двоеточием: :after/:before.
        
        Стандарт с тех пор изменился и сейчас все, кроме IE8, понимают также современную запись с двумя двоеточиями. А для IE8 нужно по-прежнему одно.
        
        Поэтому если вам важна поддержка IE8, то имеет смысл использовать одно двоеточие.

*/}



{ /*        ====    Преобразование ПСЕВДОМАССИВА в МАССИВ https://habr.com/ru/post/336136/
        
            Немного о псевдомассивах (массивоподобных объектах или коллекциях). «Что это?», «Как с ними работать?» и прочее
        JavaScript
        *
        В этой статье я расскажу про псевдомассивы: «Что это?», «Как с ними работать?», «Чем они отличаются от массива?», «Как преобразовать их в массив?».

        Так же, прежде чем начать, я уточню, что данная информация касается только JavaScript. То есть, я буду рассказывать о псевдомассивах в языке JavaScript.

        Что такое псевдомассив (массивоподобный объект или коллекция)?

        Псевдомассив — это объект, который структурно похож на массив. То есть у него есть числовые свойства (индексы) и свойство length.

        Пример:
        {0: 'Значение 1', 1: 'Значение 2', 2: 'Значение 3', length: 3};

        Чем псевдомассив отличается от массива?

        Главным отличием псевдомассива от массива является его наследование прототипа, то есть свойство __proto__.

        Когда мы посмотрим в свойства массива, то увидим, что он наследует прототип Array объекта. То есть, все свойства, которые есть в объекте Array.prototype будут доступны для любого массива. Если же посмотреть в свойства какого-либо псевдомассива, то можно заметить, что он наследует прототип другого объекта вместе с другими свойствами.

        Список типов объектов, которые относятся к псевдомассивам

        Псевдомассив может наследовать прототипы различных объектов. Вот маленький список типов объектов — псевдомассивов:

        DOMTokenList
        NamedNodeMap
        DOMStringMap
        HTMLCollection
        NodeList
        HTMLAllCollection
        StyleSheetList
        DOMStringList
        HTMLMapElement
        CSSRuleList

        Это маленькая часть из полного списка типов псевдомассивов, который имеет в себе более пятидесяти типов. Из этого вытекает следующий пункт статьи.

        Как отличить обычный объект от псевдомассива?

        Я дня три разбирал данный вопрос читая различные статьи и в итоге составил всего одно условие: если объект является псевдомассивом, то у него должно быть свойство length, которое должно являться целым числом и быть больше либо равно нулю.

        Number.isInteger(Number(object.length)) && Number(object.length) >= 0

        Это условие я составил откинув следующие пукнты:

        Нельзя равняться на числовые свойства, ведь если не указать их, то это не значит, что их не будет. Они просто будут равны значению undefined
        Когда я посмотрел типы псевдомассивов, то увидел, что в их типах содержится слово Collection, Map либо List. Но данная идея сразу развеялась, так как псевдомассив может иметь тип обычного объекта — Object,
        и вообще это глупо, ведь под этот пункт даже обычный массив не попадёт.
        Так же нельзя равняться и на нечисловые свойства, ведь нечисловое свойство может быть и в массиве.

        Но JavaScript «сказал», что и моё условие слишком жестокое. Когда я проанализировал варианты конвертирования псевдомассива в массив, то понял, что JavaScript «съест» псевдомассив, в котором свойство length равно числу, которое больше либо равно нулю.

        typeof object.length === 'number' && Number(object.length) >= 0

        И не обязательно, чтобы число было целым (кроме некоторых случаев). JavaScript просто переведёт дробное число в наибольшее целое число, меньшее, либо равное указанному.

        Пример:
        Array.from({0: 'Значение 1', 1: 'Значение 2', length: 1.6}); // ['Значение 1']
        Array.from({0: 'Значение 1', 1: 'Значение 2', 2: 'Значение 3', length: 2.3}); // ['Значение 1', 'Значение 2']

        Как конвертировать псевдомассив в массив?

        Чтобы преобразить псевдомассив в массив, есть несколько вариантов:

        Перебрать значения псевдомассива в обычный массив
        Первый вариант, который приходит в голову новичкам — с помощью цикла перебрать все значения из псевдомассива в массив.

        var object = {0: 1, 1: 2, 2: 3, length: 3}
        var array = [];

        // Преобразуем псевдомассив в массив
        for (var i = 0; i < object.length; i++) {
        array.push(object[i]);
        };

        console.log( array ); // [1, 2, 3]

        С помощью функции Array.from()
        Данный вариант немного спорный, так как таблицы, поддержки браузерами данной функции, на разных сайтах разные. Но я с уверенностью могу сказать, что во всех современных браузерах данный метод будет работать.

        var object = {0: 1, 1: 2, 2: 3, length: 3}
        // Преобразуем псевдомассив в массив
        var array = Array.from(object);

        console.log( array ); // [1, 2, 3]

        С помощью функции Array.prototype.slice.call() ( [].slice.call() )
        Этот метод «наших дедушек и бабушек», который работает до сих пор.

        var object = {0: 1, 1: 2, 2: 3, length: 3}
        // Преобразуем псевдомассив в массив
        var array = Array.prototype.slice.call(object); // Или сокращённая форма: [].slice.call(object);

        console.log( array ); // [1, 2, 3]

        С помощью spread оператора
        Данный метод во время написания данной статьи является довольно спорным, так как поддерживается до сих пор не всеми браузерами и будет работать только с «корневыми» псевдомассивами (NodeList, HTMLCollection и прочее).

        var object = document.querySelectorAll(selector);
        // Преобразуем псевдомассив в массив
        var array = [...object];

        console.log( array ); // [element, element, element]

        С помощью изменения свойства __proto__
        Про это свойство я упоминал в начале статьи. Если мы изменим свойство __proto__ объекта на Array.prototype, то псевдомассив преобразуется в массив. Но этот метод входит в те самые «кроме некоторых случаев», про которые я писал више, так как, для полного преображения в массив, свойство length должно являться целым числом.

        var object = {0: 'a', 1: 'b', 2: 'c', length: 3}
        // Меняем __proto__ объекта
        object.__proto__ = Array.prototype;

        console.log(object); // ['a', 'b', 'c']

        Так же тут есть одна особенность: если мы укажем length число, которое будет меньше чем количество записей в псевдомассиве, то у нас получится массив с количеством записей указанных в length и с дополнительными свойствами из остатка записей.

        var object = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', length: 3}
        // Меняем __proto__ объекта
        object.__proto__ = Array.prototype;

        console.log(object); // ['a', 'b', 'c', 3: 'd', 4: 'e']

        И ещё одна заметка: данный метод не сделает объект настоящим массивом, хоть и даст ему нужные параметры. В этом можно убедиться, если проверить объект с помощью функции Array.isArray();.

        var object = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', length: 3}
        // Меняем __proto__ объекта
        object.__proto__ = Array.prototype;

        console.log( Array.isArray(object) ); // false


        Это самые популярные методы преображения. Так же нужно сказать, что эти все методы можно не использовать, если вам нужно, к примеру, перебрать псевдомассив с помощью forEach или отфильтровать его функцией filter. Для таких целей в функциях есть дополнительная функция .call(), которая даёт возможность работать с псевдомассивами.

        Пример:
        var object = {0: 'a', 1: 'b', 2: 'c', length: 3}
        // Создаём массив из значений псевдомассива
        object = Array.prototype.map.call(object, v => 'Буква: ' + v); // Или сокращённо: [].map.call(object, v => 'Буква: ' + v)

        console.log(object); // ['Буква: a', 'Буква: b', 'Буква: c']

        На этом я закончу данную статью. Рассказал что хотел, а было ли это полезно для вас, решать вам.
  
*/}



{//  226    ====    INTERACTION WITH ELEMENTS    ====

    // Используем файлы из предыдущего урока. 
    


    // +++ СТИЛИ. 
    //У нас уже есть элементы которые мы получили со страницы, теперь будем с ними работать. Научимся изменять их СТИЛИ
        let box = document.getElementById("box"),
            btns = document.getElementsByTagName("button"),
            circles = document.getElementsByClassName("circle"),
            wrapper = document.querySelector(".wrapper"),
            hearts = document.querySelectorAll('.heart'),
            oneHeart = document.querySelector('.heart'); 

            
    // Чтобы понимать что мы можем сделать с элементов на странице посмотрим на него с помощью console.dir(); Раскроем объект и
        // тут можно видеть какие у него есть свойства и методы. Через поиск найдем свойство style: CSSStyleDeclaration. 
        // Его тоже раскрываем и видим еще одну большую структуру, это объект внутри объекта. Тут мы видим различные пустые
        // свойства которые сейчас и будем изменять. ВСЕ эти свойства - ИНЛАЙН свойства(которые прописываются в style в теге хтмл)
        // Свойства записываются в инлайн строку, прямо в хтмл, поэтому по приоритету они будут главнее чем сss свойства.
        console.dir(box);   // div#box.box - вывелся объект

    // Изменяем инлайн(inline) свойство - обращаемся к элементу box потом к его объекту style и теперь прописываем нужное
        // свойство только если в ксс стиль писался через тире(background-color) то в JS пишется кемел кейсом(backgroundСolor)
        // потом присваиваем ему нужное значение в формате строки. Изменим также ширину width - если просто указать 500 - это
        // не сработает потому что для ксс нужно указать единицы и поэтому нам нужно передавать это в виду строки '500px'
        box.style.backgroundColor = 'green';    
        box.style.width = '500px';  
        //Видим что цвет и размер квадрата поменялся.

 
    // Работаем с кнопками. Хотим обратиться к одной определенной кнопке 2. Для этого укажем индекс кнопки [1]. Измени закругление
        // углов кнопки  borderRadius укажем 100% строкой, теперь она похожа на овал.
        btns[1].style.borderRadius = "100%";


    // Самая частая ошибка новичков, когда мы хотим поменять цвет фона первого элемента из кружков нужно прописывать код также 
        // как для кнопки с индексом потому что тут тоже псевдомассив.
        circles[0].style.backgroundColor = "red";


    // * Задаем множество инлайн свойств  для одного элемента.  
        // Для этого есть спец. свойство - csstext - оно может передавать стили в качестве текста - в нем мы прописываем ксс
        // свойства не кемел кейсом, а так как оно пишеться в ксс файле. Так же в эту конструкцию можно подставлять переменные.
        // Это очень полезно если какие то параментры у нас динамически рассчитываются, например ширину модального окна в 
        // зависимости от устройства с которого зашел пользователь.
        let num = 400;
        box.style.cssText = `background-color: blue; width: ${num}px`;


    // * Чтобы назначить инлайн свойство сразу нескольким элементам массива, ведь неудобно и долго будет прописывать для каждого  
        // одну и туже строку меняя только индекс. Можно использовать цикл, перебирающую конструуцию for of или 
        // метод forEach(только если псевдомассив был получен querySelectorAll).
        
        // * Цикл. 
        //Когда перебираем массив нужно указывать i = 0 что бы не потерять первый элемент.
        for (let i = 0; i < hearts.length; i++){
            hearts[i].style.backgroundColor = "blue";
        }

        // * forEach
        // Вместо циклов в основном используем перебирающие методы
        hearts.forEach(item => {
            item.style.backgroundColor = "blue";
        });
    


    // +++ МЕТОДЫ    
    // Очень часто части сайта создаются(генерируются) при помощи JS, на таком принципе построен React.


    // *** Методы для создания элементов на лету
        const div = document.createElement("div"); // создали элемент <div></div> он существует только в JS, на странице мы его 
                                                    // пока не видим

        // также создается и текстовый узел(нода)(внутреннее наполнение тега), но этот метод используется редко
        const text = document.createTextNode("Новый текст");  


    // *** Теперь можем ЗАСТИЛИЗОВАТЬ эл. который сущетвует только внутри JS - ДОБАВИТЬ к визуальной оболочке. Если мы хотим
        // ПОЛНОСТЬЮ поменять эл. кардинальным образом то чаще всего мы не прописываем целую кучу стилей и даже не используем
        // cssText, мы модифицируем ксс КЛАССЫ элементов - можем их добавить или удалить. В реальных проектах мы скорее всего
        // не будем устанавливать инлайн стили, а будем работать с ксс классами. 
        // Обычно объекту назначают класс что бы применить сразу много аттрибутов.


    // Есть простое свойство className - в нем мы через пробел указываем классы которые нужно добавить к эл. Но пользоваться им
        // не стоит потому что оно устаревшее и неудобное. Вместо него используем classList - в нем через точку можем писать
        // действия с нашим классом(удаление, добавление, переключение, проверка на содержаие(наличие класса), определение
        // количества примененных классов к элементу).

        // Берем переменную div с созданным элементом  через точку указываем classList и еще через точку выбираем метод свойства
        //  класслист add - добавляет определенный класс. В ксс файле есть стиль black - его и назначим.
        // .black{
        //     width: 150px;
        //     height: 50px;
        //     line-height: 50px;
        //     text-align: center;
        //     background-color: black;
        //     margin-bottom: 30px;
        //     margin-top: 30px;
        //     color: #fff;
        // }

        div.classList.add("black");
        // Теперь элемент создан и он лежит только в переменной в JS и на странице его нету. 
    

    // *** Теперь его нужно ВСТАВИТЬ на страницу
        // Любой элемент можно вставить в конец, после определенного эл., удалить или заменить, но только по отношению к другому
        // элементу, потому что нам нужно отталкиваться от структуры ДОМ что бы четко сказать где разместить новый элемент.

        // Рассмотрим современные методы для работы со страницей, их небольшая проблема в том что в устаревших браузерах они
        // не будут работать. Можно это посмотреть на сайте https://caniuse.com/?search=prepend и введя нужный метод, например
        // prepend, красными квадратами показаны те браузеры и их версии в которых не будет работать данный метод.
        // В готовом проекте который будем выкладывать на хостинг нам нужно будет их перевести в старый стандарт чтобы проект
        // работал на старых браузерах тоже(это не всегда необходимо), этим занимается спец. технология без нашего участия, ее
        // мы изучим позже.

        // После современных рассмотрим устаревшие методы, потому что они все равно будут встречаться в коде и знать их нужно.


    // Рассмотрим самый простой вариант - добавим наш див в конец страницы(body), что бы мы его уже смогли увидеть на странице.
        // Обращаемся к document потом к тегу body и выбираем метод append (appendChild - устаревший)
        document.body.append(div); // созданный див в КОНЕЦ тега body


    // Можно вставить эл. не только в конец верстки, а и в любого другого родителя. Например у нас есть обертка сердец, див wrapper
        //Если элемент используется только 1 раз его не обязательно помещать в переменную поэтому пишем сразу document выбираем
        // элемент querySelector(".wrapper") и присоединяем к нему созданный элемент append(div)
        document.querySelector(".wrapper").append(div);  // эл. появился в КОНЦЕ тега  wrapper после сердечек 
        
        // Нам этот эл. еще несколько раз понадобится поэтому присвоим его переменной
        const wrapper = document.querySelector(".wrapper");
        
        // теперь можно произвести тоже действие не обращаясь к document потому что к нему мы обращались в переменной wrapper, а 
        // подставим сразу переменную для обращения к ней
        wrapper.append(div); // С переменной
        wrapper.appendChild(div); // УСТАРЕВШИЙ метод (разницы нету)

        // Присоединяем в НАЧАЛО обертки. Для присоединения нужно сначала получить элемент к которому присоединять
        wrapper.prepend(div); //Прикрепляем в НАЧАЛО тега


    // Вставить ПЕРЕД и ПОСЛЕ какого то элемента. Но сначала нужно эти элементы получить в переменную
        // querySelector будет искать .heart внутри wrapper,  wrapper должен быть получен перед этим запросом.
        
        // * можно получить эти переменные внутри wrapper обращаясь сразу к нему а не к document как в начале урока
        wrapper = document.querySelector(".wrapper");   // Получаем 1 эл. wrapper, содержащий эл-ты heart(блок эл-тов)
        oneHeart = wrapper.querySelector('.heart');     // Получаем 1 эл. heart из блока эл-тов wrapper
        hearts = wrapper.querySelectorAll('.heart');    // ПСЕВДОМАССИВ (узел/NodeList) из блока эл-тов wrapper
    
        hearts[1].before(div);  // перед вторым сердечком
        hearts[1].after(div);   // после второго сердечка

        wrapper.insertBefore(div,  hearts[1]); //СТАРЫЙ метод для бефор


    // *** УДАЛЕНИЕ со страницы
        circles[1].remove();
        wrapper.removeChild(circles[1]); //СТАРЫЙ метод


    // *** ЗАМЕНА одного элемента другим
        hearts[2].replaceWith(circles[0]); // Сердце заменяем кругом
        wrapper.replaceChild(circles[0], hearts[2] ); //Старый метод



    // +++ ВСТАВКА ТЕКСТА в элемент на странице  

    // Первый Метод Для вставки ТЕКСТА или ХМТЛ СТРУКТУРЫ
        div.innerHTML = "<h1>Hello World</h1>";

    // Второй Метод ТОЛЬКО для ТЕКСТА *(безопасность при вводе пользователем данных, что бы он случайно или намеренно не вставил
        // какую то конструкцию и не сломал верстку или даже тег script который ведет на сторонный ресурс и тогда может положить
        // сайт)
        div.textContent = "Hello";

    // Для вставки КУСКА ХТМЛ кода ПЕРЕД или ПОСЛЕ определенных ТЕГОВ(первым или последним тегов в середине тега)
        // afterbegin - в начало(первый в середине) элемента. beforeend - в конец в середину, afterend - после элемента
        // beforebegin - перед элементом
        div.insertAdjacentHTML("beforebegin", "<h2>Hello</h2>"); // вставляем второй аргумент "<h2>Hello</h2>" перед див

    // * можно получить эти переменные внутри wrapper обращаясь сразу к нему а не к document как в начале урока. Таким образом
        // можно четко задать место поиска этих элементов чтобы не захватить лишние.
        wrapper = document.querySelector(".wrapper");   // Получаем 1 эл. wrapper, содержащий эл-ты heart(блок эл-тов)
        oneHeart = wrapper.querySelector('.heart');     // Получаем 1 эл. heart из блока эл-тов wrapper
        hearts = wrapper.querySelectorAll('.heart');    // ПСЕВДОМАССИВ (узел/NodeList) из блока эл-тов wrapper

}



{//  227    ====    PRACTICE INTERACTION WITH ELEMENTS    ====

    // С Консольным приложением закончили, теперь будем работать со страницей. Распакуем файлы из архива в practice_project.



    /* ЗАДАНИЕ на урок:

        1) Удалить все рекламные блоки со страницы (правая часть сайта)

        2) Изменить жанр фильма, поменять "комедия" на "драма"

        3) Изменить задний фон постера с фильмом на изображение "bg.jpg". Оно лежит в папке img.
        Реализовать только при помощи JS

        4) Список фильмов на странице сформировать на основании данных из этого JS файла.
        Отсортировать их по алфавиту 

        5) Добавить нумерацию выведенных фильмов */

        'use strict';
        const movieDB = {
            movies: [
                "Логан",
                "Лига справедливости",
                "Ла-ла лэнд",
                "Одержимость",
                "Скотт Пилигрим против..."
            ]
        };



    //  +++ РЕШЕНИЕ
    
    {/* Мое решение
            'use strict';
        //  Задания на урок:

        // 1) При таком способе удалился весь блок и хоть верстка не сломалась элемента на месте нету и не на что действовать
            // стилям, поэтому вместо фонового темного цвета образовалось белое пространство.
            let delAdv = document.querySelector('.promo__adv');
            delAdv.remove();            

        // 2) 
            let genre = document.querySelector('.promo__genre');
            genre.textContent = "Драма"

        // 3) 
        // Реализовать только при помощи JS
            let bg = document.querySelector('.promo__bg');
            bg.style.cssText = 'background:url("img/bg.jpg")';

        // 4) 
        // 
        // 5) В такой конструкции будет ограничение по отображаемым элементам, нужно заменять(добавлять) верстку
            под каждый новый фильм(элемент массива).

            const movieDB = {
                movies: [
                    "Логан",
                    "Лига справедливости",
                    "Ла-ла лэнд",
                    "Одержимость",
                    "Скотт Пилигрим против...",
                    "Алешки",
                    'Алексеи',
                    'Акведуки'
                ]
            };
            let sortDB = movieDB.movies.sort();
            console.log(sortDB);

            
            let listFilms = document.querySelectorAll(".promo__interactive-item");
            console.log(listFilms.length);

            for (let i = 0; i < listFilms.length; i++ ){
                listFilms[i].innerHTML = `№${i + 1} ${sortDB[i]}`;
            }
    */}


    
    {const movieDB = {
        movies: [
            "Логан",
            "Лига справедливости",
            "Ла-ла лэнд",
            "Одержимость",
            "Скотт Пилигрим против..."
        ]
    };

    // 1 Через инспектор кода наводимся на элементы и находим их в верстке. Видим это это картинки(img) внутри блока с классом
        // promo__adv. Пропишем ппеременную adv и в нее через querySelectorAll получим все картинки( теги img ) внутри тега с
        // классом .promo__adv. Теперь когда мы их получили можно их удалить. Так как у нас получен ПСЕВДОМАССИВ элементов, мы
        //не можем сделать adv.remove() - потому что у него нету такого метода. Нужно взять каждый элемент из этого псевдомассива
        // и каждый удалить. Можно воспользоваться циклом, но давайте делать сразу правильно, так как псевдомассив получен через
        // querySelectorAll у него есть метод forEach, воспользуемся им.
        const adv =  document.querySelectorAll('.promo__adv img');
        
        adv.forEach(item => {
            item.remove();
        });
        // Обычная ф-я вместо стрелочной    adv.forEach( function (item){


    //2 находим эл. на странице, получаем его в переменную и изменяем "внутренности". В 3м задании нужно поменять фоновую картинку
        // у элемента в котором находится нужный нам сейчас элемент. Поэтому можем сразу в переменную взять родительский эл., а
        // потом в нем найти элемента для этого задания. Для простого изменения текста используем метод textContent.
        const poster = document.querySelector(".promo__bg"),
              genre = poster.querySelector(".promo__genre");

        genre.textContent = "Драма";


    //3 Элемент получен. Поэтому обращаемся к нему. Путь к картинке прописываем относительно файла index.html
        poster.style.backgroundImage = 'url("img/bg.jpg")'; //Прописываем внутры другие кавычки что бы избежать конфликта


    //4  Для начала удалим элементы которые есть в статичной верстке. Получае их родителя .promo__interactive-list.  Используем один
        //  селектор querySelector что бы получить доступ к родителю списка как к элементу чтобы у него был метод innerHTML.
        let movieList =  document.querySelector(".promo__interactive-list"); 

        movieList.innerHTML = ""; //Очистили список на странице ничего не передав

        movieDB.movies.sort(); // Так как это массив - сортируем по алфавиту перед добавлением на страницу

        //Теперь формируем верстку при помощи JS и поместим(вставим/добавим) ее на страницу, каждый раз когда в массиве будет проходить
        // новый элемент(итерация forEach) будет динамически добавленна строка, таким образом все фильмы из массива поместятся на 
        // страницу. Если делать это через createElement вручную создавать эл., добавить ему класс, потом добавить внутренность
        // из массива и потом поместить на страницу это не самый оптимизированный способ(много операций). Легче сразу вставить 
        // конструкцию(часть хтмл кода) с перевенной внутры которая будет меняться в зависимости от содержимого элемента массива.
        
        // * Дополнительное присваивание (+=) - плюс равно(может использоваться и минус "-") это сокращенная форма записи такой
        // конструкции   a = a + 1 или a += 1; используется что бы в переменную ДОБАВЛЯТЬ новое значение. В данном случае для
        // того что бы у нас не заменялось каждый раз содержимое тега, а оставалось старое и добавлялось новое. 
        
        // Так как вставляемая верстка будет строкой можно сделать интерполяцию и добавлять номер фильма из индекса + 1  ${i+1}  
        movieDB.movies.forEach((film, i) =>{    //
                movieList.innerHTML += ` 
                        <li class="promo__interactive-item">№${i + 1} ${film}
                            <div class="delete"></div>
                        </li>
                `;
        });
    

    // Также как и очистить элемент movieList.innerHTML = "",  innerHTML нам может вернуть, содержимое тега на текущий момент.
        // Для этого присвоим его какой то переменной и получим кусок верстки в строке. Таким же образом его можно и присвоить
        // для родительского тега.
        const inner = movieList.innerHTML;
        console.log(inner);
            // <li class="promo__interactive-item">ЛОГАН
                        
            // </li>
            // <li class="promo__interactive-item">ЛИГА СПРАВЕДЛИВОСТИ
            //     <div class="delete"></div>
            // </li>
            // <li class="promo__interactive-item">ЛА-ЛА ЛЭНД
            //     <div class="delete"></div>
            // </li>
                            // <li class="promo__interactive-item">ОДЕРЖИМОСТЬ
            //     <div class="delete"></div>
            // </li>
            // <li class="promo__interactive-item">СКОТТ ПИЛИГРИМ ПРОТИВ...
            //     <div class="delete"></div>
            // </li>
    }

}



{//  228    ====    EVENT LISTENER (События и их обработчики)    ====

    // Событие - сигнал от браузера о том что что-то произошло(клик, двойной клик, наведение мыши на эл., убирание мыши, прокрутка
        // колеса мыши, отправка данных из формы, нажатие клавиш на клавиатуре и т.д.).
        // Список событий в JS https://oddler.ru/blog/i63 ,  https://developer.mozilla.org/ru/docs/Web/Events
        // Мы их можем отлавливать.



    // Что бы использовать любое событие ему нужно назначить обработчик события - это ф-я которая срабатывает как только событие
        // произошло. Способа назначить обработчики событий всего 3: 
        
    // *** 1) использовать хтмл аттрибут который записывается прямо в верстке и в этот аттрибут можно прямо передать ф-ю из JS
        // Выбираем элемент на который хотим назначить обработчик события и прописывам событие с приставкой "on". Тоесть
        // событие называется click, а мы пишем onclick (при нажатии). Необходимо комбинировать кавычки чтобы измежать ошибки.
        // В реальных проектах такой способ не используется. Либо в совсем маленьких скриптов либо в тестовых проектах
        <button onclick = "alert('Click')" id="btn">Нажми меня</button>


    // *** 2) Используем СВОЙСТВО DOM дерева для событий.
        // при этом способе мы можем забыть что этот обработчик событий у нас уже используется на кнопке или из другого скрипта
        // на него навесится другой обработчик, тогда последний обработчик заменит все предыдущие, и поэтому код который написан
        // до этого перестанет работать(потеряется функционал). Еще один минус в том что иногда обработчики событий нам нужно
        // удалять (допустим единоразовое нажатие на кнопку на странице), то при таком способе назначения обработчика удалить
        // его потом мы не сможеи.
        let btn = document.querySelector("button"); // button - тег - выбирает только первый элемент с этим тегом
        
        btn.onclick = function(){
            alert("Knock");
        };

        btn.onclick = function(){
            alert("Second cilck");
        };


    //*** 3) addEventListener
        // Берем все тот же элемент и добавляем к нему конструкцию addEventListener (слушатель событий). В нем первый аргумент
        // click - название(без "on") события, второй аргумент коллбек функция с кодом который должен выполниться.
        let btn = document.querySelector("button");
        
        btn.addEventListener("click", () => {
            alert("click");
        });

        btn.addEventListener("mouseenter", () => { // при наведении на элемент
            console.log("Hover");
        });
        // При таком способе можно на один элемент назначать несколько обработчиков событий, которые выполняться поочередно.

        // События в JS выполняются в очередности их проишествия( одна большая очередь из всех событий).

        //Иногда необходимо получения данных об элементе(что за событие только что произошло, что за эл. используется, получить
        // координаты этого объекта). Для этого есть спец. объект Event, он передается как первый аргумент в callback функцию 
        // (e) - имя для него можно использоваеть любое (event). Поэтому если нужно передать свои аргументы ставим запятую и 
        // передаем следующими аргументами ("mouseenter", (e, "text message") => {
        btn.addEventListener("mouseenter", (e) => { 
            console.log(e);// при наведении получаем ОБЪЕКТ в консоль
        });

        // В этом объекте много разных данных координаты, type:"mouseenter" - тип события который произошел, 
        // target: button#btn - тот эл. на котором произошло событие. Эти свойства будем использовать очень часто.
        // Для того чтобы получать не весь объект, а сразу необходимый элемент можно через точку сразу указывать что мы хотим
        // получить console.log(e.target), и теперь мы можем с ним взаимодействовать: перекрасить, поменять класс или удалить.
        btn.addEventListener("mouseenter", (e)=>{ 
            console.log(e.target);// при наведении получаем на каком объекте сработало
            e.target.remove(); // получаем элемент и удаляем его после наведения
        });

    // *** removeEventListener
        // Для обработчика события мы пишем ф-ю и что бы удалить его нам снова нужно прописать ф-ю, но как и в задаче на массивы
        // которые одинаковые или нет a = [1, 2, 3]; b = [1, 2, 3]; тут ф-я объект и второй раз прописав ее для удаления, это
        // будет уже другая ф-я, поэтому нужно сразу присвоить ф-ю обработчика события переменной, чтобы потом на нее ссылаться.
        const deleteElement = (e) => {
            console.log(e.target);
        }
        btn.addEventListener("click", deleteElement); // теперь можно просто передать имя переменной в назначаемый обработчик
        btn.removeEventListener("click", deleteElement); // при клике сразу удаляет обработчик с этого элемента.
        //Оба обработчика срабатывают сразу и ничего не происходит

        //Рассмотрим более функциональный пример. Создадим переменную  i = 0, а в ф-ю допишем i++; и когда i == 2 удаляем обработчик
        // с кнопки  btn.removeEventListener("click", targetElement);
                
        let i = 0;
        const targetElement = (e)=>{ 
            console.log(e.target);
            i++;
            if(i == 2){
                btn.removeEventListener("click", targetElement); //Удаление 
            }
        };

        btn.addEventListener("click", targetElement);
        


    // +++ Всплытие событий(не путать со всплытием переменных hoisting, это другое) - когда событие срабатывает сначала на
        // вложенном элементе(на который назначен обработчик события), а потом на родителе поднимаясь все выше и выше если есть
        // большая вложенность. 

        //Поместим кнопку в див с классом overlay, теперь вокруг кнопки на странице
        // появился широкий контур. Назначим обработчик события на кнопку btn и на ее родителя overlay( в котором она лежит).
        const overlay = document.querySelector(".overlay");
        const targetOverlay = (e)=>{ 
         // console.log(e.target);          // на каком елементе произошло событие
            console.log(e.currentTarget);   // Показывает на каком елементе произошло событие СЕЙЧАС
            console.log(e.type);            // Тип произошедшего события
        };
        btn.addEventListener("click", targetOverlay);
        overlay.addEventListener("click", targetOverlay);
        //При нажатии на кнопку получили 2 раза вывод в консоль(двойное срабатывание ф-и) тоесть событие сначало сработало на
        // вложенной кнопке. а потом поднялось выше(всплыло) и сработало на родителе overlay. Причем в консоль 2 раза выводился
        // элемент на котором сработало событие изначально. Но если заменить свойство target на (e.currentTarget); тогда увидим
        // на КАКОМ именно элементе событие произошло СЕЙЧАС. Теперь в консоль выводится вторым элементом overlay. 
        
        // * Отмена стандартного поведения
        // На практике будем использовать свойство target, так как оно удобнее, а всплытые события можно отменять. Но на практике
        // оно тоже не особо нужно. потому что может доставить нам еще больше проблем. Поэтому будем отменять стандартное поведение
        // в браузере. 

        //СТАНДАРТНОЕ поведение
        //При клике на ссылку в браузере, то страница перейдет по этой ссылке взяв URL путь(Uniform Resource Locator. URL это лишь 
        // адрес, который выдан уникальному ресурсу в интернете) из аттрибута href, это СТАНДАРТНОЕ поведение ссылки.
        // Отправка данных из формы при нажатии кнопки submit, выделение текста при зажатии правой кнопки мыши. все эти стандартные
        // поведения мы можем отменять. Есть 2 способа:

        // *** 1) Вернуть в обработчике события return false; - в самом конце. Но этот способ устаревший и им почти никто не 
            // пользуется потому что есть второй вариант
        

        // *** 2) Предполагает использование МЕТОДА который есть у ОБЪЕКТА СОБЫТИЯ. Будем использовать очень часто, когда
            // дойдем до веб приложений, там будет много ссылок, но при этом мы не хотим переходить на другую страницу или 
            // перезагружать эту страницу, а будем назначать свои события на них, и каждый раз будем использовать preventDefault
            // Получим элемент ссылки а навесим на него обработчик <a href="https://www.youtube.com/">https://www.youtube.com/</a>
            
            const link = document.querySelector("a"); // получение елемента ссылки 
            link.addEventListener("click", function(event){
                event.preventDefault();     // отмена перехода по ссылке(стандартного поведения), всегда прописываем ВНАЧАЛЕ 
                console.log(event.target);  // вместо перехода по ссылке выполняется дальнейшый код
            });

    // +++ Применение обработчика события к МНОЖЕСТВУ элементов
        // Частая ошибка новичков они получают все элементы через querySelectorAll
        const btns = document.querySelectorAll("button");
        // и потом просто берут и назначают  btns.addEventListener("click", targetOverlay); и такой код работать не будет, потому
        // что у переменной btns нету такого метода потому что в ней лежит псевдомассив. Поэтому нужно его перебрать и навесить
        // обработчик на каждый элемент псевдомассива( можно использовать цикл, for of, но так как псевдомассив получили через
        // querySelectorAll - удобнее использовать forEach)
        btns.forEach(btn => {
            btn.addEventListener("click", targetOverlay);
        });



    // +++ ОПЦИИ СОБЫТИЯ (options)
        // третий аргумент EventListener (type, listener, options).  options: capture, once, passive, mozSystemGroup.
        // once - опция хорошая альтернатива removeEventListener, потому что не нужно теперь прописывать удаление обработчика
        // а можно прописать опцию once, которая сделает выполнение ОДИН РАЗ.
        btns.forEach(btn =>{
            btn.addEventListener("click", targetOverlay, {once: true});
        })

}



{//  229    ====    NAVIGATION IN DOM, DATA ATTRIBUTES, FOROF преимущества    ====

    // Научимся путешествовать по ДОМ дереву. Есть задача взять эл. и обратиться к его родителю или к следующему эл. и уже у них
        // поменять класс. Для тестов открываем заготовку 229 index.


    // Мы уже можем получать эл. из body. Также можем получить эл. из head например для динамической смены стилей.
        //получаем тег боди со всеми эл-ми. При наведении в консоли все эл. подсвечиваются
        console.log(document.body); // <body>...</body> - 
        
        // Также можем получить и head но эти элементы мы не увидим на странице. Видим содержимое head, таким образом мы можем
        // сменить title, добавить метатег, динамически подключить стили или шрифты.
        console.log(document.head);
    
    // Если смотреть на уровень выше от хед и бади, то увидим их родителя тег ХТМЛ (<html lang="en">). Его мы можем получить через
        // такое свойство. Это родительский эл. - объединяет находящиеся внутри него эл.
        console.log(document.documentElement); //- получаем ХТМЛ тег со всем содержимым



    // +++ Дочерние эл.(внутренние) можем получить при помощи 3х методов(команд)
        

        // *** Самая полезная на практике childNodes. Получает узлы которые являются детьми у бади - document.body.childNodes
        console.log(document.body.childNodes); //- NodeList(6) [text, div.wrapper, text, script]
        // псевдомассив(NodeList) узлов(нод) боди 4 эл., а если их раскрыть то получаетс 8 эл.
        // 0: text 1: div.wrapper 2: text 3: script 4: text 5: comment 6: text 7: script 8: text 

        // Разберем что за эл. Заходим в Elements открываем body видим что сначала идет текстовый узел между body и
        // оболочкой wrapper (== $0), его в обычной верстке не видно, только если нажать на эл. в этой вкладке в браузере
        //  - это обычный перенос строки, он считается текстовой нодой(узлом). Дальше вторым эл. идет эл. wrapper.
        // После него снова идет text - перенос строки(== $0). И дальше идет script где мы используем JS.

        // При первом рендере страницы этих эл. всего 4. Остальные элементы 8 когда раскрываем подставились нам из-за работы
        // live server. Он подставляет свой комментарий в верстку + 2 переноса строки до и после коментария и еще один перенос
        // идет после тего script.

        // * Разница между ДОМ эл. и узлом в том что элементы - все элементы могут быть узлами, но не все узлы могут быть эл-ми.
        // Как я понимаю ВСЕ элементы в тегах, которые видно в верстке в редакторе кода и они выступают узлами если берется 
        // псевдомассив эл-в, а некоторые узлы видно только в браузере во вкладке Elements и в псевдомассиве. Узлами выступают
        // переносы строк, текстовые эл. Например лист айтем <li>1</li> - это элемент, но в нем есть текстовый узел "1".

        // *** Можно получить первого ребенка(узел)
        console.log(document.body.firstChild); // #text - первая Нода(узел переноса строки)

        // *** Можно получить последнего ребенка(узел)
        console.log(document.body.lastChild);// <script>...</script> - последняя Нода(тег script с содержимым)



        // +++ Аналоги для получения ЭЛЕМЕНТОВ 

        // *** Можно получить первый элемент
        console.log(document.body.firstElementChild); // <div class="wrapper"> - первый эл. бади

        // *** Можно получить последний элемент
        console.log(document.body.lastElementChild); // <script>...</script> - последний эл. бади


        // *! Аналога childNodes для получения псевдоколлекции ТОЛЬКО ЭЛЕМЕНТОВ - НЕТ. Тогда метод создают вручную. Можно 
        // использовать forEach для перебора псевдоколлекции но в этом случае нужно использовать перебор for of  потому что в нем 
        // есть break и continue - которым мы будем отсеивать(пропускать) текстовые ноды(Только те у которых NodName: "#text"-  
        // узлы переносы на новую строку), если будет какой то коментарий добавленый вучную(<!-- comment -->), его тоже оставит.

        for(let node of document.body.childNodes){
            if(node.nodeName == "#text"){ // пропускаем узлы содержащие в свойстве NodName: "#text"
                continue;              
            }
            console.log(node);
        }



    // Мы отталкивались от родительского элемента, теперь рассмотрим методы которые позволяют оттолкнуться от любого эл. на 
        // странице. Они позволяю получить, родителя, соседей и детей. Получим элемент  <button id="current"></button> по айди
        // так как будем использовать 1 раз то не помещаем его в переменную
        console.log(document.querySelector("#current"));
        
        // Посмотрим на верстку. Этот эл. у нас кнопка которая находится между двумя другими кнопками для которых родителем
        // выступает <div class="first">. Допустим задача - при клике на кнопку получить её родителя.
        console.log(document.querySelector("#current").parentNode); // <div class="first">...</div> - получаем родительскую ноду 

        // Если нам нужно получить родителя еще на уровень выше коим является <div class="wrapper"> пропишем
        console.log(document.querySelector("#current").parentNode.parentNode);// получаем ноду родителя еще на уровень выше
        

        // *! Получаем родительский ЭЛЕМЕНТ. Таким образом мы ТОЧНО знаем что получим элемент.
        console.log(document.querySelector("#current").parentElement); // получаем ЭЛЕМЕНТ



    // +++ Data аттрибуты. 
        // Когда пишем скрипты нам не хватает ориентиров, конечно мы можем везде в верстке расставить id(айдишники), но у этого
        // способа есть минус, поговорим дальше о нем. Для удобного ориентирования были созданы data аттрибуты с таким синтаксисом
        // <li data-current="3">3</li>. Всегда начинаем его с этой части "data-" , а дальше пишем абсолютно все что хотим, например
        // data-current или data-modal(модальное окно) или data-close(этот эл. будет что то закрывать.) Если оставить без
        // значения data-current то оно будет приравниваться к data-current = true, означает что этот аттрибут у нас существует,
        // но можно и присвоить значение data-current="3". 
        
        // Для получения эл. по аттрибуту ставим [] квадратные скобки. *!комбинация кавычек
        console.log(document.querySelector("[data-current='3']"));// элем по дата аттрибуту 

        // Методы получени следующей и предыдущей НОДЫ(узел)
        console.log(document.querySelector("[data-current='3']").nextSibling); //#text - Следующая нода(узел переноса строки)
        console.log(document.querySelector("[data-current='3']").previousSibling); //#text - Предыдущая нода


        // Аналогичные методы для ЭЛЕМЕНТО
        console.log(document.querySelector("[data-current='3']").nextElementSibling);   // <li>4</li> -Следующий элемент
        console.log(document.querySelector("[data-current='3']").previousElementSibling);// <li>2</li> -Следующий элемент

}



{//  230    ====    PRACTICE USE eventListeners    ====
        
    // Будем использовать проект с фильмами из прошлой практики в папке - practice_project
    


    /* ЗАДАНИЕ на урок:

        1) Реализовать функционал, после заполнения формы и нажатия кнопки "Подтвердить" - новый фильм добавляется в список
            movieDB. Страница не должна перезагружаться.
            *Для получени доступа к значению input обращаемся к нему как input.value; - тут есть несколько вариантов решения.

        2) Если название фильма больше чем 21 символ, обрезать его и добавить три точки

        3) При клике на мусорную корзину (на против фильма) - элемент будет удаляться из списка (сложно).

        4) Если в форме стоит галочка - "Сделать любимым" - в консоль выводится сообщение "Добавлен любимый фильм"

        5) Фильмы сортируются по алфавиту
        */



    //  +++ РЕШЕНИЕ    
        {// Мое решение
            'use strict';

            const movieDB = {
            movies: [
                "Логан",
                "Лига справедливости",
                "Ла-ла лэнд",
                "Одержимость",
                'Алешки',
                "Скотт Пилигрим против..."
            ]
            };
                
            const adv =  document.querySelectorAll('.promo__adv img');
            
                adv.forEach(item => {
                    item.remove();
            });
                
            const poster = document.querySelector(".promo__bg"),
                  genre = poster.querySelector(".promo__genre");
        
            genre.textContent = "Драма";
        
            poster.style.backgroundImage = 'url("img/bg.jpg")'; 
        
            let movieList =  document.querySelector(".promo__interactive-list"); 
        
            // 30 lesson
               
            let btn = document.querySelector('button');
            let input = document.querySelector('.adding__input');
            let mark = document.querySelector('[type=checkbox]');
        
            btn.addEventListener("click", (event) => {
                event.preventDefault();         // 1)
        
                if( input.value.length < 21) {  // 2)
                movieDB.movies.push(input.value);
                } else {
                    movieDB.movies.push(input.value.slice(0, 21) +"...");
                }
        
                if(mark.checked) {              // 4)
                    console.log("Добавлен любимый фильм");
                }
        
        
                movieList.innerHTML = ""; 
        
                movieDB.movies.sort();          // 5)
        
                movieDB.movies.forEach((film, i) =>{    
                    movieList.innerHTML += ` 
                            <li class="promo__interactive-item">№${i + 1} ${film}
                                <div class="delete"></div>
                            </li>
                    `;
                });
                // console.log(movieDB.movies);
            });
            // 3) При клике на мусорную корзину (на против фильма) - элемент будет удаляться из списка (сложно).
                // НЕ СДЕЛАЛ

        }



        {'use strict';

        // Некоторые страницы плохо оптимизированы, и так как построение ДОМ дерева идет сверху вниз и там будут тяжелый картинки
        // например, элементы могут долго появляться на странице, а наш код уже может обращаться к странице для получения эл. 
        // которых еще нету. Чтобы наш код не начал работать раньше чем страница загрузиться нужно его обернуть в обработчик события
        // с callback функцией которая начнет работать ТОЛЬКО при ПОЛНОМ ПОСТРОЕНИИ ДОМ дерева. Для этого у нас есть 2 
        // отслеживаемых события: 1) load - когда страница ПОЛНОСТБЮ загрузилась со всеми скриптами и картинками; 
        // 2) DOMContentLoaded - при этом мы ждем не полной загрузки всех элементов на странице, а только построение ДОМ структуры,
        // то есть когда наше дерево тегов (DOM) сформируется полноценно для нормальной работы с ним, тогда наши скрипты начинают
        // работать а картинки и остальное еще подгружаются.

        document.addEventListener('DOMContentLoaded', () =>{ // - скрипт начнет работу при полной загрузке ДОМ дерева

            const movieDB = {
                movies: [
                    "Логан",
                    "Лига справедливости",
                    "Ла-ла лэнд",
                    "Одержимость",
                    "Скотт Пилигрим против..."
                ]
            };
            
            const adv =  document.querySelectorAll('.promo__adv img');  // Удаление рекламы
            const bg = document.querySelector(".promo__bg"),     
            genre = bg.querySelector(".promo__genre");
            let movieList =  document.querySelector(".promo__interactive-list"); // Доступ к родителю списка
        

        // 1) На сайте при нажатии на кнопку "Подтвердить" идет отправка формы на серверер и стандартное действие при этом - 
            // перезагрузка  страницы. Можно решить парой способов 1) когда отправляется форма - добавляем новые данные в массив и
            // после этого заново строим список фильмов; 2) делаем это паралельно добавляем новый эл. в верстку и новый эл. в
            // массив. На этом этапе разныци в быстродействии не будет, но второй способ тяжее реализовать, поэтому разберем
            // только первый способ.

            // Получим эл. с которыми будем работать.
            const addForm = document.querySelector("form.add"); //<form class="add"> - форма с классом add
            const addInput = addForm.querySelector(".adding__input"); // в теге form ищем класс <input class="adding__input"
            const checkbox = addForm.querySelector("[type=checkbox]");  // ищем по аттрибуту <input type="checkbox">


            // Для отслеживания отправки формы используем обработчик событий по событию submit
            addForm.addEventListener('submit', (event)=>{
                event.preventDefault();         // отменяем стандартное поведение формы

                let newFilm = addInput.value;   // берем введенный пользователем текст
                const favorite = checkbox.checked; // обращаемся к чекбоксу по свойству checked, оно вернет true или false при 
                                                 // изменении состояния галочки(onchange)
                
                if(newFilm) {  // Проверка на пустую строку(если ничего не ввели - false)
                    if(newFilm.length > 21){
                        newFilm = `${newFilm.substring(0, 22)}...`; //проверяем на длинну символов и добавляем троеточие
                    }
                    if(favorite){
                        console.log("Добавляем любимый фильм");
                    }
                        movieDB.movies.push(newFilm);  // пушим фильм в массив
                        sortArr(movieDB.movies);        // заново сортируем список
                        
                        createMovieList(movieDB.movies, movieList); // заново строим список фильмов на странице
                }
            
                event.target.reset(); // *! удаляем текст из формы (addForm заменили на event.target разницы нету)
            });


            // Создаем функцию для вывода списка чтобы ее можно было вызвать при нажатии и добавляем аргументы чтобы отойти от 
                // переменных а ф-я узнавала с чем она работает только в момент вызова.
                function createMovieList(films, parent){
                    parent.innerHTML = ""; //Очистили список на странице
                    sortArr(films);         // Сортирует и при загрузке страницы потому что createMovieList вызывается при загрузке

                    films.forEach((film, i) =>{    //a=a+1 или a+=1;
                        parent.innerHTML += ` 
                                    <li class="promo__interactive-item">№${i+1} ${film}
                                        <div class="delete"></div>
                                    </li>
                            `; 
                    });

            // Корзинка на которую нужно нажать чтобы удалился фильм создается динамически с помощью CSS. В верстку в браузере
                // к каждому фильму элементу с фильмом после построения списка фильмов добавляется див с классом delete
                // <div  class="delete" - это и есть та самая корзинка. Чтобы корзинка соответствовала тому фильму на против
                // которого расположена нам нужно брать список(массив) корзинок после построения нового списка и вешать на
                // каждую обработчик события для удаления родителя корзинки + к этому нужно будет удалить фильм из базы
                // данных и перестроить список.
                document.querySelectorAll(".delete").forEach((btn, i)=>{ //находим кнопки удаления через класс <div  class="delete"
                    btn.addEventListener("click", ()=> {
                        btn.parentElement.remove();
                        movieDB.movies.splice(i, 1); //удаляем 1 элемент под номером i из массива(базы данных) 
                        createMovieList(films, parent); //заново перестраиваем список чтобы перестроить нумерацию,
                                                        // вызывая функцию внутри себя (Рекурсия)
                    });
                });
            }  


            // Оборачиваем удаление рекламы в ф-ю что бы ее вызвать и добавляем параметры что бы отвязаться от переменных.
                const deleteAdv = (arr)=>{
                    arr.forEach(item=>{
                        item.remove();
                    });
                };


            // Оборачиваем два действия в ф-ю
                let makeChanges = () =>{
                    genre.textContent = "Драма";
                    bg.style.backgroundImage =  "url('img/bg.jpg')";
                };


            // Создадим дефолтную ф-ю для сортировки для того если наша ф-я будет дополняться, например добавится проверка сортируемых
                // эл., возможно подключить доп. ф-ю сортировки как мы делали с числами.
                let sortArr = (arr) =>{
                    arr.sort();
                };
                
            deleteAdv(adv);
            makeChanges();
            createMovieList(movieDB.movies, movieList); // вызываем один раз для построения первоначального списка

        });

        }

}



{//  231    ====    EVENTS on MOBILE devices    ====

    // Главное отличие моб. браузеров от обычных - в них не происходят события связанные с мышкой(клик, наведения  
        // мыши на эл., и т.д.). Вместо них есть tap - прикосание пальцем к экрану, также пальцев может быть  
        // несколько, потому-что поддерживается мультитач.

    // *! Моб. браузеры нормально отрабатывают с обычными сайтами, если мы установили событие - клик, то оно будет
        // корректно отрабатывать на мобильном. JS  сам запускает сразу серию событий чтобы ничего не пропустить.


    // Событий на моб. браузерах 6 и все они начинаются со слова touch.
        // 1) touchstart - срабатывает при касании к элементу
        // 2) touchmove - коснулись к элементу и двигаем палец, будет срабатывать при каждом перемещении пальца
        // 3) touchend - когда палец перестает касаться (оторвался от эл.)
        // 4) touchenter - ведем пальцем по экрану и наскакиваем на эл.(заход на пределы элемента)
        // 5) touchleave - противоположное, когда палец уходит с эл. но не оторвался от экрана
        // 6) touchcancel - возникает когда точка соприкосновения не регистрируется, когда не отрывая пальца
                            // он выходит за пределы браузера на рабочий стол или другое приложение.

    // Посмотрим на практике как это работает. Навесим обработчик события для того что бы скрипт начал
        // работать при полной загрузке ДОМ дерева. Файл с названием 31 индекс_тач. У нас есть один эл.
        // для начала работы получим его в переменную.
        window.addEventListener('DOMContentLoaded', () => {
            const box = document.querySelector('.box');

            box.addEventListener('touchstart', (e) => {
                e.preventDefault();
                console.log('start!');
                console.log(e.touches); // TouchList {0: Touch, length: 1} объект с одним пальцем под индексом 0
            });

            box.addEventListener('touchmove', (e) => {
                e.preventDefault();
                console.log('Move');
                console.log(e.targetTouches[0].pageX); // 78.33332824707031 - коорд. касания ПЕРВОГО пальца по Х
            });

            box.addEventListener('touchend', (e) => {
                e.preventDefault();
                console.log('End');
            });
        });

        // Назначили сенсорное событие которое произойдет если будет касание пальца, в браузере можем эмулировать
        // мобильное устройство. Для этого нужно открыть панель разработчика и нажать вторую кнопку в левом
        // верхнем углу Toggle device toolbar ctrl+shift+m. Теперь при нажатии на эл. срабатывает событие касания
        //  пальцем.
        // Добавим еще 2 самых частых события touchmove и touchend. touchmove - зажав кнопку и ведя по элементу
        // появляется много сообщений move, при малейшем сдвиге мышки, даже на 1 пкс. touchend - срабатывает при
        // отжатии кнопки.

    // Эти события полезно знать потому что на телефоне есть swipe - смахивание пальцем на следующий эл., такое
        // поведение генерируется при помощи сенсорных событий. Также действие "щипок" - когда мы увеличиваем
        // или уменьшаем что то на экране тоже генерируется этими событиями.


    // Когда работаем с сенсорными устройствами у объекта элемента (e) есть дополнительные свойства:
        // 1) touches - свойство выдает списоквсех пальцев взаимодействующих сейчас с ЭКРАНОМ. Если раскрыть
                        // такой список  можно увидеть target - с чем было произведено действие, координаты,
                        // угол наклона.
        // 2) targetTouches - показывает список всех пальцев которые взаимодействуют сейчас с ЭЛЕМЕНТОМ.
        // 3) changedTouches - список пальцев которые участвуют В СОБЫТИИ. Например если это событие touchend
                        // то список будет содержать и палец который был убран, даже если еще 4 пальца у нас на
                        // экране.

    // Рассмотрим как можно в простом варианте реализовать отслеживание движения пальцев в єлементе.
        // в touchmove в консоль будем выводить не просто сообщение, а (e.targetTouches[0].pageX) - координаты
        // касания ПЕРВОГО [0] пальца по иксу, которые будут выводиться как только положение пальца по горизонтали
        // будет изменяться. Если координаты перейдут через определенное значение(границу) то произойдет 
        // переключение слайда в слайдере, тут нужно будет строить логику под каждый отдельный скрипт. В реальных
        // проектах с нуля такие большие сложные объекты мы врятли будем создавать, для них есть уже готовые
        // библиотеки такие как hammer.js https://hammerjs.github.io 

}



{//  232    ====    Async, defer, DYNAMIC scripts    ====

    // Будем оптимизировать загрузку скриптов на страницу. Как правильно это делать и как оптимизировать.
        // Повторим действия браузера. Когда он открывает индекс.хтмл - браузер считывает DOCTYPE понимает что это ХТМЛ
        // страница, видит какой язык установлен основным, дальше начинает загружать head: подгружает meta теги - устанавливает
        // их на странице, потом устанавливает title. дальше подгружает стили которые тут прописаны.
        // Потом переходит к body и начинает строить верстку тег за тегом сверху вниз, в конце если подключен скрипт - загружается
        // скриптовая структура и идет дальнейшая работа со скриптом. Далее страница загржается полностью.
        
    // Новички могут подключить скрипт в head и тогда если скрипт работает с эл. на странице которые еще не построились, будет
        // ошибка, а вторая проблема это то что выполнение скрипта блокирует построение страницы(ДОМ структуры).
        // Первую проблему мы частично решали при помощи обработчика события DOMContentLoaded, а вторую проблему пока решали
        // подключением скрипта в конце документа, НО для больших проектов где очень много верстки такой способ не подойдет,
        // потому что пока будет строиться вся верстка скрипт работать не будет, это будет очень заметно если у пользователя
        // плохая скорость интернета или картинки на сайте неоптимизированы. Для решения такой проблемы были придуманы два
        // аттрибута defer и async.



    // defer - этот аттрибут сообщает браузеру что он должен продолжать обрабатывать страницу
        // и загружать скрипт в фоновом режиме, а затем запустить скрипт когда он загрузится (*! загрузка DOM будет выполнена).
        // Скрипты с defer никогда не блокируют построение страници. Скрипты с defer выполняются *! последовательно
        // поэтому есть недостаток если впереди маленького скрипта стоит большой, маленький будет ждать выполнения(загрузки) 
        // большого. Таким образом подключая скрипты мы можем быть уверены что сначала загрузится важный скрипт например с
        // библиотекой jQuery, а потом тот который работает с этой библиотекой и зависит от нее. Можно даже поместить такие
        // скрипты в head, но в реальных проектах, такие инструменты как google test speed будут ругаться и просить перенести
        // скрипты в body, так что такая структура не всегда актуальна.
        
        // <script defer src="js/main.js"></script>  // - подключение скрипта помещено в начало body или даже в head



    // async - запускается как только он будет загружен не ждет полного построения DOM модели, и других скриптов. Для async 
        // и других скриптов существуют две разные очереди выполнения.
        // Используется для подвязки скриптов которые не зависят от DOM или других скриптов сайта(метрики и счетчики - которые
        // должны загрузиться раньше всех на страницу и уловить присутствие пользователя).Из двух скриптов с async начнет работать 
        // первым тот который быстрее загрузился и обработался.

        <script async src="js/main.js"></script>
    


    // Динамически загружаемый скрипт ведет себя как *! async(выполняется сразу), пример формирования скрипта в другом скрипте.
        // Такой скрипт начнет выполняться как только будет помещен на страницу после обработки строчки с присоединением append.
        // При тестировании в консоли браузера видна небольшая задержка при выполнени второго(созданного) скрипта. Если в скрипте
        // создаются два скрипта последовательно то они будут выполнятся в порядке подгрузки на страницу.

        const script = document.createElement("script"); //создаем елемент
        script.src = "js/test.js";                       //задаем атрибут сорс
        document.body.append(script);    //присоединяем к боди(помещается в конец) (помещаем на страницу) и тут же он выполняется


    // В редких случаях нанм нужно отменить асинхронное поведение динамически загружаемого скрипта, тогда обращаемся к атрибуту
        // script.async и установим ему значение false, перед тем как поместить скрипт на страницу. Теперь скрипты будут вести себя
        // не как асинхронные и будут выполняться строго друг за другом.

        function loadScript(src){
            const script = document.createElement("script");
            script.src = src;
            script.async = false;
            document.body.append(script);
        }

        loadScript("js/test.js"); //будут выполнятся последовательно
        loadScript("js/some.js");

}





// 300 ============================================= В РАБОТЕ =====================================================================


{//  302    ====    Classlist и делегирование событий    ====

    // Рассмотрим classlist на заготовленном примере 302. Видим минипроект из кнопок в ксс файле есть разные стили.
        <div id="first" class="btn-block">
            <button class="blue some"></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
            <button></button>
        </div>



    // Мы уже рассматривали добавление стиля через класслист add. Теперь рассмотрим другие возможности. Сначала получим псевдомассив
        // со всеми кнопками на странице. Если мы напишем так btns.classList - то ничего не сработает, потому что у псевдомассива
        // не существует такого свойства. Нами нужно обратиться к конкретному элементу, например первая кнопка с индексом 0
        // btns[0].classList.length - таким образом можно увидеть какие классы есть у эл. - получили число 2. Чаще на практике
        // применяются методы свойства classList.

        const btns = document.querySelectorAll("button"); // Получим псевдомассив со всеми кнопками.

        console.log(btns[0].classList.length); // 2  (класса <button class="blue some"></button>)
        console.log(btns[0].classList.item(0));   // 'blue' - получаем название класса, () - скобки нужны потому что метод
        console.log(btns[0].classList.item(1));     // "some" - второй класс
        
        console.log(btns[0].classList.add("red", "green")); //<button class="blue some red green"></button> добавление классов
        console.log(btns[0].classList.remove("blue")); //удаление класса, можно добалять и удалять несколько сразу
        console.log(btns[0].classList.toggle("blue")); // если класс есть на элем. его удалит, если нету добавит


    // Использование класса в условии. Мы не знаем на каком месте находится класс item(0) или item(1) для этого есть метод
        // contains - который проверяет наличие класса на всем элементе(возвращает true или false). 

        if (btns[0].classList.contains('red')){  //проверяем содержит ли элемент класс red, если да то выполнится код
            console.log("red");
        }


        // Таким образом часто добавляют динамически классы для выезжающего меню. Например при клике на кнопку добавляется класс
            // для менюшки и она показывается, а при повторном клике класс убирается и она скрывается. Тут мы при клике на первую
            // кнопку будем менять цвет второй кнопки.

            btns[0].addEventListener("click", ()=>{
                if(!btns[1].classList.contains("red")){ //проверяем отсутствие у второй кнопки класса red
                    btns[1].classList.add("red");       // добавим класс
                } else{
                    btns[1].classList.remove("red");    //если класс есть то удалим
            }
    
        // Можно использовать toggle, но иногда нужно вручную(через условие) проверить на класс в сложных скриптах
            btns[1].classList.toggle("red");
            });


    // Устаревший метод className выводит классы одной строкой и потом нужно для взаимодействия с этой строкой постоянно ее 
        // изменять что не удобно, а classList содержит псевдомассив с которым удобнее работать.
        console.log(btns[0].className);     // 'blue some'



    // +++ ДЕЛЕГИРОВАНИЕ СОБЫТИЙ - используется для назначения одного события на несколько элементов даже если они созданы без
        // *! нас(динамически). Назначаем обр. события на РОДИТЕЛЯ элементов, а при клике в этой области проверяем на что
        // (какой эл. внутри родителя) был клик и сравниваем с заданными параметрами(удостоверимся то клик был в кнопку).
        // Проверка производится и на существование тега на странице event.target и на его название(свойство) которое всегда пишется 
        // капсом event.target.tagName. Например в верстке есть тег <br>(перенос строки) - но на странице его не видно и по нему
        // невозможно кликнуть, поэтому для него сравнение event.target будет false и условие не сработает.
        
        // сравнивать можно с nodeName и classList - if(event.target && event.target.classList.contains("blue"))   

        const wrapper = document.querySelector(".btn-block"); //родитель кнопок <div id="first" class="btn-block">

        wrapper.addEventListener('click', function(event){
            if(event.target && event.target.tagName == "BUTTON"){//проверяем на существование тега и на равенство строке "BUTTON"
                console.log("Hello!");
            }
        });


        // Еще один способ который очень любят сотрудники гугла. вместо тагнейм или класснейм можем проверять на определенные
        // СОВПАДЕНИЯ. У event.target есть метод matches() - по простому это значит что какой то эл. совпадает с чем-то. Это
        // продвинутое делегирование потому что тут мы указываем селекторы которые нас интересуют. В данном случае событие 
        // сработает только на кнопках с классом red( созданной на лету далее), на остальных не работает, но когда вторая кнопка 
        // окрашивается в красный (к ней применяется класс red), то на ней тоже начинает срабатывать.

        wrapper.addEventListener('click', (event) => {
            if(event.target && event.target.matches("button.red")){ //совпадение тега баттон у которого есть класс ред
                console.log("Hello!");
            }
        });


        // Для проверки делегирования для кнопок созданных на лету создадим еще элемент кнопки. Если эл. подойдет под условие, то
        // делегирование сработает на нем. 
        
        const btn = document.createElement('button'); //создаем элемент
        btn.classList.add('red'); // добавляем ей класс ред что бы видеть ее на странице
        wrapper.append(btn);      //прикрепляем в элемент wrapper


        //*! Если кнопки созданы в скрипте динамически и к ним вместо делегирования применить перебор псевдомассива btns через 
        // forEach и назначение addEventListener с какой то ф-и на каждый эл. псевдомассива, то эта ф-я будет работать только
        // на тех эл. которые были в верстке, а не на динамически созданные.
       
        btns.forEach(btn => {
            btn.addEventListener('click', () => {
                console.log("Hello!");
            });
        });

}



{//  303    ====    Создание Табов (вкладок)    ====

    // Начинаем работать с новым проектом Project_food в папке 303 и напишем в нем один из самых часто встречающихся эл. 
        //на странице - ТАБЫ.

        // Откроем index.html и в конец body  подключим скрипт script.js. 
        // На странице есть меню справа от большой картинки Выберите стиль питания с элементами(ссылками/кнопками): Фитнес
        // Премиум Постное Сбалансированное. ЗАДАЧА - При нажатии на них большая картинка с описанием должны меняться
        // на соответствующее нажатой кнопке. Эта верстка уже есть, но она закоментирована, что бы не было каши на странице
        // (если раскоментировать то они покажутся все сразу и будут пытаться встать на одно и тоже место).
        
        // Этот функционал напишем вместе, а домашнее задание будет - пройтись по коду строчка за строчкой и разобрать что мы делали.

        // В проекте можно решить задачу разными способами и чаще всего выбирают между более понятным и более простым в работе
        // (или по параметрам скорости и нагрузки на программу) поэтому не стоит пугаться если увидим что эта задача решена
        // не так как у нас, это просто другой метод.


    // Начнем с самого главного - назначим глобальный обработчик события DOMContentLoaded.
        // Алгоритм работы нашего кода поделим на три задачи: 1) ф-я которая будет скрывать ненужные в этот момент табы;
        // 2) показать нужный таб; 3) назначить обработчики событий на кнопки меню которые и будут манипулировать этими
        // ф-ями.

        // Кликаем на кнопках меню и видим что класс у них tabheader__item, получим их псевдомассив в tabs. Раскоментируем табы
        // (картинки и описание)и посмотрим что класс у них tabcontent, получим их псевдомассив в tabsContent. Далее получим
        // родителя кнопок меню в tabsParent что бы использовать на нем делегирование, так мы назначим 1 обработчик события 
        // вместо множества и если кнопки будут добавляться в верстку динамически, то на них тоже будет работать обработчик.
        
        // В верстке у первой кнопки видим еще 1 класс tabheader__item_active - этот класс выделяет на странице кнопку на которую 
        // кликнули так что его нужно будет добавлять к кнопке по которой кликнули и удалять из других кнопок.

        // 1) Напишем ф-ю для скрытия табов hideTabContent. Перебираем псевдомассив с табами tabsContent и задаем инлайн стиль
        // для их скрытия item.style.display = "none";. Также в этой ф-и переберем псевдомассив с кнопками tabs и удалим у них 
        // стиль активности tabheader__item_active.

        // 2) ф-я для показа нужного таба showTabContent. В ее аргумент записываем i для того что бы знать к какому эл. нужно
        // обратиться. Покажем нужный таб через инлайн стили tabsContent[i].style.display ="block"; и добавим класс активности
        // tabs[i].classList.add("tabheader__item_active");

        // Ф-и готовы теперь нужно что бы при загрузке страницы скрылись все табы и показался только один, по дефолту первый под
        // индексом 0 в псевдомассиве, для этого нужно ф-и запустить(вызвать) hideTabContent(); showTabContent(0); 
        // Рассмотрим параметры по умолчанию появившиеся в ES6 так можно в самой ф-и указать дефолтное значение параметра,
        // если вдруг ф-ю вызвали без аргумента. Переставим 0 из вызова ф-и в её объявление function showTabContent(i = 0).

        // 3) Навешиваем обработчик события на родителя кнопок что бы работало делегирование. Если мы знаем что часто будем
        // использовать event.target; - мы его присвоим переменной для сокращения записи и легкости чтения. Прописываем условие
        // используем classList.contains("tabheader__item") - что бы избежать вызова ф-и при клике на пустое пространство вокруг
        // кнопок, а это был бы родительский эл. Логика действий - при клике на элемент его таргет сравнивается с элементом
        // псевдомассива кнопок и таким образом мы узнаем индекс эл. в псевдомассиве, что бы запустить ф-ю показа таба с этим
        // индексом предварительно запустив ф-ю скрытия табов, сделаем это через перебор forEach и условие для сравнения. Все
        // работает.

        // В реальных проектах через инфайн стили почти не работают, в основном используют classList для css стилей, так для
        // стилей можно добавить еще и анимацю, что невозможно при работе с инлайн стилями. КСС файл у нас в сжатом виде,
        // можно или добавить в него наши ксс классы или создать новый ксс файл и подключить его дополнительно к основному.
        // Я допишу в обычный ксс файл после margin:0 auto} вставлю .show{display:block} - добавляет поведение дисплей блок при
        // котором блок будет показываться .hide{display:none} - скрывает блок
        //.fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;}to{opacity: 1;}} - прописываем
        // класс fade с названием анимации fade и длительностью 1.5 сек. Создаем анимацию через ключевое слово keyframes с именем
        // fade и она будет увеличивать ПРОЗРАЧНОСТЬ(opacity) от 10%(0.1) до 100%(1).
        
        // Теперь вместо инлайн стилей будем использовать классы.
        // Вместо display = "none" - нужно добавить две строчки, один класс добавить для скрытия всех эл. item.classList.add("hide");
        // и удалить класс показа item.classList.remove("show");. Использовать toggle тут мы не можем потому что начнется каша при
        // переключении.
        // Тоже самое нужно сделать в showTabContent тут мы добавляем класс classList.add("show") и удаляем класс скрытия
        // classList.remove("hide"); Теперь для показа анимации нужно добавить класс fade classList.add("show", "fade");
        // вместе с классом показа, а в ф-и скрытия fade нужно удалить для того что бы при следующем назначении этого класса
        // на этот элемент анимация снова воспроизводилась item.classList.remove("show", "fade");

        

        {// Код для скрипта
        "use strict";
        
        window.addEventListener("DOMContentLoaded", ()=>{
        
        //получаем элементы в переменные
        const tabs = document.querySelectorAll(".tabheader__item"), //<div class="tabheader__item">Премиум</div> кнопки
              tabsContent = document.querySelectorAll(".tabcontent"),// <div class="tabcontent">
                                                                            // <img src="img/tabs/vegy.jpg" alt="vegy">
                                                                            // <div class="tabcontent__descr">
                                                                                    //Меню "Фитнес" - ...
                                                                            // </div>
            // родительский эл. для назначение обр. событий кнопкам динамически
               tabsParent = document.querySelector(".tabheader__items");//<div class="tabheader__item tabheader__item_active">Фитнес</div>
    
        // 1) Скрываем ненужные табы
        function hideTabContent (){
            tabsContent.forEach(item => {    //перебираем элементы и назначаем всем стиль
                //item.style.display = "none";
                item.classList.add("hide");     // Делаем через классы из css теперь две строчки
                item.classList.remove("show", "fade");
            });
            tabs.forEach(item => {
                item.classList.remove("tabheader__item_active");//удаляем подсветку активности кнопок
            });
        }
         
        // 2) Показываем нужный таб
        function showTabContent(i = 0){     // i = 0 - если вызвать функцию без аргумента то 0 будет подставлятся по дефолту
            //tabsContent[i].style.display ="block";
            tabsContent[i].classList.add("show", "fade");   // Делаем через классы из css теперь две строчки
            tabsContent[i].classList.remove("hide");
            tabs[i].classList.add("tabheader__item_active");
        }
    
        // При загрузке вызываем ф-и
        hideTabContent(); //скрываем все табы
        showTabContent(); //показываем 1 таб по дефолту обычно первый под номером 0  showTabContent(0)
    
        // 3) Присваиваем обработчик события для кнопок делегированием от родителя
        tabsParent.addEventListener("click", (event)=>{
            const target = event.target; //переменная для уменьшения писанины если нужно часто обращатся к евент
    
            if(target && target.classList.contains("tabheader__item")){
                tabs.forEach((item, i) => {
                    if(target == item){
                        hideTabContent(); 
                        showTabContent(i);
                    }
                });
            }
        });
        //Добавили в css такой код .show{display:block}.hide{display:none}
        //.fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;}to{opacity: 1;}}
    
        });
        }

}



{//  304    ====    Время выполнения скриптов, setTimeout & setInterval    ====

    // Разберем тему - управление временем выполнения скриптов. Бывает что нужно чтобы ф-я выполнилась не сразу, а через какой то
        // промежуток времени или ее выполнение повторялось через какое то время. Научимся это делать и напишем благодаря этому
        // простую JS анимацию.

    // Работать будем с файлами в папке 304 индекс + ксс

    // Все мы сталкивались с навязчивыми модельными окнами которые появляются на сайте через какое то время. Такой ф-ционал очень
        // часто будет встречаться в нашей работе. Связано это может быть не только с модальными окнами. Поэтому нам нужно уметь
        // работать с таким асинхронным кодом.

    
    // +++ setTimeout - чтобы запустить ф-ю через определенный промежуток времени.
        // Создаем переменную (она не обязательна) и ей присвеиваем setTimeout(); 1 аргумент - объявление ф-и function или
        // ее название, она не вызывается прямо здесь и сейчас; 2 арг. - время через которое начнется выполнение ф-ии в мс.
        // Напишем пример с анонимной ф-й(без названия, она просто объявляется). 1000 мс = 1 секунда
        
        const timerId = setTimeout(function(){
            console.log("Hello");
        }, 1000);
        

        // Также в эту конструкцию можно передавать аргументы ф-и. "Hello2" - 3 арг. который по синтаксису перейдет в арг. ф-ии
        // text. Такой синтаксис используется не часто. Дополнительных аргументов может быть бесконечное количество.

        const timerId2 = setTimeout(function(text){
            console.log(text);
        }, 2000, "Hello2");


        // Помимо аргументов можем передавать готовую ф-ю. Только название без круглых скобок, передаем. а не вызываем.
        const timerId3 = setTimeout(logger, 3000);
        
        function logger(){
            console.log("text");
        }

    // *! Ф-и setTimeout и setInterval будут работать и без присвоения их переменной, например setTimeout(logger, 3000); сработает
        // точно также. Но когда мы выполняем присваивание в переменную ложиться числовое значение: console.log(timerId); // 1
        // а для console.log(timerId2); // 2 - таймеры нумеруются. И так как мы теперь к ним по именам переменных можем обратиться
        // то сможем их остановить при необходимости.
        //ПРИМЕР - представим ситуацию когда заходим на гипотетический сайт, где через 30 сек должно показаться модальное окно, 
        // но если мы кликнули на кнопку - купить товар или заказать услугу, то этот таймер должен остановиться(сброситься), потому
        // что мы уже сделали то что от нас хотел сайт(разработчик).

        // Выполняется такой сброс(остановки) командой clearInterval() - в которую передаем имя переменной с нужным таймером.
        const timerId3 = setTimeout(logger, 3000);
        
        clearInterval(timerId3);

        function logger(){
            console.log("text");
        }



        // Напишем более реальный пример когда остановка таймера будет происходить после клика по кнопке. 
        // Получаем эл. кнопки по классу btn = document.querySelector(".btn").
        // Навешиваем обработчик события клика мыши btn.addEventListener("click", и внутрь помещаем
        // *! setInterval - эта ф-я заставляет ф-ю вызываться через какой то промежуток времени, синтаксис
        // у нее такой же, аргументы такие же и отменяется также как setTimeout. 
        // Но для остановки таймера нужно что бы переменная с таймером была глобальная, поэтому объявим ее до обработчика события
        // через let потому что будем ее менять и без присвоения значения сразу, его присвоим в ф-и.

        // Теперь при клике на кнопку каждые (logger, 2000)  2 секунды будем видеть текст в консоли.
        // Что б его остановить пропишем clearInterval(timerId4); но он не сработает потому что ф-я с интервалом запустится только 
        // после клика на кнопку и до этого момента timerId4 будет равен undefined, но браузер прочитает код и после обработчика 
        // события сразу попробует вызвать clearInterval(timerId4); а с undefined он не сработает. Поэтому нужно модернизировать 
        // наш код. В function logger() будем отслеживать сколько раз уже повторился setInterval и будем это значение присваивать 
        // глобальной переменной let i = 0; с начальным значением 0. Для увеличения i поставим i++; в logger и сделаем условие
        // если ф-я сработала 3 раза if (i === 3), то запустить clearInterval(timerId4); функция отработает 4 раза.

        const btn = document.querySelector(".btn"); //<button class="btn">Animation</button>
        let timerId4;
        let i = 0;
        
        btn.addEventListener("click", () => {
            //clearInterval()
            timerId4 = setInterval(logger, 2000); //Присваиваем значение сетинтервала таймеру через 2 секунды
        });

        //clearInterval(timerId4); не сработает потому что значение ему присвоится после клика. А текущее undefined

        function logger(){
                if (i === 3){
                    clearInterval(timerId4);
                }
                console.log("text");    // text text text text - выведет 4 раза и остановится
                i++;
            }



    // На собеседовании может быть вопрос - чем рекурсивный setTimeout лучше чем рекурсивный setInterval. Рекурсия - когда ф-я 
        // внутри вызывает сама себя. Она используется довольно часто, мы ее применяли в предыдущем проекте. setTimeout может 
        // внутри себя вызвать setTimeout еще раз когда закончится внешний, запустится внутренний и тд.

        // А если рекурсивный будет setInterval то он не будет ждать пока ф-я выполниться что бы запустить следующий setInterval
        // Тоесть когда таймер setInterval работает он не учитывает то время которое будет отрабатывать ф-я внутри него.
      
        // Например при времени повторения ф-и logger в 0.5 секунды, если logger будет выполнять сложные вычисления которые
        // потребуют времени например в 3 секунды, то setInterval не буедет ждать потом 0.5 секунды, потому что он считал это 
        // время во время выполнения ф-и logger 3х секунд, и он тут же запустит снова ф-ю logger считая что 500 прошли во время 
        // выполнения функции.
                
        // решение такой проблемы - рекурсивный setTimeout - работает как setInterval но всегда ждет отведенное ему время.
        // Ф-и присваиваем имя log что бы можно было к ней обращаться и после выполнения console.log("text"); мы замещаем 
        // переменную id таким же setTimeout с ф-й log в которой после срабатывания кода снова будет происходить замещение
        // таймера id. Поэтому переменную объявляют через let чтобы можно было ее перезаписать.
            let id = setTimeout(function log(){
                console.log("text");
                id = setTimeout(log, 500);
            }, 500);



    // +++ Перейдем к практике.
        // Видим синий квадрат в левом верхнем углу большого белого квадрата с красной границей. ЗАЧАДА сделать так чтобы
        // синий квадрат плавно меремещался в правый нижний угол по нажатии на кнопку. Сделаем эту анимачию через setInterval
        // это устаревший метод, сейчас есть новые методики но мы увидим применение setInterval.

        // Получим кнопку. Создадим общую ф-ю для запуска всей анимации при клике на кнопку myAnimation. В ней получим эл. box
        // по классу, это наш синий квадрат. Создадим переменную для хранения позиции квадрата и присвоим ей начальное значение 0.
        // Для движения квадрата создадим ф-ю frame которая будет запускаться через определенное время в id = setInterval(frame, 10);
        // В frame прописывем условие, в нем мы определяем что анимация закончилась при значении (pos == 300) и останавливаем
        // интервал если позиция равна 300 - clearInterval(); - в него передаем переменную id которая отвечает за запуск интервала
        // в ф-ии myAnimation clearInterval(id);
        // В блоке else (то есть когда анимация еще не закончена или начинается) будем выполнять pos++; - увеличение позиции на 1.
        // И для движения квадрата нужно ему через инлайн стили присваивать новую позицию. Так как квадрат у нас будет двигаться
        // по диагонали значит и отступ от верхнего и от левого края будет увеличиваться одинаково, поэтому присваиваем позицию
        // этим двум свойствам elem.style.top = pos + "px"; elem.style.left = pos + "px"; Так как в ксс прописана позиция квадрата
        // position: absolute; относительно родителя (белого квадрата position: relative;) то он и будет двигаться внутри белого
        // квадрата. (pos == 300) - высчитывается из размеров квадрата и родительского блока(белого квадрата), у синего размеры
        // width: 100px; height: 100px; размер 100 на 100, а размер родителя width: 400px; height: 400px; 400 на 400, поэтому 
        // сместить нужно на разницу между 400 - 100 пкс = 300 пкс. 
        
        // Теперь эту ф-ю будет вызывать id = setInterval(frame, 10); - можно поставить и меньше 10 мс, но что бы нормально
        // отрабатывал setInterval без багов, сама ф-я setInterval будет подставлять 4 мс - этот стандарт поддерживается всеми
        // браузерами.
        

        const btn = document.querySelector(".btn"); //получаем кнопку
        
        function myAnimation(){
            const elem = document.querySelector(".box"); //получаем элемент - синий квадрат <div class="box"></div>
            let pos = 0; //переменная позиции(устанавливаем начальную позицию)
        
            const id = setInterval(frame, 10);

            function frame() { // ф-я будет запускаться через определенный промежуток времени.
                if (pos == 300){ // .box { position: absolute; width: 100px; height: 100px; размер 100 на 100, размер обертки
                    //wrapper { position: relative; width: 400px; height: 400px; 400 на 400 чистой площади получается 300px
                    clearInterval(id);
                } else{
                    pos++;
                    elem.style.top = pos + "px";
                    elem.style.left = pos + "px";
                }
            }
        
        }
        
        btn.addEventListener("click", myAnimation);

    // Если много раз клацать на кнопку то квадратик будет дергаться, это потому что мы написали простейшую анимацию, более 
        // сложные анимации напишем дальше в курсе. А с появлением ксс3 в нем появились анимации которые удобнее прописать 
        // в ксс и чаще всего их и проиписывают в ксс, подвязываются к классам, а мы при помощи JS скриптов меняем эти классы
        // для нужных элементов как делали для табов с классом fade.

    

    {// Код для скрипта
        "use strict";

        // const timerId = setTimeout(function(){
        //     console.log("Hello");
        // }, 1000);
        
        // const timerId2 = setTimeout(function(text){
        //     console.log(text);
        // }, 2000, "Hello2");
        
        // const timerId3 = setTimeout(logger, 3000);
        // function logger(){
        //     console.log("text");
        // }
        

        // const btn = document.querySelector(".btn"); //<button class="btn">Animation</button>
        // let timerId4;
        // let i = 0;
        
        // btn.addEventListener("click", () => {
        //     //clearInterval()
        //     timerId4 = setInterval(logger, 500); //Присваиваем значение сетинтервала таймеру через 0,5 секунды
        // });
        // //clearInterval(timerId4) не сработает потому что значение ему присвоится после клика. А текущее undefined
        // //изменяем logger
        // function logger(){
        //         if (i === 3){
        //             clearInterval(timerId4);
        //         }
        //         console.log("text");
        //         i++;
        //     }

        
        const btn = document.querySelector(".btn"); //<button class="btn">Animation</button>
        
        function myAnimation(){
            const elem = document.querySelector(".box"); //получаем элемент - квадрат <div class="box"></div>
            let pos = 0; //переменная позиции
        
            const id = setInterval(frame, 10);
            function frame() {
                if (pos == 300){ // .box { position: absolute; width: 100px; height: 100px; размер 100 на 100, размер обертки
                    //wrapper { position: relative; width: 400px; height: 400px; 400 на 400 чистой площади получается 300px
                    clearInterval(id);
                } else{
                    pos++;
                    elem.style.top = pos + "px";
                    elem.style.left = pos + "px";
                }
            }
        
        }
        
        btn.addEventListener("click", myAnimation);
    }

}



{//  305    ====    Date    ====

    // Работа с объектом Даты обязательный навык потому что он может часто пригодиться. Например для измерения времени работы
        // ф-ии, если мы хотим засечь как быстро она работает и сравнить другой ф-ей. Таже можно использовать для таймера или
        // вывода текущей даты/часов на странице. Еще можно использовать для хранения времени создания какого то документа(это
        // уже больше Node.js, потому что наш нативный JS не умеет работать с файлами). В следующем уроке создадим на странице
        // таймер который будет работать на основе Date.


    // Создадим переменную и присвоим ей объект даты. Для этого воспользуемся конструктором new Date(); - при пустых скобках ()
        // будет показана текущая дата и время которая берется из системы. Показывается до милисекунд(у преподавателя показало
        // 2020-05-01Т11:09.26.7452) - он запускал в VSCode(в консоли или другого инструмента Дата может вернуться в формате
        // UTC) Сначала идет год-месяц-число, Т -разделитель и потом временные рамки.
        // Дата хранится в милисекундах и отсчитывается от 1970 года(тайм стемп). Это значит что дата может быть переведена в 
        // милисекунды, а милисекунды в дату.
        
        const now = new Date();
        console.log(now); // Wed Jun 29 2022 13:44:18 GMT+0300 (Восточная Европа, летнее время)



    // +++ При СОЗДАНИИ Даты мы можем передавать в нее аргументы. Например можно передать дату в виде СТРОКИ, это часто используется
        // если на странице есть input с типом даты type="date" он нам отдает дату которую мы можем передать в конструктор.
        // Передадим дату, видим что показывает нужную дату с нулем часов, потому что часы мы не передали.
        
        const now = new Date("2020.1.8");
        Date.parse("2020.1.8"); //работает идентично const now = new Date("2020.1.8");   *! но в милисекундах.
        const now = new Date("Wed Jun 29 2022");
        console.log(now); // Wed Jun 29 2022 00:00:00 GMT+0300 (Восточная Европа, летнее время)
        

        // Если передать таким образом(числа без нулей 01 -> 1), то получим 20 часов 1 число и 6 месяц, потому что месяц в Дате
        // считается с 0.
        const now = new Date(2020, 1, 8, 18); //18 часов, месяц и день указываем без 0.
        const now = new Date(2020, 5, 1, 20); // Mon Jun 01 2020 20:00:00 GMT+0300 (Восточная Европа, летнее время)


        //Часы могут показывать по гринвичу, а месяцы считаются с 0, 0-январь
        const now = new Date(0);//Дата (Тайм стемп) хранится в милисекундах. отсчет с начала 1970 года


        // Получить дату до 1970 года можно введя отрицательное значение
        const now = new Date(-999999999990) // Mon Apr 25 1938 01:13:20 GMT+0300 (Восточная Европа, летнее время)



    // +++ МЕТОДЫ ДАТЫ
        // Разберем основные(частоиспользуемые) методы
        const now = new Date();

        
        // *** ПОЛУЧЕНИЕ компонентов Даты(интересующего компонента)

        // Получение года. Всегда приходит число из 4х знаков. При передаче также это стоит помнить.
        console.log(now.getFullYear()); // 2022 

        console.log(now.getMonth());    // месяц считаются с 0, 0-январь
        console.log(now.getDate());     //число месяца
        console.log(now.getHours());    //часы
        console.log(now.getMinutes());  // минуты
        console.log(now.getDay());      // номер дня в неделе, воскресение - 0, понедельник - 1
       
        //Все эти значения возвращаются по местному часовому поясу, но если нужен другой часовой пояс по UTC - +0 часов, у всех
        // методов выше есть аналоги с добавлением слова UTC
        console.log(now.getHours());    // 14 часов (+3) - по местному
        console.log(now.getUTCHours()); // 11 часов (+0) - по Гринвичу


        // Получение разницы в минутах между UTC и местным  час.поясом в минутах
        console.log(now.getTimezoneOffset());   // -180


        // Возвращает количество милисекунд прошедших с начала 1970 года до сейчас. Его обратно можно превратить в дату 
        // поместив  в - const now = new Date(1656502672991); Этот метод часто используется.
        console.log(now.getTime());     // 1656502672991            



    // *** УСТАНОВКА  Даты
        // Тут используются все команды для получения даты только с приставкой set вместо get, кроме команды getTimezoneOffset.

        // Установим часы равные 18-00. После вывода в консоль показывается 18 вместо текущего времени.
        const now = new Date();  
        console.log(now);                   // Wed Jun 29 2022 14:43:08 GMT+0300 (Восточная Европа, летнее время)
        console.log(now.setHours(18));      // 1656517388749
        console.log(now);                   // Wed Jun 29 2022 18:43:08 GMT+0300 (Восточная Европа, летнее время)

        // Можно сразу передавать и другие компоненты, например передадим часы и минуты - но такой способ неочевиден, потому что
        // программист увидев setHours предположит что передаются только часы, поэтому так делать не всегда является хорошей
        // практикой.
        console.log(now.setHours(18, 40));  // Wed Jun 29 2022 18:40:22 GMT+0300 (Восточная Европа, летнее время)

        // При работе с датой у нее есть автоисправление, например если передать 40 часов из 24х суточных, то мы просто получим
        // дату через 40 часов, то есть 40 прибавится к текущим часам и получим следующий день и оставшееся количество часов как
        // если бы мы прибавляли к 24м.
        console.log(now.setHours(40));      // Thu Jun 30 2022 16:52:46 GMT+0300 (Восточная Европа, летнее время)



    // +++ ИЗМЕРЕНИЕ ПРОМЕЖУТКОВ ВРЕМЕНИ с помощью Даты.

        // Для этого нам не нужно отнимать Thu Jun 30 2022 16:52:46 GMT+0300 такие сложные синтаксисы друг от друга, да и мы 
        // все равно бы получили ошибку. Для этого у еас есть милисекунды внутри. Эти таймстемпы можем использовать напрямую, а
        // можем использовать динамическое преобразование поставив + перед объектом даты.

        // Пример - создадим переменную через let потому что она будет изменяться, и сделаем цикл что бы он хорошо нагрузил нашу
        // систему. Теперь создаем переменную end для того что бы засечь конец работы цикла. Так как end создаст дату когда
        // до нее дойдет очередь, тоесть после выполнения цикла, то и даты end и start будут разные, и отняв их друг от друга
        // можно увидеть сколько милисекунд выполнялся цикл. Такие операции еще называются бенчмарки, когда мы проверям
        // производительность скрипта(операции, ф-и, цикла). Они могут выглядеть сложнее но база должна выглядеть так начальное
        // время, время окончания и их разница.
        let start = new Date();
        
        for (let i = 0; i < 100000; i++){
            let some = i ** 3; // i возводим в степень 3
        }
        
        let end = new Date();
        alert(`Цикл выполнился за ${end - start} миллисекунд`);
        


    {// Код для скрипта
        "use strict";

        //const now = new Date();
        //const now = new Date("2020.1.8");
        //new Date.parse("2020.1.8"); //работает идентично const now = new Date("2020.1.8");
        //const now = new Date(2020, 1, 8, 18); //18 часов, месяц и день указываем без 0. 
        //Часы могут показывать по гринвичу, а месяцы считаются с 0, 0-январь
        //const now = new Date(0);//Дата (Тайм стемп) хранится в милисекундах. отсчет с начала 1970 года
        
        const now = new Date();
        // console.log(now.getFullYear()); //2022 год
        // console.log(now.getMonth()); // месяц считаются с 0, 0-январь
        // console.log(now.getDate()); //число
        // console.log(now.getHours());//часы
        // console.log(now.getMinutes());
        // console.log(now.getDay()); // номер дня в неделе, воскресение - 0, понедельник - 1
        // //Все значения по местному часовому поясу
        // console.log(now.getUTCHours()); // часовой пояс +0
        
        // console.log(now.getTimezoneOffset()); //разница в минутах между основным час.пояс. и местным
        // console.log(now.getTime()); //количество милисекунд с начала 1970 года
        
        //Для установки даты используем теже методы но с set
        //console.log(now.setHours(18)); // устанавливаем это время для переменной
        //console.log(now.setHours(40));//автоисправление
        //console.log(now);
        
        //Для измерения промежутков времени используем бенчмарк
        let start = new Date();
        
        for (let i = 0; i < 100000; i++){
            let some = i ** 3; // i возводим в степень 3
        }
        
        let end = new Date();
        alert(`Цикл выполнился за ${end - start} миллисекунд`);
    }   

}



{//  306    ====    Timer обратного отсчета    ====

    // Будем реализовывать таймер обратного отсчет внизу страницы в проекте Project_food в папке 303. В блоке - "Осталось до конца
        // акции" - есть заготовка таймера с отсчетом дни-часы-минуты-секунды.

        // В верстке есть блок таймер в котором есть миниблоки с дни-часы-минуты-секунды а в них есть span с уникальными id,
        // в них мы и будем подставлять значения секунд, минут, часов, дней.
        // <div class="timer">
        //    <div class="timer__block">
        //       <span id="days">12</span>


    // Алгоритм действий. 1) Нужна ф-я для установки таймера, получения элементов; 2) ф-я определяющая разницу между временем
        // которая установлена у пользователя и временем дедлайна(окончания таймера); 3) ф-я которая будет обновлять таймер
        // (данные на странице) для показа пользователю.

    // Таймер частое решение для сайтов. Есть честные таймеры которые отсчитавают реальное время. А есть таймеры на продажу,
        // они запоминают нас как пользователя при заходе на страницу и отсчитывают время ориентируясь только на нас. Наш 
        // таймер будет подходить под оба варианта, разница будет в начальной инициализации таймера.



    // Создадим переменную с датой отсчета const deadLine до какого времени будем считать.

    // Создаем ф-ю 2) (определяющая разницу между временем) getTimeRemaining принимать аргументом будет endtime - из переменной 
        //deadLine. создаем техническую переменную t поэтому возьмем простое имя, потому что будет существовать только в этой ф-и.
        // deadLine задали строкой "2022-07-20" - для того что бы рассмотреть как работать с таким типом данных, потому что он
        // может приходить из inputa с типом даты на странице(административной панели). От такой строки мы не можем отнять 
        // милисекунды, потому что будет ошибка. Для математических действий эту строку сначала нужно тоже превратить в милисек.
        // Date.parse(endtime) - методом парсинга, создаем текущую дату в млсек.  Date.parse(new Date()) и отнимаем от конечной.
        // Теперь в t будет разница в млсек. и ее нам нужно превратить в количество дни-часы-минуты-секунды. Для этого создаем
        // переменные под каждую категорию, 
        
        // Считаем дни days - нужно просто разделить t на количество млсек. в одном дне, и округлить до меньшего целого,
        // чтобы не получить дробные значения.  t делим на ( 1(1000) сек*60 в минуте*60 в часе*24 часов в дне).
        
        // Часы hours тоже округляем, получаем количество часов таким же делением t на милисекунды в одном часе и получим все 
        // часы, но все часы по 24 часа в день перешли в дни и нам нужно получить остаток часов который останется от дней,
        // его мы можем получить чере остаок от деления на 24 часа (% 24).
        // Этот хвостик часов будет не больше чем 24 часа из-за этой операции (автоматическая конвертация неполного дня).
        
        // Таким же спомобом получам и минуты minutes, получаем количество минут до заданой даты, теперь рассмотрим еще одну
        // запись вместо умножения всех элементов, а потом деления t на этот результат (t / (1000*60*60) можно было записывать
        // (t / 1000 / 60 / 60), эта запись аналогична, мы t делим сразу на сек, потом на минуты, потом на часы. Запишем именно
        // для минут ((t / 1000 / 60) % 60) - милисек делим на 1000 получаем секунды, и делим на 60 сек в минуте - получаем
        // минуты(так избавляемся от одних скобок, но если кто то будет читать наш код, то сразу логику будет проследить труднее),
        // теперь нужно брать остаок от деления на 60 минут в часе, получаем остаток минут которые не вошли в целые часы.

        // Секунды рассчитваем также, просто делим t на 1000 млсек и получаем секунды + берем остаток от деления на 60 сек в мин.

        // Мы получили переменные со значениями которые будут рассчитаны как оставшееся время таймера. Но они локальные и нам их
        // нужно вернуть из ф-и чтобы мы могли их поместить на страницу. Чтобы компактно вернуть эти переменные из ф-ии вернем их
        // объектом. В нем возвращаем и переменную t потому что она нам будет нужна чтобы следить когда остановить таймер, если
        // заданая дата и время прошло то разница дат в переменной t будет отрицательной(минусовой).


    // Создаем ф-ю setClock(selector, endtime) для 3) для установки нашего таймера на страницу(показа пользователю). В ней нам 
        // понадобится получить эл. на странице куда мы будем передавать значения таймера(selector) и наша дата окончания 
        // таймера (endtime). Создадим переменную для получения в нее главного (родительского) эл. со страницы, что бы потом
        // от него взять следующие вложенные(дочерние) эл. и меньше при этом писать timer = document.querySelector(selector)
        // передаем аргумент selector вместо конкретного класса ".timer" что бы потом иметь возможность прикрутить этот таймер
        // к другому элементу или использовать в другом проекте.
        // Теперь от этого родительского эл. получаем эл. для каждого значения по айди days = timer.querySelector("#days")
        // который присвоены нужным элементам.

        // Теперь прямо в этой же ф-ии создаем ф-ю для обновления значений каждую секунду updateClock. Создадим переменную
        // t для расчета времени прямо в эту секунду воспользуемся ф-й getTimeRemaining   const t = getTimeRemaining(endtime); 
        // в эту переменную придет объект с расчитанными данными на текущую секунду. Теперь поместим эти данные на страницу
        // через innerHTML(можно и через textContent) будем конкретному элементу полученному ранее присваивать значение из
        // одноименного свойства полученного в t объекта - days.innerHTML = t.days;. Теперь когда ф-я запустится она рассчитает
        // значения на текущую секунду и поместит их на страницу. Теперь для ежесекундного просчета в ф-и setClock сделаем
        // переменную timeInterval и в нее назначим таймер для вызова ф-и просчета каждую секунду updateClock
        // timeInterval = setInterval(updateClock, 1000). А в updateClock добавим условие для остановки таймера если
        // дата уже прошла if(t.total <=0){.


    // Проверим таймер запустив его и передав как селектор получение эл. по классу таймер - setClock(".timer", deadLine);
        // Вылезло 2 бага  1) - если часов и минут меньше 10 то частое требование что нужно подставлять 0 (09), 
        // 2) - при обновлении страницы таймер запускается только через секунду и мы видим таймер из верстки. Будем решать
        // эти задачи.


    // Решим второй баг. Почеиу так происходит - ф-я setClock запускается, создает переменные с данными и запускает setInterval
        // а он первый раз отработает только через секунду, поэтому видим значения из верстки в эту секунду простоя. Поэтому
        // что бы не ждать эту секунду мы запустим ф-ю updateClock(); первый раз вручную.

    // Задача с подставлением нуля сложнее. Посмотрим на строчки где мы устанавливаем цифры на страницу days.innerHTML = t.days;
        // на этом этапы мы можем проверить это число, проверить на значение(или увидеть сколько в нем символов) и если оно
        // будет меньше 10, то будем добавлять 0. Для этого напишем ф-ю помошник которая будет делать такое сравнение getZero.
        // Она будет принимать в себя число getZero(num) и сравнивать его через условие if (num >=0 && num <10), в нем мы 
        // проверяем что число плюсовое num >=0(мало ли какое число нам пришло) и при этом если оно меньше 10 будем подствалять
        // 0 через интерполяцию return `0${num}` -обратные бектики и возвращаем уже получается строку, но в данном случае нам это
        // не важно, потому что мы ее сразу показываем на странице, и она будет отображаться также как и число. А если число больше
        // 10 тогда просто его же и возвращаем return num;. Теперь что бы все это у нас работало при присвоении значения переменной
        // с элементом мы сделаем эту проверку подставя нашу ф-ю  -  days.innerHTML = getZero(t.days);



    {// Код скрипта
    "use strict";
    const deadLine = "2022-07-20"; //Строкой задаем время окончания, такие строки получают еще из инпута на сайтах
    
    
    function getTimeRemaining(endtime){
        const t = Date.parse(endtime) - Date.parse(new Date()), //Превращает строку в количество милисекунд для математических расчетов
        //Отнимаем текущую дату и получим число в милисекундах
              days = Math.floor(t / (1000*60*60*24)),//Переводим в дни, милисек делим на 1(1000) сек*60 в минуте*60 в часе*24 часов в дне
              //и Math.floor округляет это число до меньшего целого
              hours = Math.floor((t / (1000*60*60) % 24)),//Переводим в часы, и получаем остаток от деления на 24 часа, что бы не было
              //например 150 часов
              minutes = Math.floor((t / 1000 / 60) % 60),
              seconds = Math.floor((t / 1000) % 60);
              //Для возврата этих локальных переменных из фунции используем ретурн и выводим объектом
              return{
                "total": t,
                "days": days,
                "hours": hours,
                "minutes": minutes,
                "seconds": seconds
              };
    }
    
    //Функция помощник для подставления 0 если число часов/минут меньше 10
    function getZero(num) {
        if (num >= 0 && num < 10){
            return `0${num}`;
        }else{
            return num;
        }
    }
    
    //функция Устанавливает время на страницу
    function setClock(selector, endtime){
        //получаем элементы со страницы
        const timer = document.querySelector(selector),
              days = timer.querySelector("#days"), //<span id="days">12</span>
              hours = timer.querySelector("#hours"),
              minutes = timer.querySelector("#minutes"),
              seconds = timer.querySelector("#seconds"),
              timeInterval = setInterval(updateClock, 1000); //запускаем функцию каждую секунду
        
        updateClock(); //Запускаем вручную что бы пофиксить второй баг
        
        function updateClock () {  //функция обновления таймера
            const t = getTimeRemaining(endtime); //в переменную получаем объект из функции с расчетами на эту секунду  
    
            days.innerHTML = getZero(t.days);
            hours.innerHTML = getZero(t.hours);
            minutes.innerHTML = getZero(t.minutes);
            seconds.innerHTML = getZero(t.seconds);
    
            //Останавливаем таймер если время вышло
            if(t.total <= 0){
                clearInterval(timeInterval);
            }
        }
    }
    
    setClock(".timer", deadLine); //Запускаем таймер в селектор подставляем класс элемента в ендтайм дату которую задаем 
                                    // или откуда то получаем (панель управления, сервер)
    
                /* <div class="timer">
                        <div class="timer__block">
                            <span id="days">12</span>
                            дней
                        </div>
                        <div class="timer__block">
                            <span id="hours">20</span>
                            часов
                        </div>
                        <div class="timer__block">
                            <span id="minutes">56</span>
                            минут
                        </div>
                        <div class="timer__block">
                            <span id="seconds">20</span> */
    
    //Два бага нужно исправить 1) - если часов и минут меньше 10 то нужно подставлять 0 (09), 2) - при обновлении страницы таймер
    //запускается только через секунду и мы видим таймер из верстки
    }   

}



{//  307    ====    Параметры документа, окна (document/window/screen)    ====

    // Поговорим о браузере. Какие глобальные сущности в нем есть и как с ними работать.
   
    // В задании работаем с шаблоном в папке 307. 
    


    // +++ Существует несколько основных понятий в работе JS относительно человека.
        
    // *** DOCUMENT. С понятием document мы уже знакомы, мы уже получали из него эл. и мы поняли что по факту это объект который 
        // содержит всю ХТМЛ структуру(только в более сложном чем верстка варианте).


    // *** WINDOW. По факту - наше окно(браузера) в котором показывается документ. Если мы будем увеличивать консоль разработчика 
        // то у нас изменяется именно window (высота окошка через которое видим контент), а document не затрагивается. Тоже 
        // самое будет если изменять ширину браузера, виндоу меняется, а элемент по центру с текстом (document) не изменяется.


    // *** SCREEN. Используется на практике редко. Весь наш видимый МОНИТОР с системными панельками и остальным. Разный размер
        // монитора - разный скрин.


    // В консоли браузера можно посмотреть что содержит тот или иной элемент. Откроем например document, раскроем его и увидим
        // все теги которые есть в большой ХТМЛ коллекции All(пседомассив со всеми эл). В скрине и виндоу будут другие свойства.
        // Например window мы использовали когда навешивали на него обраб. соб. DOMContentLoaded.
        console.dir(document);

        

    // Перейдем к более конкретным эл. у которых есть свои значения которые нам нужно изучить. Посмотрим на картинку прикрепленную
        // к уроку и видим 8 свойств у кведрата с текстом(таким же как у нас в шиблоне), на практике не все из них часто
        // применяются. Рассмотрим наиболее частоприменяемые. Все они измеряются в пикселях, но в коде JS они пишутся без
        // единиц измерения.


    // *** clientWidth(ширина) и clientHeight(высота) эл + padding - (без border, margin, scroll(полоса прокрутки)). Потренируемся
        // на практике. Получим эл в переменную box. Получим ширину и высоту эл без марджинов width и height, в консоль
        // получили  405, 355. Смотрим в ксс файл там ширина 400 + 2 паддинга по 10 пкс. = 420 пкс. но так как есть еще
        // боковой скрол то он занимает 15 пкс, итого 420 - 15 = 405 пкс. С высотой также 350 + 20 - 15 = 355 пкс.

        const box = document.querySelector(".box");
        
        const width = box.clientWidth;      //в css width: 400px + 2 шт padding: 10px с боков - 15px скролл = 405
        const height = box.clientHeight;    // height: 350px;
    
        console.log(width, height);         //405, 355 
    
        //Если в css используется box-sizing: border-box; включает padding в середину box в ширину и высоту эл. Теперь
        // общая ширина будет не 420, а 400 и отняв 15 пкс. полосы прокрутки получим = 385 пкс. В реальных проектах обычно
        // это свойство используется.
        console.log(width, height);         //385, 335 
    
        // Главный вопрос зачем нам получать эту ширину и высоту. В ксс могут использоваться разные параметры(%, vh, vw)
        // тоесть относительные величины которые ориентируются на монитор пользователя, в таком случае мы не можем получить
        // определенное число пикселей прямо из стилей и нам нужно получать их из уже построенного элемента. Таким образом
        // мы можем например увеличить высоту эл в два раза для добавления нового контента, все будет зависеть от нашей задачи.


    // *** offsetWidth и offsetHeight эл.  + padding + border + margin + scroll. Получаем те свойства которые и были установлены в
        // ксс файле. Но если посмотреть на высоту то скролом можно прокрутить контент и реальная высота контента будет больше,
        // а это получается видимая в данный момент высота.
        
        const owidth = box.offsetWidth; //свойство из css width: 400px 
        let oheight = box.offsetHeight;
        console.log(owidth, oheight); //400, 350
    

    // *** scrollWidth и scrollHeight. Получаем всю ширину или высоту объекта(даже не видимую в данный момент), на которую можно 
        //прокрутить скролом. Обычно используют высоту, потому что редко какой сайт скролится в ширину(горизонтально).
        
        const swidth = box.scrollWidth; // размер - скролл
        let sheight = box.scrollHeight; // размер всего текста(который можно скролить в этом окне)
        console.log(swidth, sheight); //385, 1352 

        // Теперь мы можем реализовать такую задачу - при клике на кнопку под эл. он полностью раскрывается на всю высоту контента
        // (показывает всю скрытую часть текста). Для этого получим эл. кнопки и повесим на нее обр. соб. при клике будем 
        // модифицировать box. Обратимся к его инлайн стилю и в него запишем число полученное из эл. + "px" что бы оно сработало.
        
        // *** Часто при этом используются свойства scrollTop или scrollLeft - эти значения помогут нам узнать сколько есть
        // пролистанного контента который уже не показывается(невидим), благодаря этим свойствам можно делать различный
        // интерактив при прокрутке страницы, например показывать прогресс, сколько пользователь пролистал нашей страницы.
        // *! все предыдущие свойства мы могли только получать из эл. а scrollTop или scrollLeft мы можем задать.
        
        let btn = document.querySelector("button");
        btn.addEventListener("click", () => {
            box.style.height = box.scrollHeight + "px"; //показываем весь текст
            box.style.width = 800 + "px";
            console.log(box.scrollTop); //показывает сколько проскроллил пользователь текста( отстчет над скролом) в пикселях
        });                             // по нажатию на кнопку.
    

    // +++ КООРДИНАТЫ
    // Часто на практике нам нужно получать координаты эл. на странице, потому что в JS они рассчитаваются не так как в ксс, а от 
        // левого верхнего угла экрана. Метод получающий объект эл. с координатами, причем некоторые браузеры могут добавлять
        // какие-то параметры, например  x: 440 y: 50.

        console.log(box.getBoundingClientRect()); // bottom: 400 height: 350 left: 440 right: 840 top: 50 width: 400 x: 440 y: 50
        
        // При этом в JS расчет идет от левого верхнего угла а в css от границы, например: css right отсчитывался бы от правой 
        // границы окна до правой границы элем., а в JS right отсчитывается от левой границы окна до правой границы элемента
        // bottom css - от низа окна до элем, а в JS от верхней окна до нижней элемента bottom: 400 = высота 350 + margin-top: 50px;
        
        // Так как мы получаем объект, то можно обратиться к конкретному его свойству
        console.log(box.getBoundingClientRect().top); //значение top - 50
    

    // +++ СТИЛИ
    // Иногда нужно получить стили которые применены к этому эл. Например для работы нашего скрипта нам нужно знать показан эл.
        // в данный момент на странице или нет, какой у него указан display в ксс и уже на основании этого при помощи условия
        // сформировать нашу структуру. 
        // Метод опеределяет какие стили css были применены(расчитаны/computed) на элем. изначально до применения скрипта.
        // Например  display. *! ИХ можно только получить это значени но не изменить его в css, изменяем стили только инлайн
        // которые в верстке, перебивая css. getComputedStyle - стили которые уже применены к элементу, в них разные параметры
        // например ширины или высоты могут не совпадать с теми что заданы в ксс файле ( потому что в ксс могли быть заданы в 
        // % или vh, или margin: auto; , а тут они будут с конкретным значением в пикселях). 
        // Их можно посмотреть в панели разраб. вкладка Elements выбрать элемента и смотреть справа  вкладку Computed.
        
        const style = window.getComputedStyle(box); // получаем объект из элемента 

        // Можно также обратиться к конкретном свойству
        console.log(style.display); // block
        
        // *! При помощи этого метода мы можем получить стили псевдоэл. В JS мы не можем работать с псевдоэл. потому что мы никак
        // не можем их получить со страницы(это прописано в стандарте, на момент записи урока у нас нет возможности просто так
        // работать с псевдоэл.), но стили псевдоэл. мы получить можем. Для этого нужно указать псевдоэл. вторым аргументом.
        // Например если бы у box был псведоэл, мы бы его указали вторым аргументом и получили бы его стили.
        const style = window.getComputedStyle(box, псевдоэл.);


        // Некоторые путают Computed стили с инлайн стилями. Computed - идут из ксс и будут на странице изначально, а то что мы
        // задаем через .style. это уже инлайн стили, они появляются внутри верстки и прописываются прямо в тег. По правилам
        // версти инлайн стили имеют самый большой приоритет по сравнению с другими стилями, поэтому когда мы задаем инлайн стиль
        // мы всегда перебиваем стиль который есть в ксс. Инлайн мы помеж получить, изменить, удалить, а Computed только получить
        // и проверить в каком-то условии.



    // МЕТРИКИ DOCUMENT и WINDOW
    // У document нету свойства scrollTop, поэтому мы не можем обратиться document.scrollTop для понимания сколько страницы было 
        // пролистано. Для обращения к свойству scrollTop в document нужно обращатся к его елементу.

        console.log(document.documentElement.scrollTop);
        console.log(document.documentElement.clientWidth);
        
        // scrollTop/csrollLeft можно изменять ВРУЧНУЮ в консоли а другие нельзя, таким образом можно сделать стрелочку для 
        // быстрого перехода. !* Указывается в пикселях.
        document.documentElement.scrollTop = 0; // закинет на начало страницы


        //  Методы window которые занимаются модифицированием положения страницы.
        // Аргументы (х, у). Х - по горизонтали, У - положение по вертикали.

        window.scrollBy(0, 400) // скролит на 400 относительно текущей позиции 

        window.scrollTo(0, 400) // скролит на 400 относительно всей страницы.

}



{//  308    ====    Создание модального окна    ====

    "use strict";
    //По нажатии двух разных кнопок будет выскакивать пока еще скрытое модальное окно <div class="modal">
    //Кнопки с разными аттрибутами и поэтому мы их бъеденим одним дата аттрибутом data-modal, допишем в верстку этот селектор
    //<button data-modal class="btn btn_dark">Связаться с нами</button> для закрытия этого окна прописываем 
    //в закрывающем элементе data-close  <div data-close class="modal__close">&times;</div>  - это крестик
    const modal = document.querySelector(".modal"),
          modalTrigger = document.querySelectorAll("[data-modal]"), //квадратные скобки что бы обратится к аттрибуту
          modalCloseBtn = document.querySelector("[data-close]");
    //Проверяем функционал выбирая только первую кнопку modalTrigger = document.querySelector("[data-modal]"),
    //добавляем и убираем стили которые раньше прописали в css .show{display:block}.hide{display:none}
    //.fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;}to{opacity: 1;}}     
    
    // modalTrigger.addEventListener("click", ()=>{
    //     modal.classList.add("show");
    //     modal.classList.remove("hide");
    //     document.body.style.overflow = "hidden";
    // });
    
    // modalCloseBtn.addEventListener("click", ()=>{
    //     modal.classList.add("hide");
    //     modal.classList.remove("show");
    //     document.body.style.overflow = ""; //оставляем пустые скобки и браузер сам возвращает дефолт для прокрутки страницы
    // });
    
    //Страницу можно пролистывать не закрывая окно, многим заказчикам это не нужно. Нужно зафиксировать страницу скрывая скролл
    // document.body.style.overflow = "hidden";
    
    //Делаем через toggle контролируя свойство display через стиль show
    // modalTrigger.addEventListener("click", ()=>{
    //     modal.classList.toggle("show"); //если класса нет - добавит, если есть уберет
    //     document.body.style.overflow = "hidden";
    // });
    
    // modalCloseBtn.addEventListener("click", ()=>{
    //     modal.classList.toggle("show");
    //     document.body.style.overflow = ""; //оставляем пустые скобки и браузер сам возвращает дефолт для прокрутки страницы
    // });
    
    //Создаем функцию для перебора кнопок при querySelectorAll
    modalTrigger.forEach(btn =>{
        btn.addEventListener("click", ()=>{
            modal.classList.add("show");
            modal.classList.remove("hide");
            document.body.style.overflow = "hidden";
        });
    });
    
    // modalCloseBtn.addEventListener("click", ()=>{
    //     modal.classList.add("hide");
    //     modal.classList.remove("show");
    //     document.body.style.overflow = ""; 
    // });
    
    //реализуем закрытие окна по клику на подложку(темную часть) и по кнопке Esc клавиатуры
    //<div class="modal"> - подложка (обертка) (темная)
    //   <div class="modal__dialog"> - область окна (светлая) - вложена в подложку(обертку)
    //єл. подложки в переменной modal
    // modal.addEventListener("click", (e)=>{
    //     if(e.target === modal){    //проверяем строгое равенство объекта по которому кликнули объекту modal
    //         modal.classList.add("hide");
    //         modal.classList.remove("show");
    //         document.body.style.overflow = ""; 
    //     }
    // });
    
    //Можно встретить такой код, но это НЕ везде будет работать, строго привязываемся к названию event, нарушаем логику кода
    //нужно четко говорить что (e) мы используем
    // modal.addEventListener("click", ()=>{
    //     if(event.target === modal){
    
    //Правило Don't Repeat yourself (DRY) если код повторяется нужно его вынести в одну функцию
    function closeModal(){
        modal.classList.add("hide");
        modal.classList.remove("show");
        document.body.style.overflow = ""; 
    }
    
    modalCloseBtn.addEventListener("click", closeModal); // тут просто передаем функцию
    
    modal.addEventListener("click", (e)=>{
        if(e.target === modal){    //проверяем строгое равенство объекта по которому кликнули объекту modal
            closeModal();          // тут вызываем функцию
        }
    });
    
    //Реализуем закрытие по кнопке Esc клавиатуры (Коды кнопок  keycode.info или learn.javascript.ru/keyboard-events)
    document.addEventListener("keydown", (e)=>{
        if(e.code === "Escape" && modal.classList.contains("show")){//если код события строго равен Escape(обозначение кнопки Esc)
            closeModal();           // вызываем функцию
        }
    });
    //что бы closeModal(); по Esc срабатывал только когда открыто окно modal.classList.contains("show")

}



{//  309    ====    Модификация модального окна    ====

    "use strict";
    //По нажатии двух разных кнопок будет выскакивать пока еще скрытое модальное окно <div class="modal">
    //Кнопки с разными аттрибутами и поэтому мы их бъеденим одним дата аттрибутом data-modal, допишем в верстку этот селектор
    //<button data-modal class="btn btn_dark">Связаться с нами</button> для закрытия этого окна прописываем 
    //в закрывающем элементе data-close  <div data-close class="modal__close">&times;</div>  - это крестик
    const modal = document.querySelector(".modal"),
          modalTrigger = document.querySelectorAll("[data-modal]"), //квадратные скобки что бы обратится к аттрибуту
          modalCloseBtn = document.querySelector("[data-close]");
    
    
    //Правило Don't Repeat yourself (DRY) если код повторяется нужно его вынести в одну функцию
    function closeModal(){
        modal.classList.add("hide");
        modal.classList.remove("show");
        document.body.style.overflow = ""; 
    }
    
    modalCloseBtn.addEventListener("click", closeModal); // тут просто передаем функцию
    
    modal.addEventListener("click", (e)=>{
        if(e.target === modal){    //проверяем строгое равенство объекта по которому кликнули объекту modal
            closeModal();          // тут вызываем функцию
        }
    });
    
    //Реализуем закрытие по кнопке Esc клавиатуры (Коды кнопок  keycode.info или learn.javascript.ru/keyboard-events)
    document.addEventListener("keydown", (e)=>{
        if(e.code === "Escape" && modal.classList.contains("show")){//если код события строго равен Escape(обозначение кнопки Esc)
            closeModal();           // вызываем функцию
        }
    });
    //что бы closeModal(); по Esc срабатывал только когда открыто окно modal.classList.contains("show")
    
    //<<<<<<<009 Модальное окно должно появится через определенное время или когда пользователь долистал страницу до конца >>>>>
    // const modalTimerId = setTimeout();
    
    //Создаем функцию для открытия окна преобразуя modalTrigger.forEach(btn =>{
    function openModal() {
        modal.classList.add("show");
        modal.classList.remove("hide");
        document.body.style.overflow = "hidden";
        //Дорабатываем openModal что бы если пользователь сам открыл окно, таймер отменялся
        clearInterval(modalTimerId); //Timeout отменяет также как и интервал
    }
    
    modalTrigger.forEach(btn =>{
        btn.addEventListener("click", openModal);
    });
    
    const modalTimerId = setTimeout(openModal, 5000);
    
    function showModalByScroll() {
        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
            openModal();
            window.removeEventListener("scroll", showModalByScroll);
        } 
    }
    
    //Делаем что бы окно показывалось при долистывании страницы до конца
    // window.addEventListener("scroll", ()=>{
    //     if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
    //         openModal();
    //     }   //pageYOffset - проскролленая часть + clientHeight - видимая часть на мониторе будут больше или равны
    //         // или больше scrollHeight все области скролла, минус 1 пиксель из-за особенности некоторых браузеров и мониторов
    // }//,{once: true});
    
    //что бы не запускалось много раз окно при доскроле до конца страницы можно использовать настройки обработчика событий
    //после функции можно добавить {once: true}, но оно в данном случае не сработает потому что обработчик повешен на скролл
    //тоесть оно срабатывает при скроле, но условия не выполняются и окно не появляется, а внизу страницы не запускается
    //потому что уже как бы сработало 
    //ВТОРОЙ способ будем удалять обработчик события с виндовся после 1 разового выполнения removeEventListener для этого
    //создаем функцию showModalByScroll и там прописываем ремув, и модифицируем window.addEventListener
    window.addEventListener("scroll", showModalByScroll);
    
}



{//  310    ====    Функции конструкторы    ====

    "use strict";
    //Функция - объект и по идее в нее можно записать какие то методы и свойства
    
    //длинный УСТАРЕВШИЙ синтаксис для создания типов данных начинается с ключевого слово new
    const num = new Number(3);
    //console.log(num);
    //получили Number  [[Prototype]]: Number  [[PrimitiveValue]]: 3 , намбер с велью 3
    //тоже можно сделать и с функцией
    const func = new Function(3);
    //console.log(func);
    //ƒ anonymous() {3}
    //Если такая функция будет содержать методы и свойства то она создаст нам новый объект
    
    //<<<<<< НОВЫЙ синтаксис >>>>>>>
    function User(name, id) {
        this.name = name;
        this.id = id;
        this.human = true;
        this.hello = function() {
            console.log(`Hello ${this.name}`);
        };
    }
    //Наша функция стала КОНСТРУКТОРОМ с помощью нее можно создавать новые (ОБЪЕКТЫ) пользователей
    const ivan = new User ("Ivan", 28);
    const alex = new User ("Alex", 20);
    console.log(ivan); // User {name: 'Ivan', id: 28, human: true}
    console.log(alex);
    alex.hello();
    
    //с помощью prototype можно добавлять свойства и методы в конструктор и они наследуются потомками
    //используется когда нету доступа к конструктору или его нельзя менять но нужно немного модифицировать
    User.prototype.exit = function(){
        console.log(`Пользователь ${this.name} ушел`);
    };
    //Этот метод появится у всех потомков которые созданы ПОСЛЕ его объявления
    alex.exit();
    
    //Это был ЕС5, в ЕС6 появились классы - синтаксический сахар(красивая обертка) их удобнее использовать
    class User {
        constructor(name, id){
            this.name = name;
            this.id = id;
            this.human = true;
        }
        hello() {
            console.log(`Hello ${this.name}`)
        }
        exit() {
            console.log(`Пользователь ${this.name} ушел`)
        }
    }

}



{//  311    ====    Контекст вызова функции this     ====

    "use strict";
    //контекст - то что окружает функцию и в каких условиях она вызывается
    //Функция может вызыватся 4мя способами и в каждом контекст вызова отличается
    
    //============ 1 =============
    // function showThis() {
    //     console.log(this);
    // }
    // showThis(); //без "use strict" this = window (глобальный обект), с "use strict" будет undefined
    
    //практическая задача - что выведет функция и как исправить если не работает
    // function showThis2(a, b) {
    //     console.log(this);
    //     function sum(){
    //         console.log(this);
    //         return this.a + this.b;
    //     }
    //     console.log(sum());
    // }
    // showThis2(4, 5);
    //Будет ошибка в "use strict", а без него выдаст NaN, потому что sum сслается на window или undefined, и у них нету а или b 
    //Исправляется код удалением this из a и b, тогда sum не найдя их в себе ищет в функции выще благодаря замыканию функций
    
    //============ 2 ============= Метод объекта
    // const obj = {
    //     a: 20,
    //     b: 15,
    //     sum: function() {
    //         console.log(this);
    //     }
    // };
    // obj.sum();
    //Контекст у методов объекта - сам объект
    
    // const obj = {
    //     a: 20,
    //     b: 15,
    //     sum: function() {
    //         function shout() {
    //             console.log(this);
    //         }
    //         shout();
    //     }
    // };
    // obj.sum();
    //при таком методе будет возвращено с "use strict" будет undefined без - window, 
    //потому что это уже не метод объекта а функция внутри метода
    
    //============ 3 ============= Функции конструкторы
    // function User(name, id) {
    //     this.name = name;
    //     this.id = id;
    //     this.human = true;
    
    //     this.hello = function() {
    //         console.log(`Hello ${this.name}`);
    //     };
    // }
    
    // let ivan = new User("Ivan", 23);
    // ivan.hello();
    //this в конструкторах и классах - это новый экземпляр объекта, в данном случае ссылается на ivan
    
    //============ 4 ============= ручное присвоение this любой функции: call, apply, bind
    // function sayName() {
    //     console.log(this);
    //     console.log(this.name);
    // }
    
    // const user = {
    //     name: "John"
    // };
    
    // sayName.call(user);// получаем объект и второй строчкой John
    // sayName.apply(user);//работает также как call, разница в синтаксисе при передаче аргументов
    
    // function sayName(surname) {
    //     console.log(this);
    //     console.log(this.name + surname);
    // }
    
    // const user = {
    //     name: "John"
    // };
    
    // sayName.call(user, "Smith");    //разница в синтаксисе при передаче аргументов - передем строкй
    // sayName.apply(user, ["Smith"]); //разница в синтаксисе при передаче аргументов - передем массивом
    
    // //третий метод bind - создает НОВУЮ функцию и под нее подвязывает контекст
    // function count(num) {
    //     return this*num;
    // }
    // //создаем переменную и назначаем ей функцию count через метод bind
    // const double = count.bind(2);
    // //При этом (2) - переходит в this, а num будет передаваться в функцию double
    // console.log(double(3)); // 6
    // console.log(double(13)); // 26
    
    //=================== ПРАКТИКА ================= 
    //В ХТМЛ есть <button></button> которая ничего не содержит
    const btn = document.querySelector("button");
    
    btn.addEventListener("click", function() { //смотрим чему равен this применимо к нашему элементу при клике
        console.log(this);  // в консоль получаем сам объект <button></button> тоесть тоже самое что event.target
        this.style.backgroundColor = "red"; //работает, но чаще пользуются event.target
    });
    
    // //Но если функция будет СТРЕЛОЧНОЙ (у стрелочной нету своего контекста вызова, она берет его от родителя) то 
    // btn.addEventListener("click", ()=> { //стрелочная пытается всзять контекст у undefined или window в зависимости от "use strict";
    //     console.log(this);  // в консоль получаем сам ОШИБКУ потому что теряется контекст
    // }); 
    
    // тогда нужно прописывать обращение не через this а через event.target для работоспособности
    // btn.addEventListener("click", (e)=> { 
    //      e.target.style.backgroundColor = "red";
    // });
    
    
    const obj = {
        num:5,
        sayNumber: function() {
            const say = () => {
                console.log(this);
            };
            say();
        }
    };
    obj.sayNumber();
    //Если бы say была обычно функц. то было бы undefined, но у стрелочной нету своего контекста и она берет контекст у родителя
    //у метода sayNumber, а метод объект всегда выдает сам объект, поэтому получаем сам объект в консоль
    //Стрелочные ф. обычно используются для модификации элементов прямо тут на месте и имеет свой синтаксис
    
    //запись с классической функцией
    // const double = function() {
    //     return a * 2;
    // }
    
    //Запись стрелочной ф. можно сократить если тело функции помещается в одну строку, убираем скобки 
    const double = (a) => a * 2; // и return(c return будет ошибка) которое подставляется автоматически
    //а если аргумент один то скобки у него тоже можно сократить  const double = a => a * 2;
        
}



{//  312    ====    Classes (ES6)     ====

    "use strict";
    //Классы - красиваяобертка ф. конструкторов (синтаксический сахар)
    //название класса ВСЕГДА с БОЛЬШОЙ буквы
    //=== Принципы ООП ====
    //1)=== АБСТРАКЦИЯ ==== когда отделяем концепцию от ее экземпляра. Rectangle - концепция(шаблон), square и long - экземпляры
    class Rectangle {
        constructor(height, width) {
            this.height = height;
            this.width = width;
        }
    
        calcArea(){
            return this.height * this.width;
        }
    } 
    
    // const square = new Rectangle(10, 10);
    // const long = new Rectangle(20, 100);
    
    // console.log(square.calcArea());
    // console.log(long.calcArea());
    
    
    //2) === НАСЛЕДОВАНИЕ === способность объекта или класса базироваться на другом объекте или классе (extends - наследуется)
    class ColoredRectangleWithText extends Rectangle {
        constructor(height, width, text, bgColor) {
            super(height, width); //метод вызывает суперконструктор родителя, тот код который был у родителя в конструкторе и методы 
                     // super() - должен быть в конструкторе ВСЕГДА на ПЕРВОМ месте
            this.text = text;
            this.bgColor = bgColor;
        }
    
        showMyProps() {
            console.log(`Текст: ${this.text}, цвет ${this.bgColor}`);
        }
    }
    
    const div = new ColoredRectangleWithText(25, 10, "Hello", "red");
    div.showMyProps(); // Текст: Hello, цвет red
    console.log(div.calcArea()); //250

}



{//  313    ====    Use Classes in real work (шаблонизация, создание єлементов на странице через классы)

    "use strict";
    //По нажатии двух разных кнопок будет выскакивать пока еще скрытое модальное окно <div class="modal">
    //Кнопки с разными аттрибутами и поэтому мы их бъеденим одним дата аттрибутом data-modal, допишем в верстку этот селектор
    //<button data-modal class="btn btn_dark">Связаться с нами</button> для закрытия этого окна прописываем 
    //в закрывающем элементе data-close  <div data-close class="modal__close">&times;</div>  - это крестик
    const modal = document.querySelector(".modal"),
          modalTrigger = document.querySelectorAll("[data-modal]"), //квадратные скобки что бы обратится к аттрибуту
          modalCloseBtn = document.querySelector("[data-close]"),
          btnCall = document.querySelector(".btn_min");
    
    
    //Правило Don't Repeat yourself (DRY) если код повторяется нужно его вынести в одну функцию
    function closeModal(){
        modal.classList.add("hide");
        modal.classList.remove("show");
        document.body.style.overflow = ""; 
    }
    
    modalCloseBtn.addEventListener("click", closeModal); // тут просто передаем функцию
    
    modal.addEventListener("click", (e)=>{
        if(e.target === modal){    //проверяем строгое равенство объекта по которому кликнули объекту modal
            closeModal();          // тут вызываем функцию
        }
    });
    
    //Реализуем закрытие по кнопке Esc клавиатуры (Коды кнопок  keycode.info или learn.javascript.ru/keyboard-events)
    document.addEventListener("keydown", (e)=>{
        if(e.code === "Escape" && modal.classList.contains("show")){//если код события строго равен Escape(обозначение кнопки Esc)
            closeModal();           // вызываем функцию
        }
    });
    //что бы closeModal(); по Esc срабатывал только когда открыто окно modal.classList.contains("show")
    
    //<<<<<<<009 Модальное окно должно появится через определенное время или когда пользователь долистал страницу до конца >>>>>
    // const modalTimerId = setTimeout();
    
    //Создаем функцию для открытия окна преобразуя modalTrigger.forEach(btn =>{
    function openModal() {
        modal.classList.add("show");
        modal.classList.remove("hide");
        document.body.style.overflow = "hidden";
        //Дорабатываем openModal что бы если пользователь сам открыл окно, таймер отменялся
        clearInterval(modalTimerId); //Timeout отменяет также как и интервал
    }
    
    modalTrigger.forEach(btn =>{
        btn.addEventListener("click", openModal);
    });
    
    //const modalTimerId = setTimeout(openModal, 5000);
    
    function showModalByScroll() {
        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
            openModal();
            window.removeEventListener("scroll", showModalByScroll);
        } 
    }
    
    //Делаем что бы окно показывалось при долистывании страницы до конца
    // window.addEventListener("scroll", ()=>{
    //     if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight - 1){
    //         openModal();
    //     }   //pageYOffset - проскролленая часть + clientHeight - видимая часть на мониторе будут больше или равны
    //         // или больше scrollHeight все области скролла, минус 1 пиксель из-за особенности некоторых браузеров и мониторов
    // }//,{once: true});
    
    //что бы не запускалось много раз окно при доскроле до конца страницы можно использовать настройки обработчика событий
    //после функции можно добавить {once: true}, но оно в данном случае не сработает потому что обработчик повешен на скролл
    //тоесть оно срабатывает при скроле, но условия не выполняются и окно не появляется, а внизу страницы не запускается
    //потому что уже как бы сработало 
    //ВТОРОЙ способ будем удалять обработчик события с виндовся после 1 разового выполнения removeEventListener для этого
    //создаем функцию showModalByScroll и там прописываем ремув, и модифицируем window.addEventListener
    window.addEventListener("scroll", showModalByScroll);
    
    //013
    class MenuCard{
        constructor(src, alt, title, descr, price, parentSelector){ //alt - будет показываться если картинки нету
            this.src = src;
            this.alt = alt;
            this.title = title;
            this.descr = descr;
            this.price = price;
            this.parent = document.querySelector(parentSelector);
            this.transfer = 28; //пока записываем статически курс валют
            this.changeToUAH(); // вызываем метод для конвертирования, он выполниться перед методом создания верстки
        }
    
        changeToUAH() { // Метод для конвертирования цены из долларов в гривну когда эта информация будет приходить с сервера
            this.price = this.price * this.transfer;
        }
    
        render() { //метод для формирования верстки. 
            const element = document.createElement("div"); //создаем элемент div
            //Вставлем верстку из хтмл в innerHTML созданного div
            element.innerHTML = `
                <div class="menu__item">
                    <img src=${this.src} alt=${this.alt}>
                    <h3 class="menu__item-subtitle">${this.title}</h3>
                    <div class="menu__item-descr">${this.descr}</div>
                    <div class="menu__item-divider"></div>
                    <div class="menu__item-price">
                        <div class="menu__item-cost">Цена:</div>
                        <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                    </div>
                </div>
            `;
            //Для размещения этой структуры нужно знать родителя, добавляем в принимаемые аргументы parentSelector, 
            //он может быть разный в зависимости от создаваемой карты MenuCard, сразу получаем его элемент
            this.parent.append(element);
        }
    }
    //Можно использовать вызов объекта на месте, без присвоения его к переменной, но тогда в будущем не сможем к нему обратиться
    new MenuCard(
        "img/tabs/vegy.jpg",
        "vegy",
        'Меню "Фитнес"”',
        'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
        9,
        ".menu .container"
    ).render();
    //заменяем карточки которые были в верстке и удаляем их оттуда
    new MenuCard(
        "img/tabs/elite.jpg",
        "elite",
        'меню “Премиум”',
        'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',
        9,
        ".menu .container"
    ).render();
    
    new MenuCard(
        "img/tabs/post.jpg",
        "post",
        'Меню "Постное"',
        'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',
        9,
        ".menu .container"
    ).render();
    
    
    // const testCard = new MenuCard(
    //     "img/tabs/elite.jpg",
    //     "elite",
    //     'меню “Премиум”',
    //     'В меню “Премиум” мы ...',
    //     100,
    //     ".menu .container");
    // testCard.render();
    //btnCall.addEventListener("click", testCard.render); //- через кнопку почему то не работает
    
    //Структура HTML верстки. Обращаемся к самому верхнему элементу .menu а потом к его div .container
    /* <div class="menu">
            <h2 class="title">Наше меню на день</h2>
    
            <div class="menu__field">
                <div class="container">
                    <div class="menu__item"></div> */
}



{//  314    ====    Rest оператор и параметры по умолчанию (ES6)     ====

    "use strict";
    //Spread - оператор разворота, берет сущность и раскладывает на отдельные элементы
    //Rest - объединяет отдельные элементы в один массив, обратен spread синтаксис такой же но в других условиях.
    // записывается как ...name(name-любой) всегда последним аргументом, используется для аргументов (опциональных), 
    //если мы не знаем сколько еще будет агрументов 
    const log = function(a, b, ...rest) {
        console.log(a, b, ...rest);
    };
    
    log("basic", "else", "operator", "usage"); // basic else [operator usage]
    
    //Метод использовался до (ES6). Задание параметра по умолчанию, если он будет отсутсвовать
    // function calcOrDouble(number, basis) {
    //     basis = basis || 2;
    //     console.log(number * basis);
    // }
    // calcOrDouble(3, ); // но если второго аргумента не будет то будет ошибка, и что бы этого избежать раньше делали basis = basis || 2;
    // в некоторых случаях такая проверка приводила к ошибкам, и поэтому в ES6 можно присвоить 2 сразу в объявлении
    function calcOrDouble(number, basis = 2) {
        console.log(number * basis);
    }
    calcOrDouble(3, );
    
    //Переходим в файл со скриптом о карточках
    //=========  014 используем rest оператор =============
    //В методе render мы создаем лишний div, что бы от этого избавится нужно класс "menu__item" присвоить этому div 
    //но что бы нам присвоить еще классы этому div которые могут появится в будущем, можно их задать через rest
    class MenuCard{
        constructor(src, alt, title, descr, price, parentSelector, ...classes){ //alt - будет показываться если картинки нету
            this.src = src;
            this.alt = alt;
            this.title = title;
            this.descr = descr;
            this.price = price;
            this.classes = classes;
            this.parent = document.querySelector(parentSelector);
            this.transfer = 28; 
            this.changeToUAH(); 
        }

        changeToUAH() { 
            this.price = this.price * this.transfer;
        }

        render() { //метод для формирования верстки. 
            const element = document.createElement("div"); 
            //Задаем параметр класса по умолчанию, в случае если его не будет.Проверку выполняе на количество элементов, так как rest
            //все равно сформирует пустой массив который в условии будет интерпретироваться как true. Также ведут себя qeurySelectorAll,
            //getElementsByClassName и т.д. когда мы пытаемся получить эл. со страницы и их не находит, формируется пустой массив
            if(this.classes.length === 0) {
                this.element = "menu__item"; //присваиваем класс в пустой массив для возможной дальнейшей работы с ним
                element.classList.add("menu__item");
            } else {
                //перебираем массив выдергиваем каждое название класса и присваи ваем его как класс класслисту элемента
                this.classes.forEach(className => element.classList.add(className)); 
            }
        
            //убираем <div class="menu__item">, и присваивам его при задании новой карточки последним аргументом
            //Записываем без точки потому что присвоние через classList
            element.innerHTML = `
                    <img src=${this.src} alt=${this.alt}>
                    <h3 class="menu__item-subtitle">${this.title}</h3>
                    <div class="menu__item-descr">${this.descr}</div>
                    <div class="menu__item-divider"></div>
                    <div class="menu__item-price">
                        <div class="menu__item-cost">Цена:</div>
                        <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                    </div>
            `;
            this.parent.append(element);
        }
    }

    new MenuCard(
        "img/tabs/vegy.jpg",
        "vegy",
        'Меню "Фитнес"”',
        'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
        9,
        ".menu .container",
    ).render();
    //заменяем карточки которые были в верстке и удаляем их оттуда
    new MenuCard(
        "img/tabs/elite.jpg",
        "elite",
        'меню “Премиум”',
        'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',
        14,
        ".menu .container",
        "menu__item"
    ).render();

    new MenuCard(
        "img/tabs/post.jpg",
        "post",
        'Меню "Постное"',
        'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',
        12,
        ".menu .container",
        "menu__item"
    ).render();

}





// 400 ========================================== ПРОДВИНУТЫЙ ==================================================================


{//  401    ====    Local servers    ====

    //Разновидности серверов: Простые - выполняют одну задачу или несколько простых(LiveServer в VSCode, http server, JSON server),
    // Комплексные - выполняют всё
    //Самые популярные HTTP запросы  Get и Post. Простые сервера принимают только Get запросы.
    //AJAX серверная технелогоия позволяет отправлять Гет и Пост запросы без перезагрузки страницы

}



{//  402    ====    JSON, глубокое клонирование объектов    ====

    "use strict";
    //JSON текстовый формат обмена данных. В файлах с расширениями JSON можно хранить данные в формате ключ - значение.
    //Главное правило - все строки должны быть в двойных кавычках
    
    // const persone = {
    //     name: "Alex",
    //     tel: "+7777744444"
    // };
    
    //Что бы передать этот объект на сервер нужно его преобразовать в один из вариантов который можно транспортировать.
    //Посмотреть основы протокола http. 
    //В уроках будем разбирать стандартный URL encoded  - форма просто отправляется с сайта с перезагрузко страницы(даже без скрипта)
    //Передача объекта form - data  и формат данных JSON
    
    //Все современные браузеры имеют встроенные инструменты для работы с данными JSON это свойства и методы
    //методов два 
    
    //1) stringify - превращает объекты в нужный формат 
    // console.log(JSON.stringify(persone)); // {"name":"Alex","tel":"+7777744444"}
    
    // //2)parse превращает информацию с сервера JSON в привычный формат данных
    // console.log(JSON.parse(JSON.stringify(persone))); // получаем объект {name: 'Alex', tel: '+7777744444'} с которым можно работать
    
    //данные в JSON занимают мало места и легко читаются, до него был XML там не было таких преимуществ
    
    //============================ Клонирование объектов. ГЛУБОКИЕ КОПИИ ===================================
    const persone = {
        name: "Alex",
        tel: "+7777744444",
        parents: {
            mom: "Olga",
            dad: "Mike"
        }
    };
    //такая структура превращает объект в формат JSON потом парсит обратно и отвязывает от исходного объекта, присваивая НОВЫЙ переменной
    const clone = JSON.parse(JSON.stringify(persone)); 
    clone.parents.mom = "Ann" ;
    console.log(persone);
    console.log(clone);

}



{//  403    ====    AJAX и общение с сервером CALC (Converter)    ====

    "use strict";
    //AJAX (Asynchronous Javascript and XML) позволяет обновлять часть контента страницы, без полной перезагрузки, экономя траффик
    //Создадим конвертер валю где курс будет приходить от сервера по требованию
    //разбираем самый первый вариант AJAX который реализуется при помощи объекта XML hhtp request(не актуален, но встречается)
    //который встроен в браузер
    
    //в папке JS файл current.json с внутренним текстом (путь js/current.json) 
    // {
    //     "current": {     //свойство объекта содержит объект usd со свойством 74 - курс доллара
    //         "usd": 74    // это значение будет доставать через usd
    //     }
    // }
    
    //получаем элементы инпутов со страницы. В один rub будет пользователь вводить значение, а во второй usd будем выводить 
    //сконвертированное значение на основании запроса от сервера и обработки
    const inputRub = document.querySelector("#rub"),
          inputUsd = document.querySelector("#usd");
    
    //назначаем обработчик события для получения данных от пользователя. Выбор между input и change
    //change - происходит когда пользователь напечатала что то в поле и увел фокус(табом или клацнул в другое место на странице)
    //input - происходит каждый раз когда что то вводится или удаляется в поле
    inputRub.addEventListener('input', () => {
        const request = new XMLHttpRequest(); //создаем запрос на сервер
    
        // этот метод собирает настройки которые позволят в будущем сделать запрос request.open(method, url, async, login, pass); 
        //method - метод для запроса (GET,POST)  пишутся в верхнем регистре, url - путь к серверу(файлу) относительно index.html , 
        //async - по умолчанию true, чтобы остальной код не ждал ответа от сервера,
        // потому что неизвестно как долго это будет, можно поставить в false при надобности
        //login и pass используются для некоторых запросов требующих авторизации
        request.open('GET', 'js/current.json'); // запрос, остальные аргументы для нас сейчас необязательны
        //для уточнения серверу что мы хотим получить используются заголовки Header
        //'Content-type' - тип контента, 'application/json' указываем что хотим json файл с кодировкой utf-8
        request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        request.send(); // отправляем запрос на сервер
        //если метод post или подобный то send(body) - принимает аргументы для отправки
    
        //СВОЙСТВА запроса: status - код с которым вернется запрос(200 OK - успешные, 400 - ошибка клиента(404 Not Found) ... и тд)
        //посмотреть состояния можно по запросу  << Список кодов состояния HTTP >>
        //statusText - текстовое описание ответа сервера (ок, Not found, ... и тд)
        //response - ответ от сервера (то что задл бэк енд разработчик), используем его в клиенте
        //readyState - содержит текущее состояние запроса(цыфра). Цыфра 0 значение UNSENT, 1 OPENED, 2 HEADERS_RECEIVED,
        //3	LOADING, 4	DONE (выполнена)
    
        //СОБЫТИЯ loadstart, progress, abort, timeout, loadend, но чаще всего используются cледующие 2 события
        //рассмотрим реализацию каждого из них
    
        //readystatechange - отслеживает статус готовности запроса в текущий момент например с 0 на 1 - сработало, с 1-2 сработало
        // request.addEventListener('readystatechange', () => { //
        //     if(request.readyState === 4 && request.status === 200){
        //         console.log(request.response); // получаем объект из json файла который нужно трансформировать в объект JS
        //         const data = JSON.parse(request.response); //получаем объект JS
        //         //рассчитываем курс валют на основании ввода пользователя и ответа сервера и выводим в поле
        //         inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2); //toFixed(2) - округляем до 2х заков после точки
        //     } else { //дописываем елсе если сервер сломался что бы пользователь увидел ошибку
        //         inputUsd.value = 'Что то пошло не так';
        //     }
        // });
        //Используется редко потому что обычно промежуточные стадии 0, 1, 2, 3 не нужны, а нужна сразу 4 DONE (выполнена)
    
        //load - срабатывает когда запрос полностью загрузился и получен результат. 4 DONE (выполнена) - не значит что выполнен
        //успешно, данные могут потерятся или еще что то
        request.addEventListener('load', () => { // оставляем проверку на успешное выполнение status
            if(request.status === 200){
                const data = JSON.parse(request.response); //получаем объект JS
                //рассчитываем курс валют на основании ввода пользователя и ответа сервера и выводим в поле
                inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2); //toFixed(2) - округляем до 2х заков после точки
            } else { //дописываем елсе если сервер сломался что бы пользователь увидел ошибку
                inputUsd.value = 'Что то пошло не так';
            }
        });
    });

}



{//  404    ====    Реализация скрипта ОТПРАВКИ данных на сервер (POST) XML http request    ====

    //Переходим в файл со скриптом о карточках Food. Запускаем его на сервере для работы POST
    //Задача собрать данные из форм  Имя и Телефон в двух местах(на сайте и в модальном окне) и отправить на сервер при нажатии кнопки
    //Для контроля правильной отработки бэкенда создаем в корне проэкта файл server.php и запишем <?php echo var_dump($_POST);
    //Эта комманда берет данные которые пришли из клиента ( массив _POST ) превращает в строку и показывает обратно на клиенте(ответ сервера, responce)

    //формы две (имя, телефон) поэтому функция отправки будет повторятся, что бы не дублировать два обработчика, обернем
    //в функцию для последующего вызова. Тут еще используем XML hhtp request, в следующих уроках будет более современный метод

    //получаем все формы по тегу
    const forms = document.querySelectorAll('form');

    //Создаем объект для вывода текстовых сообщений пользователю о ходе запроса
    const message = {
        loading: 'Загрузка',
        success: 'Спасибо! До связи',
        failure: ' Что-то пошло не так...'
    };

    //берем все form и для каждой подвязываем функцию postData
    form.forEach(item => {
        postData(item);
    });


    //Функция для постинга данных
    function postData(form) { //принимаем аргумент form для удобства навешивания на него обработчика события submit
        form.addEventListener('submit', (e) => {  // submit срабатывает по Enter или button с type submit. если в верстке кнопка задана
                                                //тегом <button - у нее автоматически установлен type submit
            e.preventDefault(); // принимаем аргумент е - события, что бы отменить стандартное повередение - перезагрузку страницы
            
            //Создаем переменную для вывода пользователю сообщений
            const statusMessage = document.createElement('div');
            statusMessage.classList.add('status'); //добавляем класс status
            statusMessage.textContent = message.loading;
            form.append(statusMessage); // Прикрепляем этот див с сообщением к form для отображения на странице

            const req = new XMLHttpRequest(); //создаем объект запроса
            req.open('POST', 'server.php'); // вызываем метод open для настройки запроса

            //как получить все данные введенные пользователем и отправить на сервер. Можно вручную. взять форму, взять все инпуты
            //которые есть внутри, взять их value, перебрать, сформировать объект, но это очень нерационально потому что есть готовые
            //механизмы, и самый простой способ подготовить данные для отправки из формы использовать объект - formData
            //не всегда нужно передавать в формате JSON, зависит от поддержки сервера или программиста бэкенда
            //рассмотрим formData и второй формат JSON

            // Если работаем с JSON, FormData спецыфический объект который просто превратить в JSON не получится, есть спецю прием
            req.setRequestHeader('Content-type', 'application/json');
            //Для этого создаем пустой объект и через переюор FormData через forEach запушим в новый объект значения
            const object = {};
            formData.forEach(function(value, key){
                object[key] = value;
            });
            //Теперь используем конвертацию в json и помещаем его в  req.send(json);
            const json = JSON.stringify(object);

            //если передаем через XMLHttpRequest
            //req.setRequestHeader('Content-type', 'multipart/form-data'); // multipart/form-data - используем что бы работал FormData
                                                                        //согласно описанию FormData, но есть ***ньюанс - смотр ниже!!!

            const formData = new FormData(form); // формирует объект ключ-значение из полей input/option/textarea, но только если 
                                                // у них прописан тег name, иначе не найдет эти значения.(name="name", name="phone")
            req.send(formData); // так как мы отправляем данные то есть body - formData

            //Если работаем с JSON то 
            //req.send(json);

            req.addEventListener('load', () => {
                if (req.status === 200) {
                    console.log(req.response);
                    statusMessage.textContent = message.success;
                    form.reset(); // очищаем форму
                    setTimeout(() =>{
                        statusMessage.remove()   // удаляем блок со страницы
                    }, 2000);
                }else{
                    statusMessage.textContent = message.failure;
                    }
            });
        });
    }
    //Что бы изменения сохраненные в коде применились при работе с сервером, нужно каждый раз сбрасывать кеш. shift+f5
    // После заполнения полей и нажатия кнопки отправить, данные ушли - смотрим по вкладке Network, статус сервера -200 ОК
    // нам написало 'Спасибо! До связи' но в консоль получили пустой массив, это случилось из-за заголовка  multipart/form-data
    // Когда используем связку XMLHttpRequest(), Объекта и FormData - заголовок устанавливать не нужно, он устанавливается
    //автоматически, поэтому весь заголовок req.setRequestHeader('Content-type', 'multipart/form-data'); нам не нужно прописывать
    //поэтому закомментируем его и все будет отрабатывать хорошо. 
    //Если нужно отправлять данные в JSON тогда прописываем req.setRequestHeader('Content-type', 'application/json');
    //*** Ньюанс PHP нативно не умеет работать с данными JSON, чаще всего такие данные отправляют на сервера Node.JS
    //Но можно вручную прописать совместимость с PHP в файле допишем строку 
    //<?php echo 
    //$_POST = json_decode(file_get_contents("php://input), true);
    //var_dump($_POST);

}



{//  405    ====    Красивое оповещение пользователя    ====

    //Переходим в файл со скриптом о карточках Food. Запускаем его на сервере для работы POST
    //============================ 005 Красивое оповещение пользователя
    //Прикручиваем спиннер в течении отправки запроса на сервер, а после успешного выполнения появление нового модального окна с текстом
    //Если запрос неудачный то будет другое сообщение. Модальное окно можно сделать новое, а можно использовать существующее.
    //Используем существующее и в нем заменим <div class="modal__dialog"> для изменения контента окна. Стили действуют прежние
    {/* <div class="modal">
            <div class="modal__dialog">
                <div class="modal__content">
                    <form action="#">
                        <div data-close class="modal__close">&times;</div>
                        <div class="modal__title">Мы свяжемся с вами как можно быстрее!</div>
                        <input required placeholder="Ваше имя" name="name" type="text" class="modal__input">
                        <input required placeholder="Ваш номер телефона" name="phone" type="phone" class="modal__input">
                        <button class="btn btn_dark btn_min">Перезвонить мне</button>
                    </form>
                </div>
            </div>
        </div> */}

    function showThanksModal(message) {
        const prevModalDialog = document.querySelector('.modal__dialog');
    
        //скрываем, а не удаляем предыдущее модальное окно что бы пользователь повторно его мог использовать
        prevModalDialog.classList.add('hide');
        openModal(); // открывается модальное окно
    
        const thanksModal = document.createElement('div'); //Создаем обвертку для нового модального окна
        thanksModal.classList.add('modal__dialog'); // добавляем стили для модального окна
        //Создаем новый тайтл и крестик х - закрытия, но он динамически создается и на него обработчик события ранее созданный closemodal
        // которая вешалась на modalCloseBtn получаемому по аттрибуту [data-close] действовать не будут, поэтому мы их подправим
        // modalCloseBtn = document.querySelector("[data-close]") и modalCloseBtn.addEventListener("click", closeModal); - этот удалим
        //
        //Этот подправим    modal.addEventListener("click", (e)=>{
        //                      if(e.target === modal){    
        //                      closeModal();          
                                //}
                            //});
        //теперь выглядит так 
        //005 Усовершенствованное для динамически создаваемых окон
        // modal.addEventListener("click", (e)=>{
        //     // Проверяем равенство объекту modal или объект содержащий аттрибут data-close равен пустой строке, мы туда ничего не помещаем
        //     if(e.target === modal || e.target.getAttribute('data-close') == '') {  
        //         closeModal();          // тут вызываем функцию
        //     }
        // });
    
        //***Крестик x  - специальный ХТМЛ символ (✖	&#10006;	Жирный символ закрыть (крестик))
        //Сообщение для пользователя в modal__title будем перелаваит как аргумент message в showThanksModal который будем брать из
        //объекта message
        thanksModal.innerHTML = `
        <div class="modal__content">
            <div class="modal__close" data-close>x</div> 
            <div class="modal__title">${message}</div> 
        </div>
        `;
    
        //Получаем модальное окно и сразу аппендим наш блок для замены старого окна новым
        document.querySelector('.modal').append(thanksModal);
    
        //Реализуем появление старого окна если пользователь снова его вызовет
        setTimeout(() => { // удаляем наш новый блок
            thanksModal.remove();
            prevModalDialog.classList.add('show');
            prevModalDialog.classList.remove('hide');
            closeModal(); // закрываем окно что бы не мешало пользователю
        } , 4000);
    }
    
    // Теперь в функции отправки проведем изменения
    // function postData(form) { 
    //     form.addEventListener('submit', (e) => {  
          
    //         e.preventDefault(); 
            
    //          const statusMessage = document.createElement('div');
    //         statusMessage.classList.add('status'); 
    //         statusMessage.textContent = message.loading;
    //         form.append(statusMessage); 
    
    //         const req = new XMLHttpRequest(); 
    //         req.open('POST', 'server.php'); 
    
    //         req.setRequestHeader('Content-type', 'application/json');
    //         const object = {};
    //         formData.forEach(function(value, key){
    //             object[key] = value;
    //         });
           
    //         const json = JSON.stringify(object);
    
    //         const formData = new FormData(form); 
    //         req.send(formData); 
    
    //         req.addEventListener('load', () => {
    //             if (req.status === 200) {
    //                 console.log(req.response);
    //                 showThanksModal(message.success); // запускаем нашу нункцию с аргументом сообщением
    //                 form.reset(); //Удалили таймаут потому что она будет использоваться только для спинера
    //                 statusMessage.remove(); // удаляется спиннер   
    //             }else{
    //                 showThanksModal(message.failure);
    //             }
    //         });
    //     });
    // }
    
    //Раскоментируем const modalTimerId = setTimeout(openModal, 50000); потому что она давала ошибку в консоле и если так и оставить
    //то вызов  openModal() в функции showThanksModal завершится ошибкой и дальше код не пойдет
    
    //Добавляем вместо loading: 'Загрузка' в объекте message - картинку спиннер "spinner.svg". В папке img создаем папку form
    //и туда помещаем спиннер, как относящийся к этому элементу
    // const message = {
    //     loading: 'img/form/spinner.svg',
    //     success: 'Спасибо! До связи',
    //     failure: ' Что-то пошло не так...'
    // };
    
    //Также изменяем
    // form.addEventListener('submit', (e) => {  
    //     e.preventDefault(); 
    //     //005 изменяем для показа картинки и класс
    //     const statusMessage = document.createElement('img');
    //     statusMessage.src = message.loading;
    //     //записываем инлайн стили что бы картинка была по центру
    //     statusMessage.style.cssText = `
    //         display: block;
    //         margin: 0 auto;
    //     `;
    //     form.append(statusMessage); 
    
    //При первой эмуляции медленного интернета slow 3G(вместо online) на вкладке Network в консоли изображение мелькнуло и пропало,
    //так как эмулируется медленный интерней картинка не успела подгрузится до выполнения запроса, нужно повторить отправку формы
    //для нормального отображения.
    //При сбросе кеша параметр slow 3G нужно менять снова на online, а то будет долго перекешироваться страница
    
    //При проверке второй формы без модального окна, спиннер сдвигает форму влево, потому что верстка на флексах(фликсах) этого
    //можно избежать если вместо аппенда  form.append(statusMessage) присоединять спиннер после формы
            //form.append(statusMessage);  - удалена в 005 что бы не сдвигалась форма используем insertAdjacentElement послеформы
            // form.insertAdjacentElement('afterend', statusMessage);
            
}



{//  406    ====    Promise    ====

    "use strict";
    //Позволяет удобно работать с асинхронными операциями(timeOut или запросы на сервер). При выполнении клика хотим что бы только
    // в этом случае выполнялся заданный код, тогда мы используем коллбек фунции. ПРИМЕР :Когда делаем запрос на сервер получаем
    //данные, выполняем с ними какие то действия и снова отправляем на сервер что бы получить следующие данные и снова с ними произвести
    //какие то операции. Цепочка действий зависит от предыдущих результатов (выполняем действие только после успешного выполнения 
    // предыдущих действий). Для такого кода можно написать много функций обратного вызова что превратится в большой нечитабельный код,
    // его также иногда называются call back hell.  Promise заменяет большой код с функциями обратного вызова.

    // Promise после reject/resolve – неизменны. после вызова resolve/reject промис уже не может «передумать».
    // Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда.
    // Последующие вызовы resolve/reject будут просто проигнорированы.



    // НЕБОЛЬШОЙ ПРИМЕР (вместо setTimeot  будут запросы к серверу)
    // console.log('Запрос данных...');

    // setTimeout(() => {
    //     console.log('Подготовка данных...');

    //     const product = {
    //         name: 'TV',
    //         price: 2000
    //     };

    //     setTimeout(() => {
    //         product.status = 'Ordered';
    //         console.log(product);
    //     }, 2000);
    // }, 2000);


        console.log('Запрос данных...');

    //создаем новый промис с коллбек функцией внутри обычно принимает 2 аргумента function(resolve, reject). resolve, reject - функции
    //которые мы сами сможем передавать. resolve - означает что то выполнилось правильно, reject - что то пошло не так, 
    //обещание не выполнилось. Сеттаймут с  product.status - заменяем на resolve, потому что он выполнится только в случае выполнения
    //предыдущего кода
            const req = new Promise(function(resolve, reject) {
                setTimeout(() => {
                    console.log('Подготовка данных...');
                
                    const product = {
                        name: 'TV',
                        price: 2000
                    };
                
                    resolve(product);
                }, 2000);
            }); 

    //vscode подсказывает что есть методы req (catch, then, finally). then - запускает функцию в случае положительного выполнения
    //предыдущего кода, будет вызыватся из места где resolve впредыдущем коде. В этом коде product не существует, поэтому его
    //нужно вернуть из предыдущей функции, вписав аргументом в resolve(product) и req.then((product)
    // req.then((product) => {
    //     setTimeout(() => {
    //         product.status = 'Ordered';
    //         console.log(product);
    //     }, 2000);
    // });
        
        
    //Для дальнейших действий с кодом req.then оборачиваем его в промис как и предыдущий(исходный код) 
    // req.then((product) => {
    //     const req2 = new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             product.status = 'Ordered';
    //             resolve(product);
    //         }, 2000);
    //     });
    //
    //     req2.then(data => {
    //         console.log(data);
    //     });
    // });
    //

    //***Если код не обернуть в новый промис то второе обращение then будет обращаться к первому промису и будет выполнятся не 
    //после второго, а совместно с первым tnen ***  МОЙ ПРИМЕР
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //        
    //         console.log(x);
    //         resolve(x);
    //     }, 2_000);
    //    
    // });
    // prom.then((x) => {
    //      setTimeout(() => {
    //       x = x + 2;
    //         console.log(x);
    //         return x;
    //     }, 2_000);
    // });
    // prom.then((x2) => {
    //     setTimeout(() => {
    //     x2 = x2 + 4;
    //         console.log(x2);
    //         return x2;
    //     }, 2_000);
    // });
    //Тут я ожидал увидеть  в консоли 10 12 16 через каждые 2 секунды, но по факту 10 12 14 - 12 и 14 выполняются одновременно и
    //используют данные которые отдает resolve. Для того что бы отдать данные дальше и нужно создавать новый промис.
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //       
    //         console.log(x);
    //         resolve(x);
    //     }, 2_000);
    //  
    // });
    //
    // prom.then((x) => {
    //     const prom2 = new Promise((resolve) =>{
    //         setTimeout(() => {
    //             let  x2 = x + 2;
    //               console.log(x2);
    //               resolve(x2);
    //           }, 2_000);
    //     });
    //
    //     prom2.then((x2) => {
    //    
    //         setTimeout(() => {
    //         let    x3 = x2 + 4;
    //             console.log(x3);
    //         }, 2_000);
    //     });
    // }); 
    //*** Но второй then обращается к prom2.then внутри предыдущего then потому что глобально нового промиса не существует
    //он существует в prom.then - первом then. И для дальнейшего вызова снова нужно создавать новый рпомис prom3, это
    //неудобно и накладывает ограничения, поэтому в коде ниже мы будет ВОЗВРАЩАТЬ новый промис для последующего взаимодействия
    //с then  и для того что бы не создавать каждый раз новый промис и называть его. После первого resolve, дальнейшая 
    //передача данных осуществляется через return
    //*** На завершённых промисах обработчики запускаются сразу
    //Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его. Однако, если промис уже завершён, 
    //то обработчики выполнятся сразу. Что бы таймауты работали правильно нужно каждый раз вызывать новый промис
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //         console.log(x);
    //         resolve(x);
    //     }, 1_000);
    //    
    // });
    //
    // prom.then(x => {
    //     return new Promise((resolve, reject) =>{
    //         setTimeout(() => {
    //             x = x + 2;
    //             console.log(x);
    //             resolve(x);
    //           }, 1_000);
    //     });
    // }).then(x => {
    //     return new Promise((resolve, reject) =>{
    //     x = x + 4;
    //     setTimeout(() => {console.log(x); resolve(x);}, 1_000);
    //     //return x;
    //     });
    // }).then(x => {
    //     return new Promise((resolve, reject) =>{
    //      x = x + 5; 
    //      setTimeout(() => {console.log(x); resolve(x);}, 1_000);
    //      //return x;
    //      });
    // }).then(x => {
    //     return new Promise((resolve, reject) =>{
    //     x = x + 5;
    //     setTimeout(() => {console.log(x); resolve(x);}, 1_000);
    //     //return x;
    //     });
    // }).catch(() =>{
    //     new Error("…");
    // }).finally(() => {console.log(`Job's done`)});


    //По сравнению с обычными колбеками преимуществом промисов является то что мы можем возвращать промис из then по цепочке.
    //Когда одна операция выполнится, выполним следующую, и т.д. сокращая написание функции вот так
    // req.then(product => {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             product.status = 'Ordered';
    //             resolve(product);
    //         }, 2000);
    //     });
    // }).then(data => {
    //     data.modify = true;
    //     return data;
    // }).then((prevData) => {
    //     console.log(prevData);
    // });

    //***МОЙ ПРИМЕР*** setTimeout работает нормально только в паре с resolve. Если в then уже идет return, из тайм аута он не вернет 
    //значение, его нужно использовать вне таймаута, наверное из-за этого все итерации с then и  return после первого выполняются
    //мгновенно. В консоль получаем 10 12 16 21 26. 10 12 - с интервалом 2 скунды и еще через 2 секунды  сразу 3 числа 16 21 26
    // const prom = new Promise((resolve, reject) => {
    //     let x = 5*2;
    //     setTimeout(() => {
    //        
    //         console.log(x);
    //         resolve(x);
    //     }, 2_000);
    //    
    // });
    //
    // prom.then(x => {
    //     return new Promise((resolve) =>{
    //         setTimeout(() => {
    //             x = x + 2;
    //             console.log(x);
    //             resolve(x);
    //           }, 2_000);
    //     });
    // }).then(x => {
    //     x = x + 4;
    //     setTimeout(() => {console.log(x);}, 3_000);
    //     return x;
    // }).then(x => {
    //      x = x + 5; 
    //     setTimeout(() => {console.log(x);}, 3_000);
    //     return x;
    // }).then(x => {
    //     x = x + 5;
    //     setTimeout(() => {console.log(x);}, 3_000);
    // });
        


    //При помощи reject обрабатывается невыполнение кода из-за ссылки на несуществующий файл при его запросе, не существующий сервер,
    // падение сервера и его ответ - ошибка. Метод catch обычно идет в конце. При ошибке все then пропускаются и выполнение кода
    //переходит на catch. (При возникновении ошибки – она отправляется в ближайший обработчик onRejected.)
            req.then(product => {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        product.status = 'Ordered';
                        resolve(product);
                    }, 2000);
                });
            }).then(data => {
                data.modify = true;
                return data;
            }).then((prevData) => {
                console.log(prevData);
            }).catch(() => {
                console.error('Произошла ошибка');
            }).finally(() => {
                console.log('Finally');
            });
    // Блок finally всегда в конце - позволяет выполнить действия не зависимо от успеха выполнения кода. Используется например для
    //очистки формы от старых данных по завершении работы кода

    //Пример с learn.javascript.ru/promise
    // 'use strict';
    // httpGet('/article/promise/userNoGithub.json')
    // .then(JSON.parse)
    // .then(user => httpGet(`https://api.github.com/users/${user.name}`))
    // .then(
    //     JSON.parse,
    //     function githubError(error) {
    //     if (error.code == 404) {
    //         return {name: "NoGithub", avatar_url: '/article/promise/anon.png'};
    //     } else {
    //         throw error;
    //     }
    //     }
    // )
    // .then(function showAvatar(githubUser) {
    //     let img = new Image();
    //     img.src = githubUser.avatar_url;
    //     img.className = "promise-avatar-example";
    //     document.body.appendChild(img);
    //     setTimeout(() => img.remove(), 3000);
    // })
    // .catch(function genericError(error) {
    //     alert(error); // Error: Not Found
    // });

        
    // Промисификация – это когда берут асинхронную функциональность и делают для неё обёртку, возвращающую промис.
    // После промисификации использование функциональности зачастую становится гораздо удобнее.
    // В качестве примера сделаем такую обёртку для запросов при помощи XMLHttpRequest.
    // Функция httpGet(url) будет возвращать промис, который при успешной загрузке данных с url будет переходить в
    // fulfilled с этими данными, а при ошибке – в rejected с информацией об ошибке:      

    //Пример с learn.javascript.ru/promise    
    // function httpGet(url) {
    //     return new Promise(function(resolve, reject) {
        
    //       var xhr = new XMLHttpRequest();
    //       xhr.open('GET', url, true);
        
    //       xhr.onload = function() {
    //         if (this.status == 200) {
    //           resolve(this.response);
    //         } else {
    //           var error = new Error(this.statusText);
    //           error.code = this.status;
    //           reject(error);
    //         }
    //       };
        
    //       xhr.onerror = function() {
    //         reject(new Error("Network Error"));
    //       };
        
    //       xhr.send();
    //     });
    //   }   

    //Использование:
    //     httpGet("/article/promise/user.json")
    //   .then(
    //     response => alert(`Fulfilled: ${response}`),
    //     error => alert(`Rejected: ${error}`)
    //   );


    //Рассмотрим методы all и race - принимают аргументом массив с промисами

    // Эта функция запускается принимает аргумент time(колю времени) возвращает Promise который зарезолвится через время time
    //Эту функцию используют для запуска одинаковых операций через разные промежутки времени
    const test = time => {
        return new Promise(resolve => { // ***Очень редко бывает второй аргумент reject не нужен, тогда мы его не передаем
            setTimeout(() => resolve(), time); //resolve выполнится через time
        });
    };

    test(1000).then(() => console.log('1000 ms')); // - console.log - через then для того что бы увидеть результат
    test(2000).then(() => console.log('2000 ms'));
    test(3000).then(() => console.log('3000 ms'));

    // all получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, 
    //пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.
    //Промисы вернут результат который можем обработать через then. Этот метод служит для того что бы точно убедится что все
    //промисы выполнились. Например запрашиваем 4 картинки из разных серверов, и что бы одновременно их показать ждем пока 
    //все промисы выполнятся. Ориентируемся на промис который выполнится последним. Если какой-то из промисов завершился с ошибкой,
    // то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются.
    Promise.all([test(1000), test(2000), test(3000)]).then(() => {
        console.log('All');
    });
    //Можно дописать catch для обработки ошибки

    // Пример с learn.javascript.ru/promise
    // Promise.all([
    //     httpGet('/article/promise/user.json'),
    //     httpGet('/article/promise/guest.json'),
    //     httpGet('/article/promise/no-such-page.json') // (нет такой страницы)
    //   ]).then(
    //     result => alert("не сработает"),
    //     error => alert("Ошибка: " + error.message) // Ошибка: Not Found
    //   )

        
    // race  - в отличие от all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.
    //этот метод начнет выполнятся как только выполнится самый первый промис из массива
    Promise.race([test(1000), test(2000), test(3000)]).then(() => {
        console.log('Race');
    });
    // 1000 ms
    // Race
    // 2000 ms
    // 3000 ms
    // All

    //     Пример с learn.javascript.ru/promise
    //     Promise.race([
    //         httpGet('/article/promise/user.json'),
    //         httpGet('/article/promise/guest.json')
    //       ]).then(firstResult => {
    //         firstResult = JSON.parse(firstResult);
    //         alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше
    //       });


    // ИТОГО
    // Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и колбэки.

    // При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, 
    //которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке.

    // Аргумент resolve/reject (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.

    // Обработчики назначаются вызовом .then/catch.

    // Для передачи результата от одного обработчика к другому используется чейнинг.

    // У промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для «отмены» промиса, 
    //хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.

    // В современной JavaScript-разработке сложные цепочки с промисами используются редко, так как они куда проще 
    //описываются при помощи генераторов с библиотекой co, которые рассмотрены в соответствующей главе. Можно сказать, 
    //что промисы лежат в основе более продвинутых способов асинхронной разработки.

    //***Функция для выполнения действия через заданное количество времени на промисе
    // function delay(ms) {
    //     return new Promise(resolve => setTimeout(resolve, ms));
    //   }
    //   delay(1000).then(() => console.log('выполнилось через 1 секунду'));
    //   delay(2000).then(() => console.log('выполнилось через 2 секунду'));
    //   delay(3000).then(() => console.log('выполнилось через 3 секунду'));
    //Заметьте, что resolve вызывается без аргументов. Мы не возвращаем из delay ничего, просто гарантируем задержку.

}



{//         ====    ЦЕПОЧКА ПРОМИСОВ  https://learn.javascript.ru/promise-chaining    ====
    
    // Давайте вернёмся к ситуации из главы Введение: колбэки: у нас есть последовательность асинхронных задач, которые должны
    // быть выполнены одна за другой. Например, речь может идти о загрузке скриптов. Как же грамотно реализовать это в коде?

    // Промисы предоставляют несколько способов решения подобной задачи.

    // В этой главе мы разберём цепочку промисов.

    // Она выглядит вот так:
        
    new Promise(function(resolve, reject) {

        setTimeout(() => resolve(1), 1000); // (*)

    }).then(function(result) { // (**)

        alert(result); // 1
        return result * 2;

    }).then(function(result) { // (***)

        alert(result); // 2
        return result * 2;

    }).then(function(result) {

        alert(result); // 4
        return result * 2;

    });
    // Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.

    // Поток выполнения такой:

    // Начальный промис успешно выполняется через 1 секунду (*),
    // Затем вызывается обработчик в .then (**).
    // Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
    // …и так далее.
    // В итоге результат передаётся по цепочке обработчиков, и мы видим несколько alert подряд, которые выводят: 1 → 2 → 4.


    // Всё это работает, потому что вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.

    // Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в 
    //следующий .then.

    // Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису. Но это не цепочка.

    // Например:

    let promise = new Promise(function(resolve, reject) {
        setTimeout(() => resolve(1), 1000);
    });

    promise.then(function(result) {
        alert(result); // 1
        return result * 2;
    });

    promise.then(function(result) {
        alert(result); // 1
        return result * 2;
    });

    promise.then(function(result) {
        alert(result); // 1
        return result * 2;
    });

    // Мы добавили несколько обработчиков к одному промису. Они не передают друг другу результаты своего выполнения, а действуют 
    //независимо.

    // Все обработчики .then на одном и том же промисе получают одно и то же значение – результат выполнения того же самого промиса.
    //Таким образом, в коде выше все alert показывают одно и то же: 1.

    // На практике весьма редко требуется назначать несколько обработчиков одному промису. А вот цепочка промисов используется куда
    // чаще.

    // Возвращаем промисы
    // Обработчик handler, переданный в .then(handler), может вернуть промис.

    // В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.

    // Например:
        
    new Promise(function(resolve, reject) {

        setTimeout(() => resolve(1), 1000);

    }).then(function(result) {

        alert(result); // 1

        return new Promise((resolve, reject) => { // (*)
        setTimeout(() => resolve(result * 2), 1000);
        });

    }).then(function(result) { // (**)

        alert(result); // 2

        return new Promise((resolve, reject) => {
        setTimeout(() => resolve(result * 2), 1000);
        });

    }).then(function(result) {

        alert(result); // 4

    });
    // Здесь первый .then показывает 1 и возвращает новый промис new Promise(…) в строке (*). Через одну секунду этот промис успешно
    //  выполняется, и его результат (аргумент в resolve, то есть result * 2) передаётся обработчику в следующем .then. Он находится
    //   в строке (**), показывает2 и делает то же самое.

    // Таким образом, как и в предыдущем примере, выводятся 1 → 2 → 4, но сейчас между вызовами alert существует пауза в 1 секунду.

    // Возвращая промисы, мы можем строить цепочки из асинхронных действий.

    // Пример: loadScript
    function loadScript(src) {
        return new Promise(function(resolve, reject) {
        let script = document.createElement('script');
        script.src = src;
    
        script.onload = () => resolve(script);
        script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));
    
        document.head.append(script);
        });
    }
    // Давайте используем эту возможность вместе с промисифицированной функцией loadScript, созданной нами в предыдущей главе, чтобы
    // загружать скрипты по очереди, последовательно:

    loadScript("/article/promise-chaining/one.js")
        .then(function(script) {
        return loadScript("/article/promise-chaining/two.js");
        })
        .then(function(script) {
        return loadScript("/article/promise-chaining/three.js");
        })
        .then(function(script) {
        // вызовем функции, объявленные в загружаемых скриптах,
        // чтобы показать, что они действительно загрузились
        one();
        two();
        three();
        });
    // Этот же код можно переписать немного компактнее, используя стрелочные функции:

    loadScript("/article/promise-chaining/one.js")
        .then(script => loadScript("/article/promise-chaining/two.js"))
        .then(script => loadScript("/article/promise-chaining/three.js"))
        .then(script => {
        // скрипты загружены, мы можем использовать объявленные в них функции
        one();
        two();
        three();
        });
    // Здесь каждый вызов loadScript возвращает промис, и следующий обработчик в .then срабатывает, только когда этот промис завершается.
    //  Затем инициируется загрузка следующего скрипта и так далее. Таким образом, скрипты загружаются один за другим.

    // Мы можем добавить и другие асинхронные действия в цепочку. Обратите внимание, что наш код всё ещё «плоский», он «растёт» вниз,
    //  а не вправо. Нет никаких признаков «адской пирамиды вызовов».

    // Технически мы бы могли добавлять .then напрямую к каждому вызову loadScript, вот так:

    loadScript("/article/promise-chaining/one.js").then(script1 => {
        loadScript("/article/promise-chaining/two.js").then(script2 => {
        loadScript("/article/promise-chaining/three.js").then(script3 => {
            // эта функция имеет доступ к переменным script1, script2 и script3
            one();
            two();
            three();
        });
        });
    });
    // Этот код делает то же самое: последовательно загружает 3 скрипта. Но он «растёт вправо», так что возникает такая же проблема,
    //  как и с колбэками.

    // Разработчики, которые не так давно начали использовать промисы, иногда не знают про цепочки и пишут код именно так, как
    //  показано выше. В целом, использование цепочек промисов предпочтительнее.

    // Иногда всё же приемлемо добавлять .then напрямую, чтобы вложенная в него функция имела доступ к внешней области видимости.
    //  В примере выше самая глубоко вложенная функция обратного вызова имеет доступ ко всем переменным script1, script2, script3.
    //   Но это скорее исключение, чем правило.

    // Thenable
    // Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, такие объекты
    //  называют «thenable», и этот объект будет обработан как промис.

    // Смысл в том, что сторонние библиотеки могут создавать свои собственные совместимые с промисами объекты. Они могут иметь свои
    //  наборы методов и при этом быть совместимыми со встроенными промисами, так как реализуют метод .then.

    // Вот пример такого объекта:

    class Thenable {
        constructor(num) {
        this.num = num;
        }
        then(resolve, reject) {
        alert(resolve); // function() { native code }
        // будет успешно выполнено с аргументом this.num*2 через 1 секунду
        setTimeout(() => resolve(this.num * 2), 1000); // (**)
        }
    }

    new Promise(resolve => resolve(1))
        .then(result => {
        return new Thenable(result); // (*)
        })
        .then(alert); // показывает 2 через 1000мс
    // JavaScript проверяет объект, возвращаемый из обработчика .then в строке (*): если у него имеется метод then, который можно
    //  вызвать, то этот метод вызывается, и в него передаются как аргументы встроенные функции resolve и reject, вызов одной из 
    //  которых потом ожидается. В примере выше происходит вызов resolve(2) через 1 секунду (**). Затем результат передаётся дальше
    //   по цепочке.

    // Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от Promise.

    // Более сложный пример: fetch
    // Во фронтенд-разработке промисы часто используются, чтобы делать запросы по сети. Давайте рассмотрим один такой пример.

    // Мы будем использовать метод fetch, чтобы подгрузить информацию о пользователях с удалённого сервера. Этот метод имеет много
    //  опциональных параметров, разобранных в соответствующих разделах, но базовый синтаксис весьма прост:

    // let promise = fetch(url);
    // Этот код запрашивает по сети url и возвращает промис. Промис успешно выполняется и в свою очередь возвращает объект response
    //  после того, как удалённый сервер присылает заголовки ответа, но до того, как весь ответ сервера полностью загружен.

    // Чтобы прочитать полный ответ, надо вызвать метод response.text(): он тоже возвращает промис, который выполняется, когда данные
    //  полностью загружены с удалённого сервера, и возвращает эти данные.

    // Код ниже запрашивает файл user.json и загружает его содержимое с сервера:

    fetch('/article/promise-chaining/user.json')
        // .then в коде ниже выполняется, когда удалённый сервер отвечает
        .then(function(response) {
        // response.text() возвращает новый промис,
        // который выполняется и возвращает полный ответ сервера,
        // когда он загрузится
        return response.text();
        })
        .then(function(text) {
        // ...и здесь содержимое полученного файла
        alert(text); // {"name": "iliakan", isAdmin: true}
        });
    // Есть также метод response.json(), который читает данные в формате JSON. Он больше подходит для нашего примера, так что
    //  давайте использовать его.

    // Мы также применим стрелочные функции для более компактной записи кода:

    // то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
    fetch('/article/promise-chaining/user.json')
        .then(response => response.json())
        .then(user => alert(user.name)); // iliakan, получили имя пользователя
    // Теперь давайте что-нибудь сделаем с полученными данными о пользователе.

    // Например, мы можем послать запрос на GitHub, чтобы загрузить данные из профиля пользователя и показать его аватар:

    // Запрашиваем user.json
    fetch('/article/promise-chaining/user.json')
        // Загружаем данные в формате json
        .then(response => response.json())
        // Делаем запрос к GitHub
        .then(user => fetch(`https://api.github.com/users/${user.name}`))
        // Загружаем ответ в формате json
        .then(response => response.json())
        // Показываем аватар (githubUser.avatar_url) в течение 3 секунд (возможно, с анимацией)
        .then(githubUser => {
        let img = document.createElement('img');
        img.src = githubUser.avatar_url;
        img.className = "promise-avatar-example";
        document.body.append(img);

        setTimeout(() => img.remove(), 3000); // (*)
        });
    // Код работает, детали реализации отражены в комментариях. Однако в нём есть одна потенциальная проблема, 
    // с которой часто сталкиваются новички.

    // Посмотрите на строку (*): как мы можем предпринять какие-то действия после того, как аватар был показан и удалён? 
    // Например, мы бы хотели показывать форму редактирования пользователя или что-то ещё. Сейчас это невозможно.

    // Чтобы сделать наш код расширяемым, нам нужно возвращать ещё один промис, который выполняется после того, как 
    // завершается показ аватара.

    // Примерно так:

    fetch('/article/promise-chaining/user.json')
        .then(response => response.json())
        .then(user => fetch(`https://api.github.com/users/${user.name}`))
        .then(response => response.json())
        .then(githubUser => new Promise(function(resolve, reject) { // (*)
        let img = document.createElement('img');
        img.src = githubUser.avatar_url;
        img.className = "promise-avatar-example";
        document.body.append(img);

        setTimeout(() => {
            img.remove();
            resolve(githubUser); // (**)
        }, 3000);
        }))
        // срабатывает через 3 секунды
        .then(githubUser => alert(`Закончили показ ${githubUser.name}`));
    // То есть, обработчик .then в строке (*) будет возвращать new Promise, который перейдёт в состояние «выполнен» только после того,
    //  как в setTimeout (**) будет вызвана resolve(githubUser).

    // Соответственно, следующий по цепочке .then будет ждать этого.

    // Как правило, все асинхронные действия должны возвращать промис.

    // Это позволяет планировать после него какие-то дополнительные действия. Даже если эта возможность не нужна прямо сейчас,
    //  она может понадобиться в будущем.

    // И, наконец, давайте разобьём написанный код на отдельные функции, пригодные для повторного использования:

    function loadJson(url) {
        return fetch(url)
        .then(response => response.json());
    }

    function loadGithubUser(name) {
        return fetch(`https://api.github.com/users/${name}`)
        .then(response => response.json());
    }

    function showAvatar(githubUser) {
        return new Promise(function(resolve, reject) {
        let img = document.createElement('img');
        img.src = githubUser.avatar_url;
        img.className = "promise-avatar-example";
        document.body.append(img);

        setTimeout(() => {
            img.remove();
            resolve(githubUser);
        }, 3000);
        });
    }

    // Используем их:
    loadJson('/article/promise-chaining/user.json')
        .then(user => loadGithubUser(user.name))
        .then(showAvatar)
        .then(githubUser => alert(`Показ аватара ${githubUser.name} завершён`));
        // ...
    // Итого
    // Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут,
    //  пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.

}



{//  407    ====    Fetch API, promise + server    ====

    // API - Application Programming Interface (интерфейс программного приложения). Это набор данных и возможностей которые 
    //предоставляет нам какое то готовое решение, мы уже пользуемся DOM API (document.qerySelector - используя методы doument)

    // Fetch API - уже встроена в браузер, построена на промисах и позволяет общаться с сервером.
    //Будем обращаться к jsonplaceholder.typicode.com - небольшая база данных в интернете к которой можно обращаться для тестирования

    // Что на сервере хранится
    // /posts	100 posts
    // /comments	500 comments
    // /albums	100 albums
    // /photos	5000 photos
    // /todos	200 todos
    // /users   10 users

    //Какие запросы можно отправлять
    // GET	/posts
    // GET	/posts/1
    // GET	/posts/1/comments
    // GET	/comments?postId=1
    // POST	/posts
    // PUT	/posts/1
    // PATCH	/posts/1
    // DELETE	/posts/1

    //На этом сайте есть пример как обращаться к базе, копируем его - обращаемся к todo
    //Без указания дополнительных параметров - это будет класический GET запрос который получит данные
    // response.json- встроенный метод fetch заменяет JSON.parse и возвращает promise(потому что не знаем сколько будет длится операция)
    // fetch('https://jsonplaceholder.typicode.com/todos/1') // 1 - уникальній идентификатор по которому делаем запрос (id: 1)
    //     .then(response => response.json()) 
    //     .then(json => console.log(json));
    // получили объект {userId: 1, id: 1, title: 'delectus aut autem', completed: false}
    //Также с сервера может прийти текст который нужно будет потом превратить в объект

    //Для формирования POST запроса нужно добавить объект с настройками (обязательные 2 свойства - mehod и body, желательно указывать
    // еще заголовки для указания что мы отправляем )
    // fetch('https://jsonplaceholder.typicode.com/posts', { // обращаемся к POST	/posts 
    //     method: "POST",
    //     body: JSON.stringify({name:"Alex"}),
    //     headers: {
    //         'Content-type': 'application/json'
    //     }
    // }) 
    // .then(response => response.json()) 
    // .then(json => console.log(json));
    // {name: 'Alex', id: 101} - запостили и получили назад ответ с фейковой id: 101, на самом деле мы ничего не записали на сервер
    //просто получили такой ответ, который говорит нам что все работает 

    // Метод запросов fetch намного проще XMLHttpRequest запросов. url задается одной строкой, а настройки идут одним объектом. Этот
    //метод запросов сейчас используется почти везде, однако можно встретить и XMLHttpRequest запросы.

    //======== Перписываем функционал сайта продуктов с использованием fetch
    //============================ 007 Переписываем запросы с помощью fetch
    // 1) отправим классическую формдейту 2) отправим JSON файл на наш сервер
    function postData(form) { 
        form.addEventListener('submit', (e) => {  
            e.preventDefault(); 
            
            //005 изменяем для показа картинки и класс
            const statusMessage = document.createElement('img');
            statusMessage.src = message.loading;
            //записываем инлайн стили что бы картинка была по центру
            statusMessage.style.cssText = `
                display: block;
                margin: 0 auto;
            `;
            //form.append(statusMessage);  - удалена в 005 что бы не сдвигалась форма используем insertAdjacentElement послеформы
            form.insertAdjacentElement('afterend', statusMessage);

            //007 Убираем этот запрос, вместо него будет fetch - который перемещаем ниже под создание formData
            // const req = new XMLHttpRequest(); 
            // req.open('POST', 'server.php'); 
            
            //007 из req.setRequestHeader берем headers только через двоеточие и удаляем строку
            //req.setRequestHeader('Content-type', 'application/json');
        
            const formData = new FormData(form);

            //007- пока закоментируем потому что  отправляем только FormData и превращать в json не нужно
            // const object = {};
            // formData.forEach(function(value, key){
            //     object[key] = value;
            // });
            // const json = JSON.stringify(object);

    
            // req.send(formData);  //007 убрано

                    //007  Раньше обрабатывали результат запроса так, теперь с помощью промисов
            // req.addEventListener('load', () => {
            //     if (req.status === 200) {
            //         console.log(req.response);
            //         showThanksModal(message.success); // запускаем нашу функцию с аргументом сообщением
            //         form.reset(); //Удалили таймаут потому что она будет использоваться только для спинера
            //         statusMessage.remove(); // удаляется спиннер   
            //     }else{
            //         showThanksModal(message.failure);
            //     }
            // });

            fetch('server.php', {
                method: 'POST',
                // headers: {                // заголовок раскоментируем когда будем отправлять json данные
                //     'Content-type': 'application/json'
                // },
                body: formData
            }).then(data => data.text()) //От сервера пришел отве Responce объект, но не данные которые мы отправляли, что бы их получить
            //что бы понимать какой ответ приходит нужно этот ответ модифицировать. В данном случае в текст, потому что мы знаем
            //что отправляли не json. ***Так же в Сервере .php  закоментируем строку для работы с json
            .then(data => { 
                console.log(data);
                showThanksModal(message.success); // запускаем нашу функцию с аргументом сообщением
                statusMessage.remove(); // удаляется спиннер  
            }).catch(() => {
                showThanksModal(message.failure); // Показываем ошибку если есть
            }).finally(() => {
                form.reset(); //очищаем форму в любом случае в конце этого кода
            });
        });
    }
    // Что бы передать JSON изменяем

    //007- пока закоментируем потому что  отправляем только FormData и превращать в json не нужно
            // const object = {};
            // formData.forEach(function(value, key){
            //     object[key] = value;
            // });

            // const json = JSON.stringify(object); // - избавляемся от лишней переменной и подставляем вместо formData

            fetch('server.php', {
                method: 'POST',
                headers: {                // заголовок раскоментируем для отправки json данных 
                    'Content-type': 'application/json' //***Так же в Сервере .php  раскомментируем строку для работы с json
                },
                body: JSON.stringify(object)
                //body: formData 
            }).then(data => data.text()) 
            .then(data => { 
                console.log(data);
                showThanksModal(message.success); // запускаем нашу функцию с аргументом сообщением
                statusMessage.remove(); // удаляется спиннер  
            }).catch(() => {
                showThanksModal(message.failure); // Показываем ошибку если есть
            }).finally(() => {
                form.reset(); //очищаем форму в любом случае в конце этого кода
            });

    //**** Проверим вывод ошибки для пользователя. Допустим ошибку в пути сервера server1.php, при этом в консоль выкидывается ошибка
    //но сообщение в модальном окне выводится как при положительном ответе. Это особенность fetch, промис который он запускает
    // не перейдет в состояни отклонено(rejected) из-за ответа http который считается ошибкой (404, 500, 502, ...) он все равно
    //выполнится нормально у него поменятся только status который будет false. (Еще раз простыми словами - если внутри фетча промис
    //попадает на ошибку которая связана с http протоколом - он не выкинет reject, для него это не считается ошибкой, он нормально
    //отработает resolve. Главное для фетча что он вообще смог сделать запрос, соответственно reject юудет только в случае сбоя сети
    // или если что то помешало запросу выполнится)

}



{//  408    ====    Методы перебора массивов и объектов    ====

    // 1) filter - фильтрует массив согласно заданному правилу и ***возвращает в новом массиве. Поэтому присваиваем результат переменной
    //в примере нужно получить все имена которые меньше 5 символов

    const names = ['Ivan', 'Ann', ' Ksenia', 'Volandemort'];

    const shortNames = names.filter(function(name) {
        return name.length < 5; // можно использовать запись через if if(name.length < 5) { return name.length;}
    });


    // 2) map - аналогичен forEach но ***возвращает новый массив
    //Нам нужно все элементы привести к нижнему регистру для дальнейшоего использования

    let answers = ['iVaN', 'AnnA', 'Hello'];

    const result = answers.map(item => {  //  сокращаем запись  answers.map(item => item.toLowerCase());
        return item.toLowerCase(); 
    });
    console.log(result); // ['ivan', 'anna', 'hello']

    // //Можно переприсвоить значение исходному массиву, объявляя его через let. 
    // //***С точки зрения Иммутабельности лучше создавать новую переменную
    answers = answers.map(item => item.toLocaleLowerCase()); // ['ivan', 'anna', 'hello']


    // 3) every/some
    // some - если хотя бы один эл. подходит под условие возвращает true
    //*** при использовании стрелочной записи функции return подставляется автоматически
    const some = [4, 'Some', 'user'];
    console.log(some.some(item => typeof(item) === 'number')); //true  сравниеваем эл. с типом number

    //every - true если все эл. массива подходят под условие
    console.log(some.every(item => typeof(item) === 'number')); //false  сравниеваем эл. с типом number


    // 4) reduce - собирает массив в единое целое ( чаще всего работает с числами)
    const arr = [4, 3, 2, 1];

    const result = arr.reduce((sum, current) => sum + current); //10

    //Можно проводить другие действия 
    //*** Если не задавать значение по умолчанию для sum - тогда оно равняется первому элементу массива 
    const resultMinus = arr.reduce((sum, current) => sum - current); // -2 (4 -3 -2 -1)
    //*** Если задать 0
    const resultMinus2 = arr.reduce((sum, current) => sum - current, 0); // -10 (0 -4 -3 -2 -1)

    const resultDouble = arr.reduce((sum, current) => (sum + current)*2, 0); // 98 ((0+4)*2 = (8+3)*2 = (22+2)*2 = (48+1)*2 = 98)

    //*** Массив со строками можно собрать в единую строку
    const str = ['Apple', 'Juice', 'Awesome'];
    //Метод 1 через конкатенацию
    const solidStr = str.reduce((sum, current) => sum + ', ' + current); //Apple, Juice, Awesome
    //Метод 2 через интерполяцию
    const solidStr2 = str.reduce((sum, current) => `${sum}, ${current}`); //Apple, Juice, Awesome


    //*** ПРАКТИЧЕСКИЙ ПРИМЕР
    // После обращения к серверу с него пришел объект с поменяными сетами названиями и свойствами (так делают потому что объект не может
    // содержать одинаковые названия свойств). Задача - вытащить имена пользователей ivan и ann, при том что расположение свойств 
    //в объекте неизвестно (индекс не известен)
    const obj = {
        ivan: 'persone',
        ann: 'persone',
        dog: 'animal',
        cat: 'animal'
    };

    // entries - метод для преобразования объекта в матрицу (*НОВЫЙ массив с вложенными массивами)
        //const newArr = Object.entries(obj);  // [ ['ivan', 'persone'], ['ann', 'persone'], ['dog', 'animal'], ['cat', 'animal'] ]

    //теперь фильтруем массив и оставляем те массивы у которых вторым эл. persone. Сделаем это методом цепочек(chaining) как промисы
    const newArr = Object.entries(obj)
    .filter(item => item[1] === 'persone')  //[ ['ivan', 'persone'], ['ann', 'persone'] ] снова используем цепочку
    .map(item => item[0]);                  // ['ivan', 'ann']

}



{//  409    ====    Подробно про npm и проект. JSON-server    ====

}



{//         ====    Деструктуризация / todo list    ====

}
